[
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Moonship Smart Contract/contracts-74658f327c56d66dae8e9c96bffa3f98e806c831/moonship.sol",
        "contract": "MoonShip",
        "function": "claimBNBReward",
        "line": 1324,
        "line_end": 1346,
        "name": "reentrancy-no-eth",
        "code_segment": "contract MoonShip is Context, IBEP20, Ownable, ReentrancyGuard {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    mapping(address => bool) private _isExcludedFromFee;\n    mapping(address => bool) private _isExcluded;\n    mapping(address => bool) private _isExcludedFromMaxTx;\n\n    address[] private _excluded;\n\n    uint256 private constant MAX = ~uint256(0);\n    uint256 private _tTotal = 1000000000 * 10 ** 6 * 10 ** 18;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 private _tFeeTotal;\n\n    string private _name = \"MoonShip Token\";\n    string private _symbol = \"MSP\";\n    uint8 private _decimals = 18;\n\n    InutRouter02 public immutable nutRouter;\n    address public immutable nutPair;\n\n    bool inSwapAndLiquify = false;\n\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n\n    event ClaimBNBSuccessfully(\n        address recipient,\n        uint256 ethReceived,\n        uint256 nextAvailableClaimDate\n    );\n\n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n\n    constructor (\n        address payable routerAddress\n    ) public {\n        _rOwned[_msgSender()] = _rTotal;\n\n        InutRouter02 _nutRouter = InutRouter02(routerAddress);\n        // Create a pancake pair for this new token\n        nutPair = IPancakeFactory(_nutRouter.factory())\n        .createPair(address(this), _nutRouter.WETH());\n\n        // set the rest of the contract variables\n        nutRouter = _nutRouter;\n\n        //exclude owner and this contract from fee\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n\n        // exclude from max tx\n        _isExcludedFromMaxTx[owner()] = true;\n        _isExcludedFromMaxTx[address(this)] = true;\n        _isExcludedFromMaxTx[address(0x000000000000000000000000000000000000dEaD)] = true;\n        _isExcludedFromMaxTx[address(0)] = true;\n\n        emit Transfer(address(0), _msgSender(), _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n//SWC-107-Reentrancy:L995.1009\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount, 0);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount, 0);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\n        return true;\n    }\n\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n    function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns (uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns (uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate = _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    function excludeFromReward(address account) public onlyOwner() {\n        require(!_isExcluded[account], \"Account is already excluded\");\n        if (_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcluded[account] = true;\n        _excluded.push(account);\n    }\n\n    function includeInReward(address account) external onlyOwner() {\n        require(_isExcluded[account], \"Account is already excluded\");\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_excluded[i] == account) {\n                _excluded[i] = _excluded[_excluded.length - 1];\n                _tOwned[account] = 0;\n                _isExcluded[account] = false;\n                _excluded.pop();\n                break;\n            }\n        }\n    }\n\n    function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n\n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n\n    function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n        _taxFee = taxFee;\n    }\n\n    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n        _liquidityFee = liquidityFee;\n    }\n\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n        swapAndLiquifyEnabled = _enabled;\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\n    }\n\n    //to receive BNB from nutRouter when swapping\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n        uint256 tFee = calculateTaxFee(tAmount);\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n        return (tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 currentRate = _getRate();\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n        if (_isExcluded[address(this)])\n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n    }\n\n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_taxFee).div(\n            10 ** 2\n        );\n    }\n\n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_liquidityFee).div(\n            10 ** 2\n        );\n    }\n\n    function removeAllFee() private {\n        if (_taxFee == 0 && _liquidityFee == 0) return;\n\n        _previousTaxFee = _taxFee;\n        _previousLiquidityFee = _liquidityFee;\n\n        _taxFee = 0;\n        _liquidityFee = 0;\n    }\n\n    function restoreAllFee() private {\n        _taxFee = _previousTaxFee;\n        _liquidityFee = _previousLiquidityFee;\n    }\n\n    function isExcludedFromFee(address account) public view returns (bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 value\n    ) private {\n        require(from != address(0), \"BEP20: transfer from the zero address\");\n        require(to != address(0), \"BEP20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n\n        ensureMaxTxAmount(from, to, amount, value);\n\n        // swap and liquify\n        swapAndLiquify(from, to);\n\n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromFee[from] || _isExcludedFromFee[to]) {\n            takeFee = false;\n        }\n\n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from, to, amount, takeFee);\n    }\n\n    //this method is responsible for taking all fee, if takeFee is true\n    function _tokenTransfer(address sender, address recipient, uint256 amount, bool takeFee) private {\n        if (!takeFee)\n            removeAllFee();\n\n        // top up claim cycle\n        topUpClaimCycleAfterTransfer(recipient, amount);\n\n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n//SWC-135-Code With No Effects:L1245\n        if (!takeFee)\n            restoreAllFee();\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    // Innovation for protocol by MoonRat Team\n    uint256 public rewardCycleBlock = 7 days;\n    uint256 public easyRewardCycleBlock = 1 days;\n    uint256 public threshHoldTopUpRate = 2; // 2 percent\n    uint256 public _maxTxAmount = _tTotal; // should be 0.05% percent per transaction, will be set again at activateContract() function\n    uint256 public disruptiveCoverageFee = 2 ether; // antiwhale\n    mapping(address => uint256) public nextAvailableClaimDate;\n    bool public swapAndLiquifyEnabled = false; // should be true\n    uint256 public disruptiveTransferEnabledFrom = 0;\n    uint256 public disableEasyRewardFrom = 0;\n    uint256 public winningDoubleRewardPercentage = 5;\n\n    uint256 public _taxFee = 2;\n    uint256 private _previousTaxFee = _taxFee;\n\n    uint256 public _liquidityFee = 8; // 4% will be added pool, 4% will be converted to HT\n    uint256 private _previousLiquidityFee = _liquidityFee;\n    uint256 public rewardThreshold = 1 ether;\n\n    uint256 minTokenNumberToSell = _tTotal.mul(1).div(10000).div(10); // 0.001% max tx amount will trigger swap and add liquidity\n\n    function setMaxTxPercent(uint256 maxTxPercent) public onlyOwner() {\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(10000);\n    }\n\n    function setExcludeFromMaxTx(address _address, bool value) public onlyOwner {\n        _isExcludedFromMaxTx[_address] = value;\n    }\n\n    function calculateBNBReward(address ofAddress) public view returns (uint256) {\n        uint256 tSupply = uint256(_tTotal)\n        .sub(balanceOf(address(0)))\n        .sub(balanceOf(0x000000000000000000000000000000000000dEaD)) // exclude burned wallet\n        .sub(balanceOf(0x0d15E114cdD9F3f2B3bc0De19D5C9c5e4994ee8F)) // exclude dev wallet\n        .sub(balanceOf(address(nutPair)));\n        // exclude liquidity wallet\n\n        return Utils.calculateBNBReward(\n            _tTotal,\n            balanceOf(address(ofAddress)),\n            address(this).balance,\n            winningDoubleRewardPercentage,\n            tSupply,\n            ofAddress\n        );\n    }\n\n    function getRewardCycleBlock() public view returns (uint256) {\n        if (block.timestamp >= disableEasyRewardFrom) return rewardCycleBlock;\n        return easyRewardCycleBlock;\n    }\n\n    function claimBNBReward() isHuman nonReentrant public {\n        require(nextAvailableClaimDate[msg.sender] <= block.timestamp, 'Error: next available not reached');\n        require(balanceOf(msg.sender) >= 0, 'Error: must own MRAT to claim reward');\n\n        uint256 reward = calculateBNBReward(msg.sender);\n\n        // reward threshold\n        if (reward >= rewardThreshold) {\n            Utils.swapETHForTokens(\n                address(nutRouter),\n                address(0x000000000000000000000000000000000000dEaD), \n                reward.div(5)\n            );\n            reward = reward.sub(reward.div(5));\n        }\n\n        // update rewardCycleBlock\n        nextAvailableClaimDate[msg.sender] = block.timestamp + getRewardCycleBlock();\n        emit ClaimBNBSuccessfully(msg.sender, reward, nextAvailableClaimDate[msg.sender]);\n\n        (bool sent,) = address(msg.sender).call{value : reward}(\"\");\n        require(sent, 'Error: Cannot withdraw reward');\n    }\n\n    function topUpClaimCycleAfterTransfer(address recipient, uint256 amount) private {\n        uint256 currentRecipientBalance = balanceOf(recipient);\n        uint256 basedRewardCycleBlock = getRewardCycleBlock();\n\n        nextAvailableClaimDate[recipient] = nextAvailableClaimDate[recipient] + Utils.calculateTopUpClaim(\n            currentRecipientBalance,\n            basedRewardCycleBlock,\n            threshHoldTopUpRate,\n            amount\n        );\n    }\n\n    function ensureMaxTxAmount(\n        address from,\n        address to,\n        uint256 amount,\n        uint256 value\n    ) private view {\n        if (\n            _isExcludedFromMaxTx[from] == false && // default will be false\n            _isExcludedFromMaxTx[to] == false // default will be false\n        ) {\n            if (value < disruptiveCoverageFee && block.timestamp >= disruptiveTransferEnabledFrom) {\n                require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n            }\n        }\n    }\n\n    function disruptiveTransfer(address recipient, uint256 amount) public payable returns (bool) {\n        _transfer(_msgSender(), recipient, amount, msg.value);\n        return true;\n    }\n\n    function swapAndLiquify(address from, address to) private {\n        // is the token balance of this contract address over the min number of\n        // tokens that we need to initiate a swap + liquidity lock?\n        // also, don't get caught in a circular liquidity event.\n        // also, don't swap & liquify if sender is pancake pair.\n        uint256 contractTokenBalance = balanceOf(address(this));\n\n        if (contractTokenBalance >= _maxTxAmount) {\n            contractTokenBalance = _maxTxAmount;\n        }\n\n        bool shouldSell = contractTokenBalance >= minTokenNumberToSell;\n\n        if (\n            !inSwapAndLiquify &&\n        shouldSell &&\n        from != nutPair &&\n        swapAndLiquifyEnabled &&\n        !(from == address(this) && to == address(nutPair)) // swap 1 time\n        ) {\n            // only sell for minTokenNumberToSell, decouple from _maxTxAmount\n            contractTokenBalance = minTokenNumberToSell;\n\n            // add liquidity\n            // split the contract balance into 3 pieces\n            uint256 pooledBNB = contractTokenBalance.div(2);\n            uint256 piece = contractTokenBalance.sub(pooledBNB).div(2);\n            uint256 otherPiece = contractTokenBalance.sub(piece);\n\n            uint256 tokenAmountToBeSwapped = pooledBNB.add(piece);\n\n            uint256 initialBalance = address(this).balance;\n\n            // now is to lock into staking pool\n            Utils.swapTokensForEth(address(nutRouter), tokenAmountToBeSwapped);\n\n            // how much BNB did we just swap into?\n\n            // capture the contract's current BNB balance.\n            // this is so that we can capture exactly the amount of BNB that the\n            // swap creates, and not make the liquidity event include any BNB that\n            // has been manually sent to the contract\n            uint256 deltaBalance = address(this).balance.sub(initialBalance);\n\n            uint256 bnbToBeAddedToLiquidity = deltaBalance.div(3);\n\n            // add liquidity to pancake\n            Utils.addLiquidity(address(nutRouter), owner(), otherPiece, bnbToBeAddedToLiquidity);\n\n            emit SwapAndLiquify(piece, deltaBalance, otherPiece);\n        }\n    }\n\n    function activateContract() public onlyOwner {\n        // reward claim\n        disableEasyRewardFrom = block.timestamp + 1 weeks;\n        rewardCycleBlock = 7 days;\n        easyRewardCycleBlock = 1 days;\n\n        winningDoubleRewardPercentage = 5;\n\n        // protocol\n        disruptiveCoverageFee = 2 ether;\n        disruptiveTransferEnabledFrom = block.timestamp;\n        setMaxTxPercent(1);\n        setSwapAndLiquifyEnabled(true);\n\n        // approve contract\n        _approve(address(this), address(nutRouter), 2 ** 256 - 1);\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-Pud.Fi Masterchef_Audit/MasterChef0x15Bee180BB39eE5c0166E63313C33984376930Db/contracts/MasterChef.sol",
        "contract": "MasterChef",
        "function": "safePudTransfer",
        "line": 1444,
        "line_end": 1451,
        "name": "unchecked-transfer",
        "code_segment": "contract MasterChef is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 shares; // How many LP tokens shares the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of Pud\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.shares * pool.accPudPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accPudPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        IERC20 lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. Pud to distribute per block.\n        uint256 lastRewardBlock; // Last block number that Pud distribution occurs.\n        uint256 accPudPerShare; // Accumulated Pud per share, times 1e12. See below.\n        address strategy;\n        uint256 totalShares;\n    }\n\n    // The Pud TOKEN!\n    PudToken public pud;\n    // Dev fund (10%, initially)\n    uint256 public devFundDivRate = 10;\n    // Dev address.\n    address public devaddr;\n    // Treasure address.\n    address public treasury;\n    // Block number when bonus Pud period ends.\n    uint256 public bonusEndBlock;\n    // Pud tokens created per block.\n    uint256 public pudPerBlock;\n    // Bonus muliplier for early pud makers.\n    uint256 public constant BONUS_MULTIPLIER = 10;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfo;\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when Pud mining starts.\n    uint256 public startBlock;\n\n    // Events\n    event Recovered(address token, uint256 amount);\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event EmergencyWithdraw(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 amount\n    );\n\n    constructor(\n        PudToken _pud,\n        address _devaddr,\n        address _treasury,\n        uint256 _pudPerBlock,\n        uint256 _startBlock,\n        uint256 _bonusEndBlock\n    ) public {\n        pud = _pud;\n        devaddr = _devaddr;\n        treasury = _treasury;\n        pudPerBlock = _pudPerBlock;\n        bonusEndBlock = _bonusEndBlock;\n        startBlock = _startBlock;\n    }\n\n    function poolLength() external view returns (uint256) {\n        return poolInfo.length;\n    }\n\n    // Add a new lp to the pool. Can only be called by the owner.\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\n    // SWC-107-Reentrancy: L105 - L127\n    function add(\n        uint256 _allocPoint,\n        IERC20 _lpToken,\n        bool _withUpdate,\n        address _strategy\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock =\n            block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfo.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accPudPerShare: 0,\n                strategy: _strategy,\n                totalShares: 0\n            })\n        );\n    }\n\n    // Update the given pool's Pud allocation point. Can only be called by the owner.\n    // SWC-107-Reentrancy: L131 - L143\n    function set(\n        uint256 _pid,\n        uint256 _allocPoint,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(\n            _allocPoint\n        );\n        poolInfo[_pid].allocPoint = _allocPoint;\n    }\n\n    // Return reward multiplier over the given _from to _to block.\n    function getMultiplier(uint256 _from, uint256 _to)\n        public\n        view\n        returns (uint256)\n    {\n        if (_to <= bonusEndBlock) {\n            return _to.sub(_from).mul(BONUS_MULTIPLIER);\n        } else if (_from >= bonusEndBlock) {\n            return _to.sub(_from);\n        } else {\n            return\n                bonusEndBlock.sub(_from).mul(BONUS_MULTIPLIER).add(\n                    _to.sub(bonusEndBlock)\n                );\n        }\n    }\n\n    // View function to see pending Pud on frontend.\n    function pendingPud(uint256 _pid, address _user)\n        external\n        view\n        returns (uint256)\n    {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][_user];\n        uint256 accPudPerShare = pool.accPudPerShare;\n        uint256 lpSupply = pool.totalShares;\n        if (block.number > pool.lastRewardBlock && lpSupply != 0 && pool.allocPoint > 0) {\n            uint256 multiplier =\n                getMultiplier(pool.lastRewardBlock, block.number);\n\n            uint256 pudReward =\n                multiplier.mul(pudPerBlock).mul(pool.allocPoint).div(\n                    totalAllocPoint\n                );\n            accPudPerShare = accPudPerShare.add(\n                pudReward.mul(1e12).div(lpSupply)\n            );\n        }\n        return\n            user.shares.mul(accPudPerShare).div(1e12).sub(user.rewardDebt);\n    }\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfo.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = pool.totalShares;\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\n        uint256 pudReward = 0;\n        if (pool.allocPoint > 0){\n            pudReward =\n                multiplier.mul(pudPerBlock).mul(pool.allocPoint).div(\n                    totalAllocPoint\n                );\n            if (pudReward > 0){    \n                pud.mint(devaddr, pudReward.div(devFundDivRate));\n                pud.mint(address(this), pudReward);\n            }\n        }\n        pool.accPudPerShare = pool.accPudPerShare.add(\n            pudReward.mul(1e12).div(lpSupply)\n        );\n        pool.lastRewardBlock = block.number;\n    }\n\n    // Deposit LP tokens to MasterChef for Pud allocation.\n    // SWC-107-Reentrancy: L227 - L266\n    function deposit(uint256 _pid, uint256 _amount) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        updatePool(_pid);\n        if (user.shares > 0) {\n            uint256 pending =\n                user.shares.mul(pool.accPudPerShare).div(1e12).sub(\n                    user.rewardDebt\n                );\n            safePudTransfer(msg.sender, pending);\n        }\n\n        //\n        uint256 _pool = balance(_pid); //get _pid lptoken balance\n        if (_amount > 0) {\n            uint256 _before = pool.lpToken.balanceOf(pool.strategy);\n            // SWC-107-Reentrancy: L245 - L249\n            pool.lpToken.safeTransferFrom(\n                address(msg.sender),\n                pool.strategy,\n                _amount\n            );\n\n            uint256 _after = pool.lpToken.balanceOf(pool.strategy);\n            _amount = _after.sub(_before); // Additional check for deflationary tokens\n        }\n        uint256 shares = 0;\n        if (pool.totalShares == 0) {\n            shares = _amount;\n        } else {\n            shares = (_amount.mul(pool.totalShares)).div(_pool);\n        }\n\n        user.shares = user.shares.add(shares); //add shares instead of amount\n        user.rewardDebt = user.shares.mul(pool.accPudPerShare).div(1e12);\n        pool.totalShares = pool.totalShares.add(shares); //add shares in pool\n\n        emit Deposit(msg.sender, _pid, _amount);\n    }\n\n    // Withdraw LP tokens from MasterChef.\n    // SWC-107-Reentrancy: L270 - L304\n    function withdraw(uint256 _pid, uint256 _shares) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n\n        require(user.shares >= _shares, \"withdraw: not good\");\n        updatePool(_pid);\n\n        uint256 r = (balance(_pid).mul(_shares)).div(pool.totalShares);        \n        uint256 pending =\n            user.shares.mul(pool.accPudPerShare).div(1e12).sub(\n                user.rewardDebt\n            );\n\n        safePudTransfer(msg.sender, pending);\n        user.shares = user.shares.sub(_shares);\n        user.rewardDebt = user.shares.mul(pool.accPudPerShare).div(1e12);\n        pool.totalShares = pool.totalShares.sub(_shares); //minus shares in pool\n\n        // Check balance\n        if (r > 0) {\n            uint256 b = pool.lpToken.balanceOf(address(this));\n\n            IStrategy(pool.strategy).withdraw(r);\n            uint256 _after = pool.lpToken.balanceOf(address(this));\n            uint256 _diff = _after.sub(b);\n            if (_diff < r) {\n                r = b.add(_diff);\n            }\n\n            pool.lpToken.safeTransfer(address(msg.sender), r);\n\n        }\n\n        emit Withdraw(msg.sender, _pid, r);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    // SWC-107-Reentrancy: L307 - L326\n    function emergencyWithdraw(uint256 _pid) public {\n        PoolInfo storage pool = poolInfo[_pid];\n        UserInfo storage user = userInfo[_pid][msg.sender];\n        uint256 r = (balance(_pid).mul(user.shares)).div(pool.totalShares);\n\n        // Check balance\n        uint256 b = pool.lpToken.balanceOf(address(this));\n\n        IStrategy(pool.strategy).withdraw(r);\n        uint256 _after = pool.lpToken.balanceOf(address(this));\n        uint256 _diff = _after.sub(b);\n        if (_diff < r) {\n            r = b.add(_diff);\n        }\n\n        pool.lpToken.safeTransfer(address(msg.sender), r);\n        emit EmergencyWithdraw(msg.sender, _pid, user.shares);\n        user.shares = 0;\n        user.rewardDebt = 0;\n    }\n\n    // Safe pud transfer function, just in case if rounding error causes pool to not have enough Pud.\n    // SWC-104-Unchecked Call Return Value: L328 - L345\n    function safePudTransfer(address _to, uint256 _amount) internal {\n        uint256 pudBal = pud.balanceOf(address(this));\n        if (_amount > pudBal) {\n            pud.transfer(_to, pudBal);\n        } else {\n            pud.transfer(_to, _amount);\n        }\n    }\n\n    // Update dev address by the previous dev.\n    function dev(address _devaddr) public {\n        require(msg.sender == devaddr, \"dev: wut?\");\n        devaddr = _devaddr;\n    }\n\n    // **** Additional functions separate from the original masterchef contract ****\n    function setTreasury(address _treasury) public onlyOwner {\n        treasury = _treasury;\n    }\n\n    function setPudPerBlock(uint256 _pudPerBlock) public onlyOwner {\n        require(_pudPerBlock > 0, \"!pudPerBlock-0\");\n\n        pudPerBlock = _pudPerBlock;\n    }\n\n    function setStartBlock(uint256 _startBlock) public onlyOwner {\n        startBlock = _startBlock;\n        uint256 length = poolInfo.length;\n        for (uint256 _pid = 0; _pid < length; ++_pid) {\n            PoolInfo storage pool = poolInfo[_pid];\n            pool.lastRewardBlock = startBlock;\n        }\n    }\n\n    function setBonusEndBlock(uint256 _bonusEndBlock) public onlyOwner {\n        bonusEndBlock = _bonusEndBlock;\n    }\n\n    function setDevFundDivRate(uint256 _devFundDivRate) public onlyOwner {\n        require(_devFundDivRate > 0, \"!devFundDivRate-0\");\n        devFundDivRate = _devFundDivRate;\n    }\n\n// SWC-107-Reentrancy: L378 - L381\n    function balance(uint256 _pid) public view returns (uint256) {\n        PoolInfo storage pool = poolInfo[_pid];\n        return IStrategy(pool.strategy).balanceOf();\n    }\n\n    // SWC-104-Unchecked Call Return Value: L378 - L384\n    function setPoolStrategy(uint256 _pid,address _strategy) public onlyOwner {\n        PoolInfo storage pool = poolInfo[_pid];\n        IStrategy(pool.strategy).harvest();\n        IStrategy(pool.strategy).withdrawAll(_strategy);        \n        pool.strategy = _strategy;\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/BlockSec-blocksec_impossible_finance_swap_v1.2/impossible-swap-core-29aaef89f996acdbee92b67c4d95fb608dc8b876/contracts/ImpossibleWrappedToken.sol",
        "contract": "ImpossibleWrappedToken",
        "function": "_withdraw",
        "line": 871,
        "line_end": 877,
        "name": "reentrancy-benign",
        "code_segment": "contract ImpossibleWrappedToken is IImpossibleWrappedToken {\n    using SafeMath for uint256;\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals = 18;\n    uint256 public override totalSupply;\n\n    address public underlying;\n    uint256 public underlyingBalance;\n    uint256 public ratioNum;\n    uint256 public ratioDenom;\n\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    constructor(\n        address _underlying,\n        uint256 _ratioNum,\n        uint256 _ratioDenom\n    ) {\n        underlying = _underlying;\n        ratioNum = _ratioNum;\n        ratioDenom = _ratioDenom;\n        string memory desc = string(abi.encodePacked(IERC20(_underlying).symbol()));\n        name = string(abi.encodePacked('IF-Wrapped ', desc));\n        symbol = string(abi.encodePacked('WIF ', desc));\n    }\n\n    // SWC-107-Reentrancy: L53-61\n    // wad = amount of wrapped tokens\n    function deposit(address dst, uint256 wad) public returns (uint256 transferAmt) {\n        transferAmt = wad.mul(ratioDenom).div(ratioNum);\n        bool success = IERC20(underlying).transferFrom(msg.sender, address(this), transferAmt);\n        require(success, 'ImpossibleWrapper: TRANSFERFROM_FAILED');\n        _deposit(dst, wad);\n        underlyingBalance = underlyingBalance.add(transferAmt);\n        emit Transfer(address(0), msg.sender, wad);\n    }\n\n    // SWC-107-Reentrancy: L65-73\n    // SWC-114-Transaction Order Dependence: L65-73\n    // wad = amount of wrapped tokens\n    function deposit(address dst) public override returns (uint256 transferAmt) {\n        uint256 balance = IERC20(underlying).balanceOf(address(this));\n        transferAmt = balance.sub(underlyingBalance);\n        uint256 wad = transferAmt.mul(ratioNum).div(ratioDenom);\n        _deposit(dst, wad);\n        underlyingBalance = balance;\n        emit Transfer(address(0), dst, wad);\n    }\n\n    // wad = amount of wrapped tokens\n    function _deposit(address dst, uint256 wad) internal {\n        balanceOf[dst] = balanceOf[dst].add(wad);\n        totalSupply = totalSupply.add(wad);\n    }\n\n    // wad = amount of wrapped tokens\n    function withdraw(address dst, uint256 wad) public override returns (uint256 transferAmt) {\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(wad);\n        emit Transfer(msg.sender, address(0), wad);\n        return _withdraw(dst, wad);\n    }\n\n    function withdraw(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (uint256 transferAmt) {\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(wad);\n        balanceOf[src] = balanceOf[src].sub(wad);\n        emit Transfer(src, address(0), wad);\n        return _withdraw(dst, wad);\n    }\n\n    function _withdraw(address dst, uint256 wad) internal returns (uint256 transferAmt) {\n        totalSupply = totalSupply.sub(wad);\n        transferAmt = wad.mul(ratioDenom).div(ratioNum);\n        bool success = IERC20(underlying).transfer(dst, transferAmt);\n        require(success, 'IF Wrapper: UNDERLYING_TRANSFER_FAIL');\n        underlyingBalance = underlyingBalance.sub(transferAmt);\n    }\n\n    function amtToUnderlyingAmt(uint256 amt) public view override returns (uint256) {\n        return amt.mul(ratioDenom).div(ratioNum);\n    }\n\n    function approve(address guy, uint256 wad) public override returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public override returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public override returns (bool) {\n        require(balanceOf[src] >= wad, '');\n\n        if (src != msg.sender && allowance[src][msg.sender] != uint256(-1)) {\n            require(allowance[src][msg.sender] >= wad, 'ImpossibleWrapper: INSUFF_ALLOWANCE');\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_VÐµrification-stakefish_ethereum_staking_audit_report/eth2-validation-services-contract-d91928f3a270f6115831fe3a21a69eb98bf57b26/contracts/StakefishERC721Wrapper.sol",
        "contract": "StakefishERC721Wrapper",
        "function": "mintTo",
        "line": 689,
        "line_end": 707,
        "name": "reentrancy-benign",
        "code_segment": "contract StakefishERC721Wrapper is IERC721, ReentrancyGuard {\n    using Address for address;\n\n    mapping(uint256 => address) private _servicesContracts;\n    mapping(uint256 => uint256) private _deposits;\n    mapping(uint256 => address) private _owners;\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n    uint256 private _totalMinted;\n\n    event Mint(address indexed servicesContract, address indexed sender, address indexed to, uint256 amount, uint256 tokenId);\n    event Redeem(address indexed servicesContract, address indexed sender, address indexed to, uint256 amount, uint256 tokenId);\n\n    // ERC165\n    \n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\n        return \n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC165).interfaceId;\n    }\n\n    // Wrapper functions\n\n    \n    \n    // SWC-107-Reentrancy: L53-L71\n    function mintTo(address servicesContract, address to, uint256 amount) public nonReentrant returns (uint256) {\n        require(amount > 0, \"Amount can't be 0\");\n\n        uint256 tokenId = _safeMint(to, \"\");\n\n        _servicesContracts[tokenId] = servicesContract;\n        _deposits[tokenId] = amount;\n\n        bool success = IStakefishServicesContract(payable(servicesContract)).transferDepositFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n        require(success, \"Transfer deposit failed\");\n\n        emit Mint(servicesContract, msg.sender, to, amount, tokenId);\n        \n        return tokenId;\n    }\n\n    function mint(address servicesContract, uint256 amount) external returns (uint256) {\n        return mintTo(servicesContract, msg.sender, amount);\n    }\n\n    \n    \n    function redeemTo(uint256 tokenId, address to) public nonReentrant {\n        require(msg.sender == _owners[tokenId], \"Not token owner\");\n        \n        _burn(tokenId);\n\n        address servicesContract = _servicesContracts[tokenId];\n        uint256 amount = _deposits[tokenId];\n        bool success = IStakefishServicesContract(payable(servicesContract)).transferDeposit(\n            to,\n            amount\n        );\n        require(success, \"Transfer deposit failed\");\n\n        emit Redeem(servicesContract, msg.sender, to, amount, tokenId);\n    }\n\n    function redeem(uint256 tokenId) external {\n        redeemTo(tokenId, msg.sender);\n    }\n\n    function getTotalMinted() public view returns (uint256) {\n        return _totalMinted;\n    }\n\n    function getDeposit(uint256 tokenId) public view returns (uint256) {\n        require(_owners[tokenId] != address(0), \"Token does not exist\");\n\n        return _deposits[tokenId];\n    }\n\n    function getServicesContract(uint256 tokenId) public view returns (address) {\n        require(_owners[tokenId] != address(0), \"Token does not exist\");\n\n        return _servicesContracts[tokenId];\n    }\n\n    // ERC721 functions\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not owner nor approved\");\n            \n        _transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public override {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"Not owner nor approved\");\n\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    function approve(address to, uint256 tokenId) public override {\n        address owner = _owners[tokenId];\n        require(to != owner, \"Approval to current owner\");\n\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"Not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public override {\n        require(operator != msg.sender, \"Approve to caller\");\n\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function balanceOf(address owner) public view override returns (uint256) {\n        require(owner != address(0), \"Balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) public view override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"Owner query for non-existent token\");\n        return owner;\n    }\n\n    function getApproved(uint256 tokenId) public view override returns (address) {\n        require(_owners[tokenId] != address(0), \"Approved query for non-existent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n    \n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function _mint(address to) internal returns (uint256) {\n        require(to != address(0), \"Mint to the zero address\");\n\n        uint256 tokenId = _totalMinted;\n        _totalMinted += 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to; \n\n        emit Transfer(address(0), to, tokenId);\n\n        return tokenId;\n    }\n\n    function _safeMint(address to, bytes memory data) internal returns (uint256 tokenId) {\n        tokenId = _mint(to);\n\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"Transfer to non ERC721Receiver\"\n        );\n    }\n\n    function _burn(uint256 tokenId) internal {\n        address owner = _owners[tokenId];\n\n        _approve(address(0), tokenId);\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal {\n        require(_owners[tokenId] == from, \"From is not token owner\");\n\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"Transfer to non ERC721Receiver\");\n    }\n\n    function _approve(address to, uint256 tokenId) internal {\n        _tokenApprovals[tokenId] = to;\n        \n        emit Approval(_owners[tokenId], to, tokenId);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"Operator query for non-existent token\");\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"Transfer to non ERC721Receiver\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "FreezableToken",
        "function": "freeze",
        "line": 515,
        "line_end": 546,
        "name": "timestamp",
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Amp/amp-token-contracts-6871b6c64c712835b332e515cc553308dcbbc539/contracts/Amp.sol",
        "contract": "Amp",
        "function": "swap",
        "line": 1280,
        "line_end": 1289,
        "name": "unchecked-transfer",
        "code_segment": "contract Amp is\n    IERC20,\n    ERC1820Client,\n    ERC1820Implementer,\n    PartitionsBase,\n    ErrorCodes,\n    Ownable {\n    using SafeMath for uint256;\n\n    /**************************************************************************/\n    /********************** ERC1820 Interface Constants ***********************/\n\n    /**\n     * @dev AmpToken interface label.\n     */\n    string internal constant AMP_INTERFACE_NAME = \"AmpToken\";\n\n    /**\n     * @dev ERC20Token interface label.\n     */\n    string internal constant ERC20_INTERFACE_NAME = \"ERC20Token\";\n\n    /**\n     * @dev ERC777Token interface label.\n     */\n    string internal constant ERC777_INTERFACE_NAME = \"ERC777Token\";\n\n    /**\n     * @dev AmpTokensSender interface label.\n     */\n    string internal constant AMP_TOKENS_SENDER = \"AmpTokensSender\";\n\n    /**\n     * @dev AmpTokensRecipient interface label.\n     */\n    string internal constant AMP_TOKENS_RECIPIENT = \"AmpTokensRecipient\";\n\n    /**\n     * @dev AmpTokensChecker interface label.\n     */\n    string internal constant AMP_TOKENS_CHECKER = \"AmpTokensChecker\";\n\n    /**************************************************************************/\n    /*************************** Token properties *****************************/\n\n    /**\n     * @dev Token name (Amp).\n     */\n    string internal _name;\n\n    /**\n     * @dev Token symbol (AMP).\n     */\n    string internal _symbol;\n\n    /**\n     * @dev Total minted supply of token. This will increase comensurately with\n     * successful swaps of the swap token.\n     */\n    uint256 internal _totalSupply;\n\n    /**\n     * @dev The granularity of the token. Hard coded to 1.\n     */\n    uint256 internal constant _granularity = 1;\n\n    /**************************************************************************/\n    /***************************** Token mappings *****************************/\n\n    /**\n     * @dev Mapping from tokenHolder to balance.\n     */\n    mapping(address => uint256) internal _balances;\n\n    /**\n     * @dev Mapping from (tokenHolder, spender) to allowed value.\n     */\n    mapping(address => mapping(address => uint256)) internal _allowed;\n\n    /**************************************************************************/\n    /************************** Partition mappings ****************************/\n\n    /**\n     * @dev List of active partitions. This list reflects all partitions that\n     * have tokens assigned to them.\n     */\n    bytes32[] internal _totalPartitions;\n\n    /**\n     * @dev Mapping from partition to their index.\n     */\n    mapping(bytes32 => uint256) internal _indexOfTotalPartitions;\n\n    /**\n     * @dev Mapping from partition to global balance of corresponding partition.\n     */\n    mapping(bytes32 => uint256) public totalSupplyByPartition;\n\n    /**\n     * @dev Mapping from tokenHolder to their partitions.\n     */\n    mapping(address => bytes32[]) internal _partitionsOf;\n\n    /**\n     * @dev Mapping from (tokenHolder, partition) to their index.\n     */\n    mapping(address => mapping(bytes32 => uint256)) internal _indexOfPartitionsOf;\n\n    /**\n     * @dev Mapping from (tokenHolder, partition) to balance of corresponding\n     * partition.\n     */\n    mapping(address => mapping(bytes32 => uint256)) internal _balanceOfByPartition;\n\n    /**\n     * @notice Default partition of the token.\n     * @dev All ERC20 operations operate solely on this partition.\n     */\n    bytes32 public constant defaultPartition = 0x0000000000000000000000000000000000000000000000000000000000000000;\n\n    /**\n     * @dev Zero partition prefix. Parititions with this prefix can not have a strategy assigned,\n     * and partitions with a different prefix must have one.\n     */\n    bytes4 internal constant ZERO_PREFIX = 0x00000000;\n\n    /**************************************************************************/\n    /***************************** Operator mappings **************************/\n\n    /**\n     * @dev Mapping from (tokenHolder, operator) to authorized status. This is\n     * specific to the token holder.\n     */\n    mapping(address => mapping(address => bool)) internal _authorizedOperator;\n\n    /**************************************************************************/\n    /********************** Partition operator mappings ***********************/\n\n    /**\n     * @dev Mapping from (partition, tokenHolder, spender) to allowed value.\n     * This is specific to the token holder.\n     */\n    mapping(bytes32 => mapping(address => mapping(address => uint256))) internal _allowedByPartition;\n\n    /**\n     * @dev Mapping from (tokenHolder, partition, operator) to 'approved for\n     * partition' status. This is specific to the token holder.\n     */\n    mapping(address => mapping(bytes32 => mapping(address => bool))) internal _authorizedOperatorByPartition;\n\n    /**************************************************************************/\n    /********************** Collateral Manager mappings ***********************/\n    /**\n     * @notice Collection of registered collateral managers.\n     */\n    address[] public collateralManagers;\n    /**\n     * @dev Mapping of collateral manager addresses to registration status.\n     */\n    mapping(address => bool) internal _isCollateralManager;\n\n    /**************************************************************************/\n    /********************* Partition Strategy mappings ************************/\n\n    /**\n     * @notice Collection of reserved partition strategies.\n     */\n    bytes4[] public partitionStrategies;\n\n    /**\n     * @dev Mapping of partition strategy flag to registration status.\n     */\n    mapping(bytes4 => bool) internal _isPartitionStrategy;\n\n    /**************************************************************************/\n    /***************************** Swap storage *******************************/\n\n    /**\n     * @notice Swap token address.\n     */\n    ISwapToken public swapToken;\n\n    /**\n     * @notice Swap token graveyard address.\n     * @dev This is the address that the incoming swapped tokens will be\n     * forwarded to upon successfully minting Amp.\n     */\n    address public constant swapTokenGraveyard = 0x000000000000000000000000000000000000dEaD;\n\n    /**************************************************************************/\n    /** EVENTS ****************************************************************/\n    /**************************************************************************/\n\n    /**************************************************************************/\n    /**************************** Transfer Events *****************************/\n\n    /**\n     * @notice Emitted when a transfer has been successfully completed.\n     * @param fromPartition The partition the tokens were transfered from.\n     * @param operator The address that initiated the transfer.\n     * @param from The address the tokens were transferred from.\n     * @param to The address the tokens were transferred to.\n     * @param value The amount of tokens transferred.\n     * @param data Additional metadata included with the transfer. Can include\n     * the partition the tokens were transferred to (if different than\n     * `fromPartition`).\n     * @param operatorData Additional metadata included with the transfer on\n     * behalf of the operator.\n     */\n    event TransferByPartition(\n        bytes32 indexed fromPartition,\n        address operator,\n        address indexed from,\n        address indexed to,\n        uint256 value,\n        bytes data,\n        bytes operatorData\n    );\n\n    /**\n     * @notice Emitted when a transfer has been successfully completed and the\n     * tokens that were transferred have changed partitions.\n     * @param fromPartition The partition the tokens were transfered from.\n     * @param toPartition The partition the tokens were transfered to.\n     * @param value The amount of tokens transferred.\n     */\n    event ChangedPartition(\n        bytes32 indexed fromPartition,\n        bytes32 indexed toPartition,\n        uint256 value\n    );\n\n    /**************************************************************************/\n    /**************************** Operator Events *****************************/\n\n    /**\n     * @notice Emitted when a token holder specifies an amount of tokens in a\n     * a partition that an operator can transfer.\n     * @param partition The partition of the tokens the holder has authorized the\n     * operator to transfer from.\n     * @param owner The token holder.\n     * @param spender The operator the `owner` has authorized the allowance for.\n     */\n    event ApprovalByPartition(\n        bytes32 indexed partition,\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @notice Emitted when a token holder has authorized an operator for their\n     * tokens.\n     * @dev This event applies to the token holder address across all partitions.\n     * @param operator The address that was authorized to transfer tokens on\n     * behalf of the `tokenHolder`.\n     * @param tokenHolder The address that authorized the `operator` to transfer\n     * their tokens.\n     */\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @notice Emitted when a token holder has de-authorized an operator from\n     * transferring their tokens.\n     * @dev This event applies to the token holder address across all partitions.\n     * @param operator The address that was de-authorized from transferring tokens\n     * on behalf of the `tokenHolder`.\n     * @param tokenHolder The address that revoked the `operator`'s permission\n     * to transfer their tokens.\n     */\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\n\n    /**\n     * @notice Emitted when a token holder has authorized an operator to transfer\n     * their tokens of one partition.\n     * @param partition The partition the `operator` is allowed to transfer\n     * tokens from.\n     * @param operator The address that was authorized to transfer tokens on\n     * behalf of the `tokenHolder`.\n     * @param tokenHolder The address that authorized the `operator` to transfer\n     * their tokens in `partition`.\n     */\n    event AuthorizedOperatorByPartition(\n        bytes32 indexed partition,\n        address indexed operator,\n        address indexed tokenHolder\n    );\n\n    /**\n     * @notice Emitted when a token holder has de-authorized an operator from\n     * transferring their tokens from a specific partition.\n     * @param partition The partition the `operator` is no longer allowed to\n     * transfer tokens from on behalf of the `tokenHolder`.\n     * @param operator The address that was de-authorized from transferring\n     * tokens on behalf of the `tokenHolder`.\n     * @param tokenHolder The address that revoked the `operator`'s permission\n     * to transfer their tokens from `partition`.\n     */\n    event RevokedOperatorByPartition(\n        bytes32 indexed partition,\n        address indexed operator,\n        address indexed tokenHolder\n    );\n\n    /**************************************************************************/\n    /********************** Collateral Manager Events *************************/\n\n    /**\n     * @notice Emitted when a collateral manager has been registered.\n     * @param collateralManager The address of the collateral manager.\n     */\n    event CollateralManagerRegistered(address collateralManager);\n\n    /**************************************************************************/\n    /*********************** Partition Strategy Events ************************/\n\n    /**\n     * @notice Emitted when a new partition strategy validator is set.\n     * @param flag The 4 byte prefix of the partitions that the stratgy affects.\n     * @param name The name of the partition strategy.\n     * @param implementation The address of the partition strategy hook\n     * implementation.\n     */\n    event PartitionStrategySet(bytes4 flag, string name, address indexed implementation);\n\n    // ************** Mint & Swap **************\n\n    /**\n     * @notice Emitted when tokens are minted as a result of a token swap\n     * @param operator Address that executed the swap that resulted in tokens being minted\n     * @param to Address that received the newly minted tokens.\n     * @param value Amount of tokens minted\n     * @param data Empty bytes, required for interface compatibility\n     */\n    event Minted(address indexed operator, address indexed to, uint256 value, bytes data);\n\n    /**\n     * @notice Indicates tokens swapped for Amp.\n     * @dev The tokens that are swapped for Amp will be transferred to a\n     * graveyard address that is for all practical purposes inaccessible.\n     * @param operator Address that executed the swap.\n     * @param from Address that the tokens were swapped from, and Amp minted for.\n     * @param value Amount of tokens swapped into Amp.\n     */\n    event Swap(address indexed operator, address indexed from, uint256 value);\n\n    /**************************************************************************/\n    /** CONSTRUCTOR ***********************************************************/\n    /**************************************************************************/\n\n    /**\n     * @notice Initialize Amp, initialize the default partition, and register the\n     * contract implementation in the global ERC1820Registry.\n     * @param _swapTokenAddress_ The address of the ERC20 token that is set to be\n     * swappable for Amp.\n     * @param _name_ Name of the token.\n     * @param _symbol_ Symbol of the token.\n     */\n    constructor(\n        address _swapTokenAddress_,\n        string memory _name_,\n        string memory _symbol_\n    ) public {\n        // \"Swap token cannot be 0 address\"\n        require(_swapTokenAddress_ != address(0), EC_5A_INVALID_SWAP_TOKEN_ADDRESS);\n        swapToken = ISwapToken(_swapTokenAddress_);\n\n        _name = _name_;\n        _symbol = _symbol_;\n        _totalSupply = 0;\n\n        // Add the default partition to the total partitions on deploy\n        _addPartitionToTotalPartitions(defaultPartition);\n\n        // Register contract in ERC1820 registry\n        ERC1820Client.setInterfaceImplementation(AMP_INTERFACE_NAME, address(this));\n        ERC1820Client.setInterfaceImplementation(ERC20_INTERFACE_NAME, address(this));\n\n        // Indicate token verifies Amp, ERC777 and ERC20 interfaces\n        ERC1820Implementer._setInterface(AMP_INTERFACE_NAME);\n        ERC1820Implementer._setInterface(ERC20_INTERFACE_NAME);\n        // ERC1820Implementer._setInterface(ERC777_INTERFACE_NAME);\n    }\n\n    /**************************************************************************/\n    /** EXTERNAL FUNCTIONS (ERC20) ********************************************/\n    /**************************************************************************/\n\n    /**\n     * @notice Get the total number of issued tokens.\n     * @return Total supply of tokens currently in circulation.\n     */\n    function totalSupply() external override view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @notice Get the balance of the account with address `_tokenHolder`.\n     * @dev This returns the balance of the holder by the default partition, in\n     * order to be compatible with ERC20, as the default partition is the only\n     * on where the tokens are guaranteed to be unlocked.\n     * @param _tokenHolder Address for which the balance is returned.\n     * @return Amount of token held by `_tokenHolder` in the default partition.\n     */\n    function balanceOf(address _tokenHolder) external override view returns (uint256) {\n        return _balanceOfByPartition[_tokenHolder][defaultPartition];\n    }\n\n    /**\n     * @notice Transfer token for a specified address.\n     * @param _to The address to transfer to.\n     * @param _value The value to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transfer(address _to, uint256 _value) external override returns (bool) {\n        _transferByDefaultPartition(msg.sender, msg.sender, _to, _value, \"\");\n        return true;\n    }\n\n    /**\n     * @notice Check the value of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the value of tokens still available for the\n     * spender.\n     */\n    function allowance(address _owner, address _spender)\n        external\n        override\n        view\n        returns (uint256)\n    {\n        return _allowed[_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the passed address to spend the specified amount of\n     * tokens on behalf of 'msg.sender'.\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approve(address _spender, uint256 _value) external override returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the\n     * for caller.\n     * @dev This is an alternative to {approve} that can be used as a mitigation\n     * problems described in {IERC20-approve}.\n     * Emits an {Approval} event indicating the updated allowance.\n     * Requirements:\n     * - `_spender` cannot be the zero address.\n     * @param _spender Operator allowed to transfer the tokens\n     * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender`\n     * is allowed to transfer\n     * @return 'true' is successful, 'false' otherwise\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue)\n        external\n        returns (bool)\n    {\n        _approve(msg.sender, _spender, _allowed[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the\n     * caller.\n     * @dev This is an alternative to {approve} that can be used as a mitigation\n     * for bugs caused by reentrancy.\n     * Emits an {Approval} event indicating the updated allowance.\n     * Requirements:\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least\n     * `_subtractedValue`.\n     * @param _spender Operator allowed to transfer the tokens\n     * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender`\n     * is no longer allowed to transfer\n     * @return 'true' is successful, 'false' otherwise\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue)\n        external\n        returns (bool)\n    {\n        _approve(\n            msg.sender,\n            _spender,\n            _allowed[msg.sender][_spender].sub(_subtractedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @notice Transfer tokens from one address to another.\n     * @param _from The address which you want to transfer tokens from.\n     * @param _to The address which you want to transfer to.\n     * @param _value The amount of tokens to be transferred.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) external override returns (bool) {\n        require(\n            _isOperator(msg.sender, _from) || (_value <= _allowed[_from][msg.sender]),\n            EC_53_INSUFFICIENT_ALLOWANCE\n        );\n\n        if (_allowed[_from][msg.sender] >= _value) {\n            _allowed[_from][msg.sender] = _allowed[_from][msg.sender].sub(_value);\n        } else {\n            _allowed[_from][msg.sender] = 0;\n        }\n\n        _transferByDefaultPartition(msg.sender, _from, _to, _value, \"\");\n        return true;\n    }\n\n    /**************************************************************************/\n    /** EXTERNAL FUNCTIONS (AMP) **********************************************/\n    /**************************************************************************/\n\n    /******************************** Swap  ***********************************/\n\n    /**\n     * @notice Swap tokens to mint AMP.\n     * @dev Requires `_from` to have given allowance of swap token to contract.\n     * Otherwise will throw error code 53 (Insuffient Allowance).\n     * @param _from Token holder to execute the swap for.\n     */\n    function swap(address _from) public {\n        uint256 amount = swapToken.allowance(_from, address(this));\n        require(amount > 0, EC_53_INSUFFICIENT_ALLOWANCE);\n        // SWC-104-Unchecked Call Return Value: L619\n        swapToken.transferFrom(_from, swapTokenGraveyard, amount);\n\n        _mint(msg.sender, _from, amount, \"\");\n\n        emit Swap(msg.sender, _from, amount);\n    }\n\n    /**************************************************************************/\n    /************************** Holder information ****************************/\n\n    /**\n     * @notice Get the balance of the account with address `_tokenHolder` across all\n     * partitions.\n     * @param _tokenHolder Address for which the balance is returned.\n     * @return Amount of tokens held by `_tokenHolder` in the token contract.\n     */\n    function totalBalanceOf(address _tokenHolder) external view returns (uint256) {\n        return _balances[_tokenHolder];\n    }\n\n    /**\n     * @notice Get balance of a tokenholder for a specific partition.\n     * @param _partition Name of the partition.\n     * @param _tokenHolder Address for which the balance is returned.\n     * @return Amount of token of partition `_partition` held by `_tokenHolder` in the token contract.\n     */\n    function balanceOfByPartition(bytes32 _partition, address _tokenHolder)\n        external\n        view\n        returns (uint256)\n    {\n        return _balanceOfByPartition[_tokenHolder][_partition];\n    }\n\n    /**\n     * @notice Get partitions index of a token holder.\n     * @param _tokenHolder Address for which the partitions index are returned.\n     * @return Array of partitions index of '_tokenHolder'.\n     */\n    function partitionsOf(address _tokenHolder) external view returns (bytes32[] memory) {\n        return _partitionsOf[_tokenHolder];\n    }\n\n    /**************************************************************************/\n    /****************************** Transfers *********************************/\n\n    /**\n     * @notice Transfer tokens from the sender to another address, optionally\n     * including arbitirary data.\n     * @dev Transfer the amount of tokens from the address 'msg.sender' to the\n     * address `_to`.\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     * @param _data Information attached to the transfer, by the token holder.\n     */\n    function transferWithData(\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external {\n        _transferByDefaultPartition(msg.sender, msg.sender, _to, _value, _data);\n    }\n\n    /**\n     * @notice Transfer tokens on behalf of a token holder to another address,\n     * optionally including arbitirary data.\n     * @dev Transfer the amount of tokens on behalf of the address '_from' to\n     * the address 'to'. The `msg.sender` must be an operator for `_from`.\n     * @param _from Token holder (or 'address(0)' to set from to 'msg.sender').\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     * @param _data Information attached to the transfer, and intended for the\n     * token holder (`_from`).\n     */\n    function transferFromWithData(\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external {\n        require(_isOperator(msg.sender, _from), EC_58_INVALID_OPERATOR);\n\n        _transferByDefaultPartition(msg.sender, _from, _to, _value, _data);\n    }\n\n    /**************************************************************************/\n    /********************* Partition Token Transfers **************************/\n\n    /**\n     * @notice Transfer tokens from a specific partition.\n     * @param _partition Name of the partition.\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     * @param _data Information attached to the transfer, by the token holder.\n     * @return Destination partition.\n     */\n    function transferByPartition(\n        bytes32 _partition,\n        address _to,\n        uint256 _value,\n        bytes calldata _data\n    ) external returns (bytes32) {\n        return\n            _transferByPartition(\n                _partition,\n                msg.sender,\n                msg.sender,\n                _to,\n                _value,\n                _data,\n                \"\"\n            );\n    }\n\n    /**\n     * @notice Transfer tokens from a specific partition on behalf of a token\n     * holder, optionally changing the parittion and optionally including\n     * arbitrary data with the transfer.\n     * @dev Transfer tokens from a specific partition through an operator.\n     * @param _partition Name of the partition.\n     * @param _from Token holder.\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     * @param _data Information attached to the transfer. Will contain the\n     * destination partition (if changing partitions).\n     * @param _operatorData Information attached to the transfer, by the operator.\n     * @return Destination partition.\n     */\n    function operatorTransferByPartition(\n        bytes32 _partition,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes calldata _data,\n        bytes calldata _operatorData\n    ) external returns (bytes32) {\n        require(\n            _isOperatorForPartition(_partition, msg.sender, _from) ||\n                (_value <= _allowedByPartition[_partition][_from][msg.sender]),\n            EC_53_INSUFFICIENT_ALLOWANCE\n        );\n\n        if (_allowedByPartition[_partition][_from][msg.sender] >= _value) {\n            _allowedByPartition[_partition][_from][msg\n                .sender] = _allowedByPartition[_partition][_from][msg.sender].sub(_value);\n        } else {\n            _allowedByPartition[_partition][_from][msg.sender] = 0;\n        }\n\n        return\n            _transferByPartition(\n                _partition,\n                msg.sender,\n                _from,\n                _to,\n                _value,\n                _data,\n                _operatorData\n            );\n    }\n\n    /**************************************************************************/\n    /************************** Operator Management ***************************/\n\n    /**\n     * @notice Set a third party operator address as an operator of 'msg.sender'\n     * to transfer and redeem tokens on its behalf.\n     * @param _operator Address to set as an operator for 'msg.sender'.\n     */\n    function authorizeOperator(address _operator) external {\n        require(_operator != msg.sender);\n        _authorizedOperator[msg.sender][_operator] = true;\n        emit AuthorizedOperator(_operator, msg.sender);\n    }\n\n    /**\n     * @notice Remove the right of the operator address to be an operator for\n     * 'msg.sender' and to transfer and redeem tokens on its behalf.\n     * @param _operator Address to rescind as an operator for 'msg.sender'.\n     */\n    function revokeOperator(address _operator) external {\n        require(_operator != msg.sender);\n        _authorizedOperator[msg.sender][_operator] = false;\n        emit RevokedOperator(_operator, msg.sender);\n    }\n\n    /**\n     * @dev Set `_operator` as an operator for 'msg.sender' for a given partition.\n     * @param _partition Name of the partition.\n     * @param _operator Address to set as an operator for 'msg.sender'.\n     */\n    function authorizeOperatorByPartition(bytes32 _partition, address _operator)\n        external\n    {\n        _authorizedOperatorByPartition[msg.sender][_partition][_operator] = true;\n        emit AuthorizedOperatorByPartition(_partition, _operator, msg.sender);\n    }\n\n    /**\n     * @notice Remove the right of the operator address to be an operator on a\n     * given partition for 'msg.sender' and to transfer and redeem tokens on its\n     * behalf.\n     * @param _partition Name of the partition.\n     * @param _operator Address to rescind as an operator on given partition for\n     * 'msg.sender'.\n     */\n    function revokeOperatorByPartition(bytes32 _partition, address _operator) external {\n        _authorizedOperatorByPartition[msg.sender][_partition][_operator] = false;\n        emit RevokedOperatorByPartition(_partition, _operator, msg.sender);\n    }\n\n    /**************************************************************************/\n    /************************** Operator Information **************************/\n    /**\n     * @notice Indicate whether the `_operator` address is an operator of the\n     * `_tokenHolder` address.\n     * @param _operator Address which may be an operator of `_tokenHolder`.\n     * @param _tokenHolder Address of a token holder which may have the\n     * `_operator` address as an operator.\n     * @return 'true' if operator is an operator of 'tokenHolder' and 'false'\n     * otherwise.\n     */\n    function isOperator(address _operator, address _tokenHolder)\n        external\n        view\n        returns (bool)\n    {\n        return _isOperator(_operator, _tokenHolder);\n    }\n\n    /**\n     * @notice Indicate whether the operator address is an operator of the\n     * `_tokenHolder` address for the given partition.\n     * @param _partition Name of the partition.\n     * @param _operator Address which may be an operator of tokenHolder for the\n     * given partition.\n     * @param _tokenHolder Address of a token holder which may have the\n     * `_operator` address as an operator for the given partition.\n     * @return 'true' if 'operator' is an operator of `_tokenHolder` for\n     * partition '_partition' and 'false' otherwise.\n     */\n    function isOperatorForPartition(\n        bytes32 _partition,\n        address _operator,\n        address _tokenHolder\n    ) external view returns (bool) {\n        return _isOperatorForPartition(_partition, _operator, _tokenHolder);\n    }\n\n    /**\n     * @notice Indicate when the `_operator` address is an operator of the\n     * `_collateralManager` address for the given partition.\n     * @dev This method is the same as `isOperatorForPartition`, except that it\n     * also requires the address that `_operator` is being checked for MUST be\n     * a registered collateral manager, and this method will not execute\n     * partition strategy operator check hooks.\n     * @param _partition Name of the partition.\n     * @param _operator Address which may be an operator of `_collateralManager`\n     * for the given partition.\n     * @param _collateralManager Address of a collateral manager which may have\n     * the `_operator` address as an operator for the given partition.\n     */\n    function isOperatorForCollateralManager(\n        bytes32 _partition,\n        address _operator,\n        address _collateralManager\n    ) external view returns (bool) {\n        return\n            _isCollateralManager[_collateralManager] &&\n            (_isOperator(_operator, _collateralManager) ||\n                _authorizedOperatorByPartition[_collateralManager][_partition][_operator]);\n    }\n\n    /**************************************************************************/\n    /***************************** Token metadata *****************************/\n    /**\n     * @notice Get the name of the token (Amp).\n     * @return Name of the token.\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @notice Get the symbol of the token (AMP).\n     * @return Symbol of the token.\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @notice Get the number of decimals of the token.\n     * @dev Hard coded to 18.\n     * @return The number of decimals of the token (18).\n     */\n    function decimals() external pure returns (uint8) {\n        return uint8(18);\n    }\n\n    /**\n     * @notice Get the smallest part of the token thatâs not divisible.\n     * @dev Hard coded to 1.\n     * @return The smallest non-divisible part of the token.\n     */\n    function granularity() external pure returns (uint256) {\n        return _granularity;\n    }\n\n    /**\n     * @notice Get list of existing partitions.\n     * @return Array of all exisiting partitions.\n     */\n    function totalPartitions() external view returns (bytes32[] memory) {\n        return _totalPartitions;\n    }\n\n    /************************************************************************************************/\n    /********************************* Token default partitions *************************************/\n    /**\n     * @notice Get default partition to transfer from.\n     * @return The default partition.\n     */\n    function getDefaultPartition() external pure returns (bytes32) {\n        return defaultPartition;\n    }\n\n    /************************************************************************************************/\n    /******************************** Partition Token Allowances ************************************/\n    /**\n     * @notice Check the value of tokens that an owner allowed to a spender.\n     * @param _partition Name of the partition.\n     * @param _owner The address which owns the tokens.\n     * @param _spender The address which will spend the tokens.\n     * @return The value of tokens still for the spender to transfer.\n     */\n    function allowanceByPartition(\n        bytes32 _partition,\n        address _owner,\n        address _spender\n    ) external view returns (uint256) {\n        return _allowedByPartition[_partition][_owner][_spender];\n    }\n\n    /**\n     * @notice Approve the `_spender` address to spend the specified amount of\n     * tokens in `_partition` on behalf of 'msg.sender'.\n     * @param _partition Name of the partition.\n     * @param _spender The address which will spend the tokens.\n     * @param _value The amount of tokens to be tokens.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function approveByPartition(\n        bytes32 _partition,\n        address _spender,\n        uint256 _value\n    ) external returns (bool) {\n        _approveByPartition(_partition, msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @notice Atomically increases the allowance granted to `_spender` by the\n     * caller.\n     * @dev This is an alternative to {approveByPartition} that can be used as\n     * a mitigation for bugs caused by reentrancy.\n     * Emits an {ApprovalByPartition} event indicating the updated allowance.\n     * Requirements:\n     * - `_spender` cannot be the zero address.\n     * @param _partition Name of the partition.\n     * @param _spender Operator allowed to transfer the tokens\n     * @param _addedValue Additional amount of the `msg.sender`s tokens `_spender`\n     * is allowed to transfer\n     * @return 'true' is successful, 'false' otherwise\n     */\n    function increaseAllowanceByPartition(\n        bytes32 _partition,\n        address _spender,\n        uint256 _addedValue\n    ) external returns (bool) {\n        _approveByPartition(\n            _partition,\n            msg.sender,\n            _spender,\n            _allowedByPartition[_partition][msg.sender][_spender].add(_addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @notice Atomically decreases the allowance granted to `_spender` by the\n     * caller.\n     * @dev This is an alternative to {approveByPartition} that can be used as\n     * a mitigation for bugs caused by reentrancy.\n     * Emits an {ApprovalByPartition} event indicating the updated allowance.\n     * Requirements:\n     * - `_spender` cannot be the zero address.\n     * - `_spender` must have allowance for the caller of at least\n     * `_subtractedValue`.\n     * @param _spender Operator allowed to transfer the tokens\n     * @param _subtractedValue Amount of the `msg.sender`s tokens `_spender` is\n     * no longer allowed to transfer\n     * @return 'true' is successful, 'false' otherwise\n     */\n    function decreaseAllowanceByPartition(\n        bytes32 _partition,\n        address _spender,\n        uint256 _subtractedValue\n    ) external returns (bool) {\n        // TOOD: Figure out if safe math will panic below 0\n        _approveByPartition(\n            _partition,\n            msg.sender,\n            _spender,\n            _allowedByPartition[_partition][msg.sender][_spender].sub(_subtractedValue)\n        );\n        return true;\n    }\n\n    /**************************************************************************/\n    /************************ Collateral Manager Admin ************************/\n\n    /**\n     * @notice Allow a collateral manager to self-register.\n     * @dev Error 0x5c.\n     */\n    function registerCollateralManager() external {\n        // Short circuit a double registry\n        require(!_isCollateralManager[msg.sender], EC_5C_ADDRESS_CONFLICT);\n\n        collateralManagers.push(msg.sender);\n        _isCollateralManager[msg.sender] = true;\n\n        emit CollateralManagerRegistered(msg.sender);\n    }\n\n    /**\n     * @notice Get the status of a collateral manager.\n     * @param _collateralManager The address of the collateral mananger in question.\n     * @return 'true' if `_collateralManager` has self registered, 'false'\n     * otherwise.\n     */\n    function isCollateralManager(address _collateralManager)\n        external\n        view\n        returns (bool)\n    {\n        return _isCollateralManager[_collateralManager];\n    }\n\n    /**************************************************************************/\n    /************************ Partition Strategy Admin ************************/\n    /**\n     * @notice Sets an implementation for a partition strategy identified by prefix.\n     * @dev This is an administration method, callable only by the owner of the\n     * Amp contract.\n     * @param _prefix The 4 byte partition prefix the strategy applies to.\n     * @param _implementation The address of the implementation of the strategy hooks.\n     */\n    function setPartitionStrategy(bytes4 _prefix, address _implementation)\n        external\n        onlyOwner\n    {\n        require(!_isPartitionStrategy[_prefix], EC_5E_PARTITION_PREFIX_CONFLICT);\n        require(_prefix != ZERO_PREFIX, EC_5F_INVALID_PARTITION_PREFIX_0);\n\n        string memory iname = _getPartitionStrategyValidatorIName(_prefix);\n\n        ERC1820Client.setInterfaceImplementation(iname, _implementation);\n        partitionStrategies.push(_prefix);\n        _isPartitionStrategy[_prefix] = true;\n\n        emit PartitionStrategySet(_prefix, iname, _implementation);\n    }\n\n    /**\n     * @notice Return if a partition strategy has been reserved and has an\n     * implementation registered.\n     * @param _prefix The partition strategy identifier.\n     * @return 'true' if the strategy has been registered, 'false' if not.\n     */\n    function isPartitionStrategy(bytes4 _prefix) external view returns (bool) {\n        return _isPartitionStrategy[_prefix];\n    }\n\n    /**************************************************************************/\n    /*************************** INTERNAL FUNCTIONS ***************************/\n    /**************************************************************************/\n\n    /**************************************************************************/\n    /**************************** Token Transfers *****************************/\n    /**\n     * @notice Perform the transfer of tokens.\n     * @param _from Token holder.\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     */\n    function _transfer(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal {\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\n        require(_balances[_from] >= _value, EC_52_INSUFFICIENT_BALANCE);\n\n        _balances[_from] = _balances[_from].sub(_value);\n        _balances[_to] = _balances[_to].add(_value);\n\n        emit Transfer(_from, _to, _value);\n    }\n    // SWC-107-Reentrancy: L1131-L1201\n    /**\n     * @dev Transfer tokens from a specific partition.\n     * @param _fromPartition Partition of the tokens to transfer.\n     * @param _operator The address performing the transfer.\n     * @param _from Token holder.\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     * @param _data Information attached to the transfer. Contains the destination\n     * partition if a partition change is requested.\n     * @param _operatorData Information attached to the transfer, by the operator\n     * (if any).\n     * @return Destination partition.\n     */\n    function _transferByPartition(\n        bytes32 _fromPartition,\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        bytes memory _operatorData\n    ) internal returns (bytes32) {\n        require(\n            _balanceOfByPartition[_from][_fromPartition] >= _value,\n            EC_52_INSUFFICIENT_BALANCE\n        );\n\n        bytes32 toPartition = _fromPartition;\n        if (_data.length >= 64) {\n            toPartition = _getDestinationPartition(_fromPartition, _data);\n        }\n        \n        _callPreTransferHooks(\n            _fromPartition,\n            _operator,\n            _from,\n            _to,\n            _value,\n            _data,\n            _operatorData\n        );\n\n        _removeTokenFromPartition(_from, _fromPartition, _value);\n        _transfer(_from, _to, _value);\n        _addTokenToPartition(_to, toPartition, _value);\n\n        _callPostTransferHooks(\n            toPartition,\n            _operator,\n            _from,\n            _to,\n            _value,\n            _data,\n            _operatorData\n        );\n\n        emit TransferByPartition(\n            _fromPartition,\n            _operator,\n            _from,\n            _to,\n            _value,\n            _data,\n            _operatorData\n        );\n\n        if (toPartition != _fromPartition) {\n            emit ChangedPartition(_fromPartition, toPartition, _value);\n        }\n\n        return toPartition;\n    }\n\n    /**\n     * @notice Transfer tokens from default partitions.\n     * @dev Used as a helper method for ERC20 compatibility.\n     * @param _operator The address performing the transfer.\n     * @param _from Token holder.\n     * @param _to Token recipient.\n     * @param _value Number of tokens to transfer.\n     * @param _data Information attached to the transfer, and intended for the\n     * token holder (`_from`). Should contain the destination partition if\n     * changing partitions.\n     */\n    function _transferByDefaultPartition(\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) internal {\n        _transferByPartition(defaultPartition, _operator, _from, _to, _value, _data, \"\");\n    }\n\n    /**\n     * @dev Remove a token from a specific partition.\n     * @param _from Token holder.\n     * @param _partition Name of the partition.\n     * @param _value Number of tokens to transfer.\n     */\n    function _removeTokenFromPartition(\n        address _from,\n        bytes32 _partition,\n        uint256 _value\n    ) internal {\n        _balanceOfByPartition[_from][_partition] = _balanceOfByPartition[_from][_partition]\n            .sub(_value);\n        totalSupplyByPartition[_partition] = totalSupplyByPartition[_partition].sub(\n            _value\n        );\n\n        // If the total supply is zero, finds and deletes the partition.\n        // Do not delete the _defaultPartition from totalPartitions.\n        if (totalSupplyByPartition[_partition] == 0 && _partition != defaultPartition) {\n            _removePartitionFromTotalPartitions(_partition);\n        }\n\n        // If the balance of the TokenHolder's partition is zero, finds and\n        // deletes the partition.\n        if (_balanceOfByPartition[_from][_partition] == 0) {\n            uint256 index = _indexOfPartitionsOf[_from][_partition];\n\n            if (index == 0) {\n                return;\n            }\n\n            // move the last item into the index being vacated\n            bytes32 lastValue = _partitionsOf[_from][_partitionsOf[_from].length - 1];\n            _partitionsOf[_from][index - 1] = lastValue; // adjust for 1-based indexing\n            _indexOfPartitionsOf[_from][lastValue] = index;\n\n            _partitionsOf[_from].pop();\n            _indexOfPartitionsOf[_from][_partition] = 0;\n        }\n    }\n\n    /**\n     * @dev Add a token to a specific partition.\n     * @param _to Token recipient.\n     * @param _partition Name of the partition.\n     * @param _value Number of tokens to transfer.\n     */\n    function _addTokenToPartition(\n        address _to,\n        bytes32 _partition,\n        uint256 _value\n    ) internal {\n        if (_value != 0) {\n            if (_indexOfPartitionsOf[_to][_partition] == 0) {\n                _partitionsOf[_to].push(_partition);\n                _indexOfPartitionsOf[_to][_partition] = _partitionsOf[_to].length;\n            }\n            _balanceOfByPartition[_to][_partition] = _balanceOfByPartition[_to][_partition]\n                .add(_value);\n\n            if (_indexOfTotalPartitions[_partition] == 0) {\n                _addPartitionToTotalPartitions(_partition);\n            }\n            totalSupplyByPartition[_partition] = totalSupplyByPartition[_partition].add(\n                _value\n            );\n        }\n    }\n\n    /**\n     * @dev Add a partition to the total partitions collection.\n     * @param _partition Name of the partition.\n     */\n    function _addPartitionToTotalPartitions(bytes32 _partition) internal {\n        _totalPartitions.push(_partition);\n        _indexOfTotalPartitions[_partition] = _totalPartitions.length;\n    }\n\n    /**\n     * @dev Remove a partition to the total partitions collection.\n     * @param _partition Name of the partition.\n     */\n    function _removePartitionFromTotalPartitions(bytes32 _partition) internal {\n        uint256 index = _indexOfTotalPartitions[_partition];\n\n        if (index == 0) {\n            return;\n        }\n\n        // move the last item into the index being vacated\n        bytes32 lastValue = _totalPartitions[_totalPartitions.length - 1];\n        _totalPartitions[index - 1] = lastValue; // adjust for 1-based indexing\n        _indexOfTotalPartitions[lastValue] = index;\n\n        _totalPartitions.pop();\n        _indexOfTotalPartitions[_partition] = 0;\n    }\n\n    /**************************************************************************/\n    /********************************* Hooks **********************************/\n    /**\n     * @notice Check for and call the 'AmpTokensSender' hook on the sender address\n     * (`_from`), and, if `_fromPartition` is within the scope of a strategy,\n     * check for and call the 'AmpPartitionStrategy.tokensFromPartitionToTransfer'\n     * hook for the strategy.\n     * @param _fromPartition Name of the partition to transfer tokens from.\n     * @param _operator Address which triggered the balance decrease (through\n     * transfer).\n     * @param _from Token holder.\n     * @param _to Token recipient for a transfer.\n     * @param _value Number of tokens the token holder balance is decreased by.\n     * @param _data Extra information, pertaining to the `_from` address.\n     * @param _operatorData Extra information, attached by the operator (if any).\n     */\n    function _callPreTransferHooks(\n        bytes32 _fromPartition,\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        bytes memory _operatorData\n    ) internal {\n        address senderImplementation;\n        senderImplementation = interfaceAddr(_from, AMP_TOKENS_SENDER);\n        if (senderImplementation != address(0)) {\n            IAmpTokensSender(senderImplementation).tokensToTransfer(\n                msg.sig,\n                _fromPartition,\n                _operator,\n                _from,\n                _to,\n                _value,\n                _data,\n                _operatorData\n            );\n        }\n\n        // Used to ensure that hooks implemented by a collateral manager to validate\n        // transfers from it's owned partitions are called\n        bytes4 fromPartitionPrefix = _getPartitionPrefix(_fromPartition);\n        if (_isPartitionStrategy[fromPartitionPrefix]) {\n            address fromPartitionValidatorImplementation;\n            fromPartitionValidatorImplementation = interfaceAddr(\n                address(this),\n                _getPartitionStrategyValidatorIName(fromPartitionPrefix)\n            );\n            if (fromPartitionValidatorImplementation != address(0)) {\n                IAmpPartitionStrategyValidator(fromPartitionValidatorImplementation)\n                    .tokensFromPartitionToValidate(\n                    msg.sig,\n                    _fromPartition,\n                    _operator,\n                    _from,\n                    _to,\n                    _value,\n                    _data,\n                    _operatorData\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Check for 'AmpTokensRecipient' hook on the recipient and call it.\n     * @param _toPartition Name of the partition the tokens were transferred to.\n     * @param _operator Address which triggered the balance increase (through\n     * transfer or mint).\n     * @param _from Token holder for a transfer (0x when mint).\n     * @param _to Token recipient.\n     * @param _value Number of tokens the recipient balance is increased by.\n     * @param _data Extra information related to the token holder (`_from`).\n     * @param _operatorData Extra information attached by the operator (if any).\n     */\n    function _callPostTransferHooks(\n        bytes32 _toPartition,\n        address _operator,\n        address _from,\n        address _to,\n        uint256 _value,\n        bytes memory _data,\n        bytes memory _operatorData\n    ) internal {\n        bytes4 toPartitionPrefix = _getPartitionPrefix(_toPartition);\n        if (_isPartitionStrategy[toPartitionPrefix]) {\n            address partitionManagerImplementation;\n            partitionManagerImplementation = interfaceAddr(\n                address(this),\n                _getPartitionStrategyValidatorIName(toPartitionPrefix)\n            );\n            if (partitionManagerImplementation != address(0)) {\n                IAmpPartitionStrategyValidator(partitionManagerImplementation)\n                    .tokensToPartitionToValidate(\n                    msg.sig,\n                    _toPartition,\n                    _operator,\n                    _from,\n                    _to,\n                    _value,\n                    _data,\n                    _operatorData\n                );\n            }\n        } else {\n            require(toPartitionPrefix == ZERO_PREFIX, EC_5D_PARTITION_RESERVED);\n        }\n\n        address recipientImplementation;\n        recipientImplementation = interfaceAddr(_to, AMP_TOKENS_RECIPIENT);\n\n        if (recipientImplementation != address(0)) {\n            IAmpTokensRecipient(recipientImplementation).tokensReceived(\n                msg.sig,\n                _toPartition,\n                _operator,\n                _from,\n                _to,\n                _value,\n                _data,\n                _operatorData\n            );\n        }\n    }\n\n    /**************************************************************************/\n    /******************************* Allowance ********************************/\n    /**\n     * @notice Sets `_amount` as the allowance of `_spender` over the\n     * `_tokenHolder`s tokens.\n     * @dev This is internal function is equivalent to `approve`, and can be used\n     * to e.g. set automatic allowances for certain subsystems, etc.\n     * Emits an {Approval} event.\n     * Requirements:\n     * - `_tokenHolder` cannot be the zero address.\n     * - `_spender` cannot be the zero address.\n     * @param _tokenHolder Owner of the tokens\n     * @param _spender Operator allowed to transfer the tokens\n     * @param _amount Amount of `_tokenHolder`s tokens `_spender` is allowed to\n     * transfer\n     */\n    function _approve(\n        address _tokenHolder,\n        address _spender,\n        uint256 _amount\n    ) internal {\n        require(_tokenHolder != address(0), EC_56_INVALID_SENDER);\n        require(_spender != address(0), EC_58_INVALID_OPERATOR);\n\n        _allowed[_tokenHolder][_spender] = _amount;\n        emit Approval(_tokenHolder, _spender, _amount);\n    }\n\n    /**\n     * @notice Approve the `_spender` address to spend the specified amount of\n     * tokens in `_partition` on behalf of 'msg.sender'.\n     * @param _partition Name of the partition.\n     * @param _tokenHolder Owner of the tokens.\n     * @param _spender The address which will spend the tokens.\n     * @param _amount The amount of tokens to be tokens.\n     */\n    function _approveByPartition(\n        bytes32 _partition,\n        address _tokenHolder,\n        address _spender,\n        uint256 _amount\n    ) internal {\n        require(_tokenHolder != address(0), EC_56_INVALID_SENDER);\n        require(_spender != address(0), EC_58_INVALID_OPERATOR);\n        _allowedByPartition[_partition][_tokenHolder][_spender] = _amount;\n        emit ApprovalByPartition(_partition, _tokenHolder, _spender, _amount);\n    }\n\n    /**************************************************************************/\n    /************************** Operator Information **************************/\n    /**\n     * @dev Indicate whether the operator address is an operator of the\n     * tokenHolder address.\n     * @param _operator Address which may be an operator of '_tokenHolder'.\n     * @param _tokenHolder Address of a token holder which may have the '_operator'\n     * address as an operator.\n     * @return 'true' if `_operator` is an operator of `_tokenHolder` and 'false'\n     * otherwise.\n     */\n    function _isOperator(address _operator, address _tokenHolder)\n        internal\n        view\n        returns (bool)\n    {\n        return (_operator == _tokenHolder ||\n            _authorizedOperator[_tokenHolder][_operator]);\n    }\n\n    /**\n     * @dev Indicate whether the operator address is an operator of the tokenHolder\n     * address for the given partition.\n     * @param _partition Name of the partition.\n     * @param _operator Address which may be an operator of tokenHolder for the\n     * given partition.\n     * @param _tokenHolder Address of a token holder which may have the operator\n     * address as an operator for the given partition.\n     * @return 'true' if 'operator' is an operator of 'tokenHolder' for partition\n     * `_partition` and 'false' otherwise.\n     */\n    function _isOperatorForPartition(\n        bytes32 _partition,\n        address _operator,\n        address _tokenHolder\n    ) internal view returns (bool) {\n        return (_isOperator(_operator, _tokenHolder) ||\n            _authorizedOperatorByPartition[_tokenHolder][_partition][_operator] ||\n            _callPartitionStrategyOperatorHook(_partition, _operator, _tokenHolder));\n    }\n\n    /**\n     * @notice Check if the `_partition` is within the scope of a strategy, and\n     * call it's isOperatorForPartitionScope hook if so.\n     * @dev This allows implicit granting of operatorByPartition permissions\n     * based on the partition being used being of a strategy.\n     * @param _partition The partition to check.\n     * @param _operator The address to check if is an operator for `_tokenHolder`.\n     * @param _tokenHolder The address to validate that `_operator` is an\n     * operator for.\n     */\n    function _callPartitionStrategyOperatorHook(\n        bytes32 _partition,\n        address _operator,\n        address _tokenHolder\n    ) internal view returns (bool) {\n        bytes4 prefix = _getPartitionPrefix(_partition);\n\n        if (!_isPartitionStrategy[prefix]) {\n            return false;\n        }\n\n        address strategyValidatorImplementation;\n        strategyValidatorImplementation = interfaceAddr(\n            address(this),\n            _getPartitionStrategyValidatorIName(prefix)\n        );\n        if (strategyValidatorImplementation != address(0)) {\n            return\n                IAmpPartitionStrategyValidator(strategyValidatorImplementation)\n                    .isOperatorForPartitionScope(_partition, _operator, _tokenHolder);\n        }\n\n        // Not a partition format that imbues special operator rules\n        return false;\n    }\n\n    /**************************************************************************/\n    /******************************** Minting *********************************/\n    /**\n     * @notice Perform the minting of tokens.\n     * @dev The tokens will be minted on behalf of the `_to` address, and will be\n     * minted to the address's default partition.\n     * @param _operator Address which triggered the issuance.\n     * @param _to Token recipient.\n     * @param _value Number of tokens issued.\n     * @param _data Information attached to the minting, and intended for the\n     * recipient (`_to`).\n     */\n    function _mint(\n        address _operator,\n        address _to,\n        uint256 _value,\n        bytes memory _data\n    ) internal {\n        require(_to != address(0), EC_57_INVALID_RECEIVER);\n\n        _totalSupply = _totalSupply.add(_value);\n        _balances[_to] = _balances[_to].add(_value);\n\n        _addTokenToPartition(_to, defaultPartition, _value);\n        _callPostTransferHooks(\n            defaultPartition,\n            _operator,\n            address(0),\n            _to,\n            _value,\n            _data,\n            \"\"\n        );\n\n        emit Minted(_operator, _to, _value, _data);\n        emit Transfer(address(0), _to, _value);\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Axiemon Token Security Audit/code/BSCSCAN-0xC512261b8AE70260447A74aC7d94dAee150B90C0.sol",
        "contract": "LiquidityGeneratorToken",
        "function": "addLiquidity",
        "line": 1082,
        "line_end": 1095,
        "name": "unused-return",
        "code_segment": "contract LiquidityGeneratorToken is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n    using Address for address;\n    address dead = 0x000000000000000000000000000000000000dEaD;\n    uint256 public maxLiqFee = 10;\n    uint256 public maxTaxFee = 10;\n    uint256 public minMxTxPercentage = 50;\n    uint256 public prevLiqFee;\n    uint256 public prevTaxFee;\n    mapping (address => uint256) private _rOwned;\n    mapping (address => uint256) private _tOwned;\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    mapping (address => bool) private _isExcludedFromFee;\n  // SWC-135-Code With No Effects: L702 - L703\n    mapping (address => bool) private _isExcluded;\n    address[] private _excluded;\n    address public router = 0x10ED43C718714eb63d5aA57B78B54704E256024E; // PCS v2 mainnet\n    uint256 private constant MAX = ~uint256(0);\n    uint256 public _tTotal;\n    uint256 private _rTotal;\n    uint256 private _tFeeTotal;\n    // SWC-131-Presence of unused variables: L710\n    bool public mintedByDxsale = true;\n    string public _name;\n    string public _symbol;\n    uint8 private _decimals;\n    \n    uint256 public _taxFee;\n    uint256 private _previousTaxFee = _taxFee;\n    \n    uint256 public _liquidityFee;\n    uint256 private _previousLiquidityFee = _liquidityFee;\n\n    IUniswapV2Router02 public immutable uniswapV2Router;\n    address public immutable uniswapV2Pair;\n    \n    bool inSwapAndLiquify;\n    bool public swapAndLiquifyEnabled = false;\n    \n    uint256 public _maxTxAmount;\n    uint256 public numTokensSellToAddToLiquidity;\n    \n    event MinTokensBeforeSwapUpdated(uint256 minTokensBeforeSwap);\n    event SwapAndLiquifyEnabledUpdated(bool enabled);\n    event SwapAndLiquify(\n        uint256 tokensSwapped,\n        uint256 ethReceived,\n        uint256 tokensIntoLiqudity\n    );\n    \n    modifier lockTheSwap {\n        inSwapAndLiquify = true;\n        _;\n        inSwapAndLiquify = false;\n    }\n    \n    constructor (address tokenOwner,string memory name, string memory symbol,uint8 decimal, uint256 amountOfTokenWei,uint8 setTaxFee, uint8 setLiqFee, uint256 _maxTaxFee, uint256 _maxLiqFee, uint256 _minMxTxPer) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimal;\n        _tTotal = amountOfTokenWei;\n        _rTotal = (MAX - (MAX % _tTotal));\n        \n        _rOwned[tokenOwner] = _rTotal;\n        \n        maxTaxFee = _maxTaxFee;        \n        maxLiqFee = _maxLiqFee;\n        minMxTxPercentage = _minMxTxPer;\n        prevTaxFee = setTaxFee;        \n        prevLiqFee = setLiqFee;\n\n        _maxTxAmount = amountOfTokenWei;\n        numTokensSellToAddToLiquidity = amountOfTokenWei.mul(1).div(1000);\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(router);\n         // Create a uniswap pair for this new token\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\n            .createPair(address(this), _uniswapV2Router.WETH());\n\n        // set the rest of the contract variables\n        uniswapV2Router = _uniswapV2Router;\n        \n        //exclude owner and this contract from fee\n        _isExcludedFromFee[owner()] = true;\n        _isExcludedFromFee[address(this)] = true;\n        \n        emit Transfer(address(0), tokenOwner, _tTotal);\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    function balanceOf(address account) public view override returns (uint256) {\n      // SWC-135-Code With No Effects: L793 - L794\n        if (_isExcluded[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    // SWC-135-Code With No Effects: L828 - L831\n    function isExcludedFromReward(address account) public view returns (bool) {\n        return _isExcluded[account];\n    }\n\n    function totalFees() public view returns (uint256) {\n        return _tFeeTotal;\n    }\n\n  // SWC-135-Code With No Effects: L837 - L844\n    function deliver(uint256 tAmount) public {\n        address sender = _msgSender();\n        require(!_isExcluded[sender], \"Excluded addresses cannot call this function\");\n        (uint256 rAmount,,,,,) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rTotal = _rTotal.sub(rAmount);\n        _tFeeTotal = _tFeeTotal.add(tAmount);\n    }\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee) public view returns(uint256) {\n        require(tAmount <= _tTotal, \"Amount must be less than supply\");\n        if (!deductTransferFee) {\n            (uint256 rAmount,,,,,) = _getValues(tAmount);\n            return rAmount;\n        } else {\n            (,uint256 rTransferAmount,,,,) = _getValues(tAmount);\n            return rTransferAmount;\n        }\n    }\n\n    function tokenFromReflection(uint256 rAmount) public view returns(uint256) {\n        require(rAmount <= _rTotal, \"Amount must be less than total reflections\");\n        uint256 currentRate =  _getRate();\n        return rAmount.div(currentRate);\n    }\n\n\n  // SWC-135-Code With No Effects: L865 - L874\n        function _transferBothExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);        \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n    \n        function excludeFromFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = true;\n    }\n    \n    function includeInFee(address account) public onlyOwner {\n        _isExcludedFromFee[account] = false;\n    }\n    \n    function setTaxFeePercent(uint256 taxFee) external onlyOwner() {\n         require(taxFee >= 0 && taxFee <=maxTaxFee,\"taxFee out of range\");\n        _taxFee = taxFee;\n    }\n    \n    function setLiquidityFeePercent(uint256 liquidityFee) external onlyOwner() {\n         require(liquidityFee >= 0 && liquidityFee <=maxLiqFee,\"liquidityFee out of range\");\n        _liquidityFee = liquidityFee;\n    }\n   \n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner() {\n        require(maxTxPercent >= minMxTxPercentage && maxTxPercent <=100,\"maxTxPercent out of range\");\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(\n            10**2\n        );\n    }\n\n    function setSwapAndLiquifyEnabled(bool _enabled) public onlyOwner {\n        swapAndLiquifyEnabled = _enabled;\n        emit SwapAndLiquifyEnabledUpdated(_enabled);\n    }\n    \n     //to recieve ETH from uniswapV2Router when swaping\n    receive() external payable {}\n\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tFeeTotal = _tFeeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\n        (uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getTValues(tAmount);\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(tAmount, tFee, tLiquidity, _getRate());\n        return (rAmount, rTransferAmount, rFee, tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getTValues(uint256 tAmount) private view returns (uint256, uint256, uint256) {\n        uint256 tFee = calculateTaxFee(tAmount);\n        uint256 tLiquidity = calculateLiquidityFee(tAmount);\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\n        return (tTransferAmount, tFee, tLiquidity);\n    }\n\n    function _getRValues(uint256 tAmount, uint256 tFee, uint256 tLiquidity, uint256 currentRate) private pure returns (uint256, uint256, uint256) {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns(uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    // SWC-135-Code With No Effects: L941 - L951\n    function _getCurrentSupply() private view returns(uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;      \n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_rOwned[_excluded[i]] > rSupply || _tOwned[_excluded[i]] > tSupply) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n    \n    // SWC-135-Code With No Effects: L952 - L958\n    function _takeLiquidity(uint256 tLiquidity) private {\n        uint256 currentRate =  _getRate();\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\n        if(_isExcluded[address(this)])\n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\n    }\n    \n    function calculateTaxFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_taxFee).div(\n            10**2\n        );\n    }\n\n    function calculateLiquidityFee(uint256 _amount) private view returns (uint256) {\n        return _amount.mul(_liquidityFee).div(\n            10**2\n        );\n    }\n    \n    function removeAllFee() private {\n        if(_taxFee == 0 && _liquidityFee == 0) return;\n        \n        _previousTaxFee = _taxFee;\n        _previousLiquidityFee = _liquidityFee;\n        \n        _taxFee = 0;\n        _liquidityFee = 0;\n    }\n    \n    function restoreAllFee() private {\n        _taxFee = _previousTaxFee;\n        _liquidityFee = _previousLiquidityFee;\n    }\n    \n    function isExcludedFromFee(address account) public view returns(bool) {\n        return _isExcludedFromFee[account];\n    }\n\n    function _approve(address owner, address spender, uint256 amount) private {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n        require(amount > 0, \"Transfer amount must be greater than zero\");\n        if(from != owner() && to != owner())\n            require(amount <= _maxTxAmount, \"Transfer amount exceeds the maxTxAmount.\");\n\n        // is the token balance of this contract address over the min number of\n        // tokens that we need to initiate a swap + liquidity lock?\n        // also, don't get caught in a circular liquidity event.\n        // also, don't swap & liquify if sender is uniswap pair.\n        uint256 contractTokenBalance = balanceOf(address(this));\n        \n        if(contractTokenBalance >= _maxTxAmount)\n        {\n            contractTokenBalance = _maxTxAmount;\n        }\n        \n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\n        if (\n            overMinTokenBalance &&\n            !inSwapAndLiquify &&\n            from != uniswapV2Pair &&\n            swapAndLiquifyEnabled\n        ) {\n            contractTokenBalance = numTokensSellToAddToLiquidity;\n            //add liquidity\n            swapAndLiquify(contractTokenBalance);\n        }\n        \n        //indicates if fee should be deducted from transfer\n        bool takeFee = true;\n        \n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if(_isExcludedFromFee[from] || _isExcludedFromFee[to]){\n            takeFee = false;\n        }\n        \n        //transfer amount, it will take tax, burn, liquidity fee\n        _tokenTransfer(from,to,amount,takeFee);\n    }\n\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\n        // split the contract balance into halves\n        uint256 half = contractTokenBalance.div(2);\n        uint256 otherHalf = contractTokenBalance.sub(half);\n\n        // capture the contract's current ETH balance.\n        // this is so that we can capture exactly the amount of ETH that the\n        // swap creates, and not make the liquidity event include any ETH that\n        // has been manually sent to the contract\n        uint256 initialBalance = address(this).balance;\n\n        // swap tokens for ETH\n        swapTokensForEth(half); // <- this breaks the ETH -> HATE swap when swap+liquify is triggered\n\n        // how much ETH did we just swap into?\n        uint256 newBalance = address(this).balance.sub(initialBalance);\n\n        // add liquidity to uniswap\n        addLiquidity(otherHalf, newBalance);\n        \n        emit SwapAndLiquify(half, newBalance, otherHalf);\n    }\n\n    function swapTokensForEth(uint256 tokenAmount) private {\n        // generate the uniswap pair path of token -> weth\n        address[] memory path = new address[](2);\n        path[0] = address(this);\n        path[1] = uniswapV2Router.WETH();\n\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // make the swap\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\n            tokenAmount,\n            0, // accept any amount of ETH\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\n        // approve token transfer to cover all possible scenarios\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\n\n        // add the liquidity\n        uniswapV2Router.addLiquidityETH{value: ethAmount}(\n            address(this),\n            tokenAmount,\n            0, // slippage is unavoidable\n            0, // slippage is unavoidable\n            dead,\n            block.timestamp\n        );\n    }\n\n    //this method is responsible for taking all fee, if takeFee is true\n    // SWC-135-Code With No Effects: L1103 - L1121\n    function _tokenTransfer(address sender, address recipient, uint256 amount,bool takeFee) private {\n        if(!takeFee)\n            removeAllFee();\n        \n        if (_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (!_isExcluded[sender] && !_isExcluded[recipient]) {\n            _transferStandard(sender, recipient, amount);\n        } else if (_isExcluded[sender] && _isExcluded[recipient]) {\n            _transferBothExcluded(sender, recipient, amount);\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n        \n        if(!takeFee)\n            restoreAllFee();\n    }\n\n    function _transferStandard(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n\n// SWC-135-Code With No Effects: L1134 - L1143\n    function _transferToExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);           \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n// SWC-135-Code With No Effects: L1145 - L1153\n    function _transferFromExcluded(address sender, address recipient, uint256 tAmount) private {\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee, uint256 tTransferAmount, uint256 tFee, uint256 tLiquidity) = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);   \n        _takeLiquidity(tLiquidity);\n        _reflectFee(rFee, tFee);\n        emit Transfer(sender, recipient, tTransferAmount);\n    }\n\n    function disableFees() public onlyOwner {\n        prevLiqFee = _liquidityFee;\n        prevTaxFee = _taxFee;\n        \n        _maxTxAmount = _tTotal;\n        _liquidityFee = 0;\n        _taxFee = 0;\n        swapAndLiquifyEnabled = false; \n    }\n    \n    function enableFees() public onlyOwner {\n        _maxTxAmount = _tTotal;\n        _liquidityFee = prevLiqFee;\n        _taxFee = prevTaxFee;\n        swapAndLiquifyEnabled = true;   \n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "contract": "ProjectWalletAuthoriser",
        "function": "transfer",
        "line": 95,
        "line_end": 105,
        "name": "unchecked-transfer",
        "code_segment": "contract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-Hakka_Finance_wHakka/code/wHakka.sol",
        "contract": "wHakka",
        "function": "stake",
        "line": 558,
        "line_end": 575,
        "name": "reentrancy-benign",
        "code_segment": "contract wHakka is Ownable, ERC20Mintable {\n    using SafeMath for *;\n    using SafeERC20 for IERC20;\n\n    struct vault {\n        uint256 hakkaAmount;\n        uint256 wAmount;\n        uint256 unlockTime;\n    }\n\n    event Stake(address indexed holder, address indexed depositor, uint256 amount, uint256 wAmount, uint256 time);\n    event Unstake(address indexed holder, address indexed receiver, uint256 amount, uint256 wAmount);\n\n    IERC20 public constant Hakka = IERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\n    stakingRateModel public currentModel;\n\n    mapping(address => mapping(uint256 => vault)) public vaults;\n    mapping(address => uint256) public vaultCount;\n    mapping(address => uint256) public stakedHakka;\n    mapping(address => uint256) public votingPower;\n\n    constructor() public {\n        symbol = \"wHAKKA\";\n        name = \"Wrapped Hakka\";\n        decimals = 18;\n        _balances[address(this)] = uint256(-1);\n        _balances[address(0)] = uint256(-1);\n    }\n\n    function getStakingRate(uint256 time) public returns (uint256 rate) {\n        return currentModel.stakingRate(time);\n    }\n\n    function setStakingRateModel(address newModel) external onlyOwner {\n        currentModel = stakingRateModel(newModel);\n    }\n\n// SWC-107-Reentrancy: L556 - L573\n    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n        vault storage v = vaults[to][vaultCount[to]];\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n        require(wAmount > 0, \"invalid lockup\");\n\n        v.hakkaAmount = amount;\n        v.wAmount = wAmount;\n        v.unlockTime = block.timestamp.add(time);\n        \n        stakedHakka[to] = stakedHakka[to].add(amount);\n        votingPower[to] = votingPower[to].add(wAmount);\n        vaultCount[to]++;\n\n        _mint(to, wAmount);\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n    }\n\n    // SWC-107-Reentrancy: L576 - L592\n    function unstake(address to, uint256 index, uint256 wAmount) public returns (uint256 amount) {\n        vault storage v = vaults[msg.sender][index];\n        // SWC-116-Block values as a proxy for time: L580\n        require(block.timestamp >= v.unlockTime, \"locked\");\n        require(wAmount <= v.wAmount, \"exceed locked amount\");\n        amount = wAmount.mul(v.hakkaAmount).div(v.wAmount);\n\n        v.hakkaAmount = v.hakkaAmount.sub(amount);\n        v.wAmount = v.wAmount.sub(wAmount);\n\n        stakedHakka[msg.sender] = stakedHakka[msg.sender].sub(amount);\n        votingPower[msg.sender] = votingPower[msg.sender].sub(wAmount);\n\n        _burn(msg.sender, wAmount);\n        Hakka.safeTransfer(to, amount);\n        \n        emit Unstake(msg.sender, to, amount, wAmount);\n    }\n\n    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n        require(_TokenAddress != Hakka);\n        _TokenAddress.safeTransfer(msg.sender, _amount);\n    }\n\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Citrus Smart Contract/CitrusTechContract-e50a2a983928c10b76e6bc374ae6267f51af99b6/CitrusToken.sol",
        "contract": "TimeLock",
        "function": "release",
        "line": 125,
        "line_end": 138,
        "name": "unchecked-transfer",
        "code_segment": "contract TimeLock is Owned, BEP20 {\n    \n    struct LockedAccounts {\n        address account;\n        uint amount;\n        uint time;\n        Locked[] locked;\n    }\n    \n    struct Locked {\n        uint time;\n        uint amount;\n        uint lockedAt;\n    }\n    \n    mapping(address => LockedAccounts) lock;\n    \n    function timelock(address _lockAccount, uint time, uint amount) public onlyOwner returns (bool) {\n        require(amount > 0, \"TimeLock: Amount cannot be zero\");\n        transfer(address(this), amount);\n        lock[_lockAccount].account = _lockAccount;\n        lock[_lockAccount].amount = amount;\n        lock[_lockAccount].time = time;\n        lock[_lockAccount].locked.push(Locked(time, amount, block.timestamp));\n        return true;\n    }\n    \n    function release() public returns (bool) {\n        LockedAccounts storage lockedAccount = lock[msg.sender];\n//        SWC-104-Unchecked Call Return Value: L132\n        for(uint i = 0; i < lockedAccount.locked.length; i++) {\n            Locked storage loc = lockedAccount.locked[i];\n            require(block.timestamp >= (loc.time + loc.lockedAt), \"TimeLock: Release time not reached\");\n            uint amount = loc.amount;\n            BEP(address(this)).transfer(msg.sender, amount);\n            loc.amount = 0;\n            loc.time = 0;\n            loc.lockedAt = 0;\n        }\n        return true;\n    }\n    \n    function lockedAccountDetails(address user) public view returns (uint[] memory, uint[] memory, uint[] memory, uint[] memory, uint) {\n        uint lockedLength = lock[user].locked.length;\n        uint[] memory lockedAmounts = new uint[](lockedLength);\n        uint[] memory lockTimes = new uint[](lockedLength);\n        uint[] memory lockedAt = new uint[](lockedLength);\n        uint[] memory totalLockTime = new uint[](lockedLength);\n        uint currentTime = block.timestamp;\n        \n        \n        for(uint i = 0; i < lockedLength; i++) {\n            lockedAmounts[i] = lock[user].locked[i].amount;\n            lockTimes[i] = lock[user].locked[i].time;\n            lockedAt[i] = lock[user].locked[i].lockedAt;\n            totalLockTime[i] = lock[user].locked[i].time + lock[user].locked[i].lockedAt;\n        }\n        return(lockedAmounts, lockTimes, lockedAt, totalLockTime, currentTime);\n    }\n}",
        "check": "TP"
    }
]