[
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 42,
        "line_end": 42,
        "name": "Division bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 41,
        "line_end": 41,
        "name": "Overflow bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 41,
        "line_end": 41,
        "name": "Division bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 653,
        "line_end": 653,
        "name": "Concurrency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 672,
        "line_end": 672,
        "name": "Concurrency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 626,
        "line_end": 626,
        "name": "Overflow bugs",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 662,
        "line_end": 662,
        "name": "Time dependency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 662,
        "line_end": 662,
        "name": "Time dependency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 740,
        "line_end": 740,
        "name": "Underflow bugs",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Fee",
        "function": null,
        "line": 1,
        "line_end": 1,
        "name": "Overflow bugs",
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Fee",
        "function": null,
        "line": 92,
        "line_end": 92,
        "name": "Overflow bugs",
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Fee",
        "function": null,
        "line": 93,
        "line_end": 93,
        "name": "Overflow bugs",
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Fee",
        "function": null,
        "line": 181,
        "line_end": 181,
        "name": "Overflow bugs",
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Fee",
        "function": null,
        "line": 190,
        "line_end": 190,
        "name": "Overflow bugs",
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Owned",
        "function": null,
        "line": 1,
        "line_end": 1,
        "name": "Overflow bugs",
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Owned",
        "function": null,
        "line": 92,
        "line_end": 92,
        "name": "Overflow bugs",
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "Owned",
        "function": null,
        "line": 93,
        "line_end": 93,
        "name": "Overflow bugs",
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "StandardToken",
        "function": null,
        "line": 181,
        "line_end": 181,
        "name": "Overflow bugs",
        "code_segment": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "contract": "StandardToken",
        "function": null,
        "line": 190,
        "line_end": 190,
        "name": "Overflow bugs",
        "code_segment": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "contract": "NanoLoanEngine",
        "function": null,
        "line": 520,
        "line_end": 520,
        "name": "Overflow bugs",
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "contract": "NanoLoanEngine",
        "function": null,
        "line": 521,
        "line_end": 521,
        "name": "Overflow bugs",
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "contract": "NanoLoanEngine",
        "function": null,
        "line": 865,
        "line_end": 865,
        "name": "Overflow bugs",
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "contract": "StakingPool",
        "function": null,
        "line": 128,
        "line_end": 128,
        "name": "Overflow bugs",
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "contract": "StakingPool",
        "function": null,
        "line": 349,
        "line_end": 349,
        "name": "Overflow bugs",
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "FreezableMintableToken",
        "function": null,
        "line": 398,
        "line_end": 398,
        "name": "Overflow bugs",
        "code_segment": "contract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "FreezableMintableToken",
        "function": null,
        "line": 432,
        "line_end": 432,
        "name": "Overflow bugs",
        "code_segment": "contract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "FreezableToken",
        "function": null,
        "line": 398,
        "line_end": 398,
        "name": "Overflow bugs",
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "FreezableToken",
        "function": null,
        "line": 432,
        "line_end": 432,
        "name": "Overflow bugs",
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "MainToken",
        "function": null,
        "line": 398,
        "line_end": 398,
        "name": "Overflow bugs",
        "code_segment": "contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable {\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0x1e57f50778fc34dae64d7f16ad120193f8631464)];\n        uint[1] memory amounts = [uint(10000000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "contract": "MainToken",
        "function": null,
        "line": 432,
        "line_end": 432,
        "name": "Overflow bugs",
        "code_segment": "contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable {\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0x1e57f50778fc34dae64d7f16ad120193f8631464)];\n        uint[1] memory amounts = [uint(10000000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "contract": "MainContract",
        "function": null,
        "line": 354,
        "line_end": 354,
        "name": "Overflow bugs",
        "code_segment": "contract MainContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n    struct AccountData {\n        uint8 accountType; // 0 => Freelancer, 1 => Approver, 2 => Customer\n        address personWalletAddress;\n        uint256 personWorkCount;\n        uint256[] personPuan; // Rate x/5\n        address[] WorkAddresses; // All work addresses\n        string personInfoData;\n    }\n\n    mapping(address => AccountData) accounts;\n    mapping(address => bool) personsAddress;\n    mapping(address => uint8) public feeRates;\n    mapping(address => bool) public availableTokens;\n    mapping(address => uint256) public approverLockBalances;\n    mapping(address => bool) public isDeployedWorks;\n\n    uint8 public bnbFeeRate;\n    uint256 public remainingArgonToken;\n    uint256 public approverMinArgonLimit;\n    address[] public deployedWorks;\n    address[] public allPersons;\n    address public feeAddress;\n    address public argonTokenContractAddress;\n    bool public isActive;\n    IERC20 public argonToken; // ArgonToken Contract Address\n\n    modifier isInAccounts() {\n        require(personsAddress[msg.sender]);\n        _;\n    }\n\n    modifier mustApprover() {\n        require(personsAddress[msg.sender]);\n        AccountData storage data = accounts[msg.sender];\n        require(data.accountType == 1);\n        _;\n    }\n\n    modifier mustActive() {\n        require(isActive);\n        _;\n    }\n\n    constructor(\n        address _argonTokenAddress,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) public {\n        argonToken = IERC20(_argonTokenAddress);\n        bnbFeeRate = _bnbFeeRate;\n        remainingArgonToken = 5e6 ether;\n        approverMinArgonLimit = 20000 * 10**18;\n        feeAddress = _feeAddress;\n        argonTokenContractAddress = _argonTokenAddress;\n    }\n\n    function changeActive(bool _active) external onlyApprover {\n        isActive = _active;\n    }\n\n    function changeAvailableTokenFee(\n        address _tokenAddress,\n        uint8 _feeRate,\n        bool _available\n    ) external onlyApprover {\n        feeRates[_tokenAddress] = _feeRate;\n        availableTokens[_tokenAddress] = _available;\n    }\n\n    function changeSettings(\n        uint256 _approverMinArgonLimit,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) external onlyApprover {\n        approverMinArgonLimit = _approverMinArgonLimit;\n        bnbFeeRate = _bnbFeeRate;\n        feeAddress = _feeAddress;\n    }\n\n    function sendArgonTokenAdmin(address _address, uint256 amount)\n        external\n        onlyApprover\n        nonReentrant\n    {\n        argonToken.transfer(_address, amount);\n    }\n\n    function unLock() external mustApprover nonReentrant {\n        require(approverLockBalances[msg.sender] > 0);\n        AccountData storage data = accounts[msg.sender];\n        require(data.WorkAddresses.length == 0);\n        delete accounts[msg.sender];\n        personsAddress[msg.sender] = false;\n        for (uint256 x = 0; x < allPersons.length; x++) {\n            if (allPersons[x] == msg.sender) {\n                delete allPersons[x];\n            }\n        }\n        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);\n        approverLockBalances[msg.sender] = 0;\n    }\n\n    function getAllPersons() external view returns (address[]) {\n        return allPersons;\n    }\n\n    function addPerson(uint8 _accountType, string _personInfoData)\n        external\n        mustActive\n        nonReentrant\n    {\n        if (_accountType == 1) {\n            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]\n                .safeAdd(approverMinArgonLimit);\n            require(\n                argonToken.transferFrom(\n                    msg.sender,\n                    address(this),\n                    approverMinArgonLimit\n                )\n            );\n        }\n        require(!personsAddress[msg.sender]);\n        AccountData memory newAccount =\n            AccountData({\n                accountType: _accountType,\n                personWalletAddress: msg.sender,\n                personWorkCount: 0,\n                personPuan: new uint256[](0),\n                WorkAddresses: new address[](0),\n                personInfoData: _personInfoData\n            });\n\n        accounts[msg.sender] = newAccount; // Adding a new account\n        allPersons.push(msg.sender); // Adding a new account\n        personsAddress[msg.sender] = true;\n    }\n\n    function getPersonInfoData(address _personAddress)\n        external\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256[],\n            address[],\n            string\n        )\n    {\n        AccountData storage data = accounts[_personAddress];\n        return (\n            data.accountType,\n            data.personWorkCount,\n            data.personPuan,\n            data.WorkAddresses,\n            data.personInfoData\n        );\n    }\n\n    function getPersonAccountType(address _personAddress)\n        public\n        view\n        returns (uint8)\n    {\n        AccountData storage data = accounts[_personAddress];\n        return data.accountType;\n    }\n\n    function updatePerson(string _personInfoData)\n        external\n        isInAccounts\n        mustActive\n    {\n        AccountData storage data = accounts[msg.sender];\n        data.personInfoData = _personInfoData;\n    }\n\n    function createWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget\n    ) external mustActive {\n        AccountData storage data = accounts[msg.sender];\n        require(getPersonAccountType(msg.sender) == 2);\n        address newWork =\n            new WorkContract(\n                _workTitle,\n                _workCategory,\n                _workDescription,\n                _workAvarageBudget,\n                msg.sender,\n                this\n            );\n        data.WorkAddresses.push(newWork); // Adding Person Works\n        deployedWorks.push(newWork); // Adding All Works\n        isDeployedWorks[newWork] = true;\n    }\n\n    function getWorks() external view returns (address[]) {\n        return deployedWorks;\n    }\n\n    function setPuan(uint256 _puan, address _freelancerAddress) external {\n        require(isDeployedWorks[msg.sender]);\n        AccountData storage data = accounts[_freelancerAddress];\n        data.personPuan.push(_puan);\n    }\n\n    function setApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        data.WorkAddresses.push(_workAddress);\n    }\n\n    function _removeApproverWorkAddressArray(\n        uint256 index,\n        address _approveraddress\n    ) private {\n        AccountData storage data = accounts[_approveraddress];\n\n        if (index >= data.WorkAddresses.length) return;\n\n        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {\n            data.WorkAddresses[i] = data.WorkAddresses[i + 1];\n        }\n        delete data.WorkAddresses[data.WorkAddresses.length - 1];\n        data.WorkAddresses.length--;\n    }\n\n    function deleteApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {\n            if (data.WorkAddresses[i] == _workAddress) {\n                _removeApproverWorkAddressArray(i, _approveraddress);\n            }\n        }\n    }\n\n    function checkDeadline(address _workAddress)\n        external\n        view\n        returns (bool, address)\n    {\n        WorkContract deployedWork;\n        deployedWork = WorkContract(_workAddress);\n        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {\n            return (true, _workAddress);\n        } else {\n            return (false, _workAddress);\n        }\n    }\n\n    function sendApproverArgonCoin(address _approveraddress) external {\n        require(isDeployedWorks[msg.sender]);\n\n        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);\n        argonToken.transfer(_approveraddress, amount);\n        remainingArgonToken = remainingArgonToken.safeSub(amount);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "contract": "MainContract",
        "function": null,
        "line": 354,
        "line_end": 354,
        "name": "Truncation bugs",
        "code_segment": "contract MainContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n    struct AccountData {\n        uint8 accountType; // 0 => Freelancer, 1 => Approver, 2 => Customer\n        address personWalletAddress;\n        uint256 personWorkCount;\n        uint256[] personPuan; // Rate x/5\n        address[] WorkAddresses; // All work addresses\n        string personInfoData;\n    }\n\n    mapping(address => AccountData) accounts;\n    mapping(address => bool) personsAddress;\n    mapping(address => uint8) public feeRates;\n    mapping(address => bool) public availableTokens;\n    mapping(address => uint256) public approverLockBalances;\n    mapping(address => bool) public isDeployedWorks;\n\n    uint8 public bnbFeeRate;\n    uint256 public remainingArgonToken;\n    uint256 public approverMinArgonLimit;\n    address[] public deployedWorks;\n    address[] public allPersons;\n    address public feeAddress;\n    address public argonTokenContractAddress;\n    bool public isActive;\n    IERC20 public argonToken; // ArgonToken Contract Address\n\n    modifier isInAccounts() {\n        require(personsAddress[msg.sender]);\n        _;\n    }\n\n    modifier mustApprover() {\n        require(personsAddress[msg.sender]);\n        AccountData storage data = accounts[msg.sender];\n        require(data.accountType == 1);\n        _;\n    }\n\n    modifier mustActive() {\n        require(isActive);\n        _;\n    }\n\n    constructor(\n        address _argonTokenAddress,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) public {\n        argonToken = IERC20(_argonTokenAddress);\n        bnbFeeRate = _bnbFeeRate;\n        remainingArgonToken = 5e6 ether;\n        approverMinArgonLimit = 20000 * 10**18;\n        feeAddress = _feeAddress;\n        argonTokenContractAddress = _argonTokenAddress;\n    }\n\n    function changeActive(bool _active) external onlyApprover {\n        isActive = _active;\n    }\n\n    function changeAvailableTokenFee(\n        address _tokenAddress,\n        uint8 _feeRate,\n        bool _available\n    ) external onlyApprover {\n        feeRates[_tokenAddress] = _feeRate;\n        availableTokens[_tokenAddress] = _available;\n    }\n\n    function changeSettings(\n        uint256 _approverMinArgonLimit,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) external onlyApprover {\n        approverMinArgonLimit = _approverMinArgonLimit;\n        bnbFeeRate = _bnbFeeRate;\n        feeAddress = _feeAddress;\n    }\n\n    function sendArgonTokenAdmin(address _address, uint256 amount)\n        external\n        onlyApprover\n        nonReentrant\n    {\n        argonToken.transfer(_address, amount);\n    }\n\n    function unLock() external mustApprover nonReentrant {\n        require(approverLockBalances[msg.sender] > 0);\n        AccountData storage data = accounts[msg.sender];\n        require(data.WorkAddresses.length == 0);\n        delete accounts[msg.sender];\n        personsAddress[msg.sender] = false;\n        for (uint256 x = 0; x < allPersons.length; x++) {\n            if (allPersons[x] == msg.sender) {\n                delete allPersons[x];\n            }\n        }\n        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);\n        approverLockBalances[msg.sender] = 0;\n    }\n\n    function getAllPersons() external view returns (address[]) {\n        return allPersons;\n    }\n\n    function addPerson(uint8 _accountType, string _personInfoData)\n        external\n        mustActive\n        nonReentrant\n    {\n        if (_accountType == 1) {\n            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]\n                .safeAdd(approverMinArgonLimit);\n            require(\n                argonToken.transferFrom(\n                    msg.sender,\n                    address(this),\n                    approverMinArgonLimit\n                )\n            );\n        }\n        require(!personsAddress[msg.sender]);\n        AccountData memory newAccount =\n            AccountData({\n                accountType: _accountType,\n                personWalletAddress: msg.sender,\n                personWorkCount: 0,\n                personPuan: new uint256[](0),\n                WorkAddresses: new address[](0),\n                personInfoData: _personInfoData\n            });\n\n        accounts[msg.sender] = newAccount; // Adding a new account\n        allPersons.push(msg.sender); // Adding a new account\n        personsAddress[msg.sender] = true;\n    }\n\n    function getPersonInfoData(address _personAddress)\n        external\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256[],\n            address[],\n            string\n        )\n    {\n        AccountData storage data = accounts[_personAddress];\n        return (\n            data.accountType,\n            data.personWorkCount,\n            data.personPuan,\n            data.WorkAddresses,\n            data.personInfoData\n        );\n    }\n\n    function getPersonAccountType(address _personAddress)\n        public\n        view\n        returns (uint8)\n    {\n        AccountData storage data = accounts[_personAddress];\n        return data.accountType;\n    }\n\n    function updatePerson(string _personInfoData)\n        external\n        isInAccounts\n        mustActive\n    {\n        AccountData storage data = accounts[msg.sender];\n        data.personInfoData = _personInfoData;\n    }\n\n    function createWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget\n    ) external mustActive {\n        AccountData storage data = accounts[msg.sender];\n        require(getPersonAccountType(msg.sender) == 2);\n        address newWork =\n            new WorkContract(\n                _workTitle,\n                _workCategory,\n                _workDescription,\n                _workAvarageBudget,\n                msg.sender,\n                this\n            );\n        data.WorkAddresses.push(newWork); // Adding Person Works\n        deployedWorks.push(newWork); // Adding All Works\n        isDeployedWorks[newWork] = true;\n    }\n\n    function getWorks() external view returns (address[]) {\n        return deployedWorks;\n    }\n\n    function setPuan(uint256 _puan, address _freelancerAddress) external {\n        require(isDeployedWorks[msg.sender]);\n        AccountData storage data = accounts[_freelancerAddress];\n        data.personPuan.push(_puan);\n    }\n\n    function setApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        data.WorkAddresses.push(_workAddress);\n    }\n\n    function _removeApproverWorkAddressArray(\n        uint256 index,\n        address _approveraddress\n    ) private {\n        AccountData storage data = accounts[_approveraddress];\n\n        if (index >= data.WorkAddresses.length) return;\n\n        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {\n            data.WorkAddresses[i] = data.WorkAddresses[i + 1];\n        }\n        delete data.WorkAddresses[data.WorkAddresses.length - 1];\n        data.WorkAddresses.length--;\n    }\n\n    function deleteApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {\n            if (data.WorkAddresses[i] == _workAddress) {\n                _removeApproverWorkAddressArray(i, _approveraddress);\n            }\n        }\n    }\n\n    function checkDeadline(address _workAddress)\n        external\n        view\n        returns (bool, address)\n    {\n        WorkContract deployedWork;\n        deployedWork = WorkContract(_workAddress);\n        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {\n            return (true, _workAddress);\n        } else {\n            return (false, _workAddress);\n        }\n    }\n\n    function sendApproverArgonCoin(address _approveraddress) external {\n        require(isDeployedWorks[msg.sender]);\n\n        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);\n        argonToken.transfer(_approveraddress, amount);\n        remainingArgonToken = remainingArgonToken.safeSub(amount);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "contract": "ProjectKudos",
        "function": null,
        "line": 138,
        "line_end": 138,
        "name": "Overflow bugs",
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "contract": "ProjectKudos",
        "function": null,
        "line": 227,
        "line_end": 227,
        "name": "Overflow bugs",
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "contract": "ProjectKudos",
        "function": null,
        "line": 229,
        "line_end": 229,
        "name": "Overflow bugs",
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "contract": "ProjectKudos",
        "function": null,
        "line": 230,
        "line_end": 230,
        "name": "Overflow bugs",
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "contract": "KOK_Contract",
        "function": null,
        "line": 114,
        "line_end": 114,
        "name": "Overflow bugs",
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "contract": "DTT",
        "function": null,
        "line": 376,
        "line_end": 376,
        "name": "Overflow bugs",
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "contract": "DTT",
        "function": null,
        "line": 377,
        "line_end": 377,
        "name": "Overflow bugs",
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "contract": "DTT",
        "function": null,
        "line": 381,
        "line_end": 381,
        "name": "Overflow bugs",
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "contract": "TMC_Contract",
        "function": null,
        "line": 112,
        "line_end": 112,
        "name": "Overflow bugs",
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "contract": "DescendingPriceERC20Auction",
        "function": null,
        "line": 251,
        "line_end": 251,
        "name": "Concurrency bug",
        "code_segment": "contract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "contract": "DescendingPriceERC20Auction",
        "function": null,
        "line": 253,
        "line_end": 253,
        "name": "Concurrency bug",
        "code_segment": "contract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "contract": "DescendingPriceCryptoKittyAuction",
        "function": null,
        "line": 342,
        "line_end": 342,
        "name": "Concurrency bug",
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "contract": "DescendingPriceCryptoKittyAuction",
        "function": null,
        "line": 344,
        "line_end": 344,
        "name": "Concurrency bug",
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-The_LAO/moloch-4bc443f4dad60279b47978fc6987bb978d3dfc58/contracts/Moloch.sol",
        "contract": "Moloch",
        "function": null,
        "line": 246,
        "line_end": 246,
        "name": "Truncation bugs",
        "code_segment": "contract Moloch is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    /***************\n    GLOBAL CONSTANTS\n    ***************/\n    address public summoner; // initial singular shareholder, assists with bailouts\n\n    uint256 public periodDuration; // default = 17280 = 4.8 hours in seconds (5 periods per day)\n    uint256 public votingPeriodLength; // default = 35 periods (7 days)\n    uint256 public gracePeriodLength; // default = 35 periods (7 days)\n    uint256 public emergencyProcessingWait; // default = 35 periods (7 days)\n    uint256 public bailoutWait; // default = 70 periods (14 days)\n    uint256 public proposalDeposit; // default = 10 ETH (~$1,000 worth of ETH at contract deployment)\n    uint256 public dilutionBound; // default = 3 - maximum multiplier a YES voter will be obligated to pay in case of mass ragequit\n    uint256 public processingReward; // default = 0.1 - amount of ETH to give to whoever processes a proposal\n    uint256 public summoningTime; // needed to determine the current period\n\n    IERC20 public depositToken; // deposit token contract reference; default = wETH\n    GuildBank public guildBank; // guild bank contract reference\n\n    // HARD-CODED LIMITS\n    // These numbers are quite arbitrary; they are small enough to avoid overflows when doing calculations\n    // with periods or shares, yet big enough to not limit reasonable use cases.\n    uint256 constant MAX_VOTING_PERIOD_LENGTH = 10**18; // maximum length of voting period\n    uint256 constant MAX_GRACE_PERIOD_LENGTH = 10**18; // maximum length of grace period\n    uint256 constant MAX_BAILOUT_WAIT = 10**18; // maximum # periods after a jailed member can be ragekicked before they must be bailed out instead\n    uint256 constant MAX_DILUTION_BOUND = 10**18; // maximum dilution bound\n    uint256 constant MAX_NUMBER_OF_SHARES_AND_LOOT = 10**18; // maximum number of shares that can be minted\n\n    // ***************\n    // EVENTS\n    // ***************\n    event SubmitProposal(uint256 proposalIndex, address indexed delegateKey, address indexed memberAddress, address indexed applicant, uint256 sharesRequested, uint256 lootRequested, uint256 tributeOffered, address tributeToken, uint256 paymentRequested, address paymentToken);\n    event SponsorProposal(address indexed delegateKey, address indexed memberAddress, uint256 proposalIndex, uint256 proposalQueueIndex, uint256 startingPeriod);\n    event SubmitVote(uint256 indexed proposalIndex, address indexed delegateKey, address indexed memberAddress, uint8 uintVote);\n    event ProcessProposal(uint256 indexed proposalIndex, uint256 indexed proposalId, bool didPass);\n    event Ragequit(address indexed memberAddress, uint256 sharesToBurn, uint256 lootToBurn);\n    event CancelProposal(uint256 indexed proposalIndex, address applicantAddress);\n    event UpdateDelegateKey(address indexed memberAddress, address newDelegateKey);\n    event SummonComplete(address indexed summoner, uint256 shares);\n\n    // *******************\n    // INTERNAL ACCOUNTING\n    // *******************\n    uint256 public proposalCount = 0; // total proposals submitted\n    uint256 public totalShares = 0; // total shares across all members\n    uint256 public totalLoot = 0; // total loot across all members\n\n    bool public emergencyWarning = false; // true if emergency processing has ever been triggered\n    uint256 public lastEmergencyProposalIndex = 0; // index of the last proposal which triggered emergency processing\n\n    enum Vote {\n        Null, // default value, counted as abstention\n        Yes,\n        No\n    }\n\n    struct Member {\n        address delegateKey; // the key responsible for submitting proposals and voting - defaults to member address unless updated\n        uint256 shares; // the # of voting shares assigned to this member\n        uint256 loot; // the loot amount available to this member (combined with shares on ragequit)\n        bool exists; // always true once a member has been created\n        uint256 highestIndexYesVote; // highest proposal index # on which the member voted YES\n        uint256 jailed; // set to proposalIndex of a passing guild kick proposal for this member, prevents voting on and sponsoring proposals\n    }\n\n    struct Proposal {\n        address applicant; // the applicant who wishes to become a member - this key will be used for withdrawals (doubles as guild kick target for gkick proposals)\n        address proposer; // the account that submitted the proposal (can be non-member)\n        address sponsor; // the member that sponsored the proposal (moving it into the queue)\n        uint256 sharesRequested; // the # of shares the applicant is requesting\n        uint256 lootRequested; // the amount of loot the applicant is requesting\n        uint256 tributeOffered; // amount of tokens offered as tribute\n        IERC20 tributeToken; // tribute token contract reference\n        uint256 paymentRequested; // amount of tokens requested as payment\n        IERC20 paymentToken; // payment token contract reference\n        uint256 startingPeriod; // the period in which voting can start for this proposal\n        uint256 yesVotes; // the total number of YES votes for this proposal\n        uint256 noVotes; // the total number of NO votes for this proposal\n        bool[6] flags; // [sponsored, processed, didPass, cancelled, whitelist, guildkick]\n        string details; // proposal details - could be IPFS hash, plaintext, or JSON\n        uint256 maxTotalSharesAndLootAtYesVote; // the maximum # of total shares encountered at a yes vote on this proposal\n        mapping(address => Vote) votesByMember; // the votes on this proposal by each member\n    }\n\n    mapping(address => bool) public tokenWhitelist;\n    IERC20[] public approvedTokens;\n\n    mapping(address => bool) public proposedToWhitelist;\n    mapping(address => bool) public proposedToKick;\n\n    mapping(address => Member) public members;\n    mapping(address => address) public memberAddressByDelegateKey;\n\n    mapping(uint256 => Proposal) public proposals;\n\n    uint256[] public proposalQueue;\n\n    modifier onlyMember {\n        require(members[msg.sender].shares > 0 || members[msg.sender].loot > 0, \"not a member\");\n        _;\n    }\n\n    modifier onlyShareholder {\n        require(members[msg.sender].shares > 0, \"not a shareholder\");\n        _;\n    }\n\n    modifier onlyDelegate {\n        require(members[memberAddressByDelegateKey[msg.sender]].shares > 0, \"not a delegate\");\n        _;\n    }\n\n    constructor(\n        address _summoner,\n        address[] memory _approvedTokens,\n        uint256 _periodDuration,\n        uint256 _votingPeriodLength,\n        uint256 _gracePeriodLength,\n        uint256 _emergencyProcessingWait,\n        uint256 _bailoutWait,\n        uint256 _proposalDeposit,\n        uint256 _dilutionBound,\n        uint256 _processingReward\n    ) public {\n        require(_summoner != address(0), \"summoner cannot be 0\");\n        require(_periodDuration > 0, \"_periodDuration cannot be 0\");\n        require(_votingPeriodLength > 0, \"_votingPeriodLength cannot be 0\");\n        require(_votingPeriodLength <= MAX_VOTING_PERIOD_LENGTH, \"_votingPeriodLength exceeds limit\");\n        require(_gracePeriodLength <= MAX_GRACE_PERIOD_LENGTH, \"_gracePeriodLength exceeds limit\");\n        require(_emergencyProcessingWait > 0, \"_emergencyProcessingWait cannot be 0\");\n        require(_bailoutWait > _emergencyProcessingWait, \"_bailoutWait must be greater than _emergencyProcessingWait\");\n        require(_bailoutWait <= MAX_BAILOUT_WAIT, \"_bailoutWait exceeds limit\");\n        require(_dilutionBound > 0, \"_dilutionBound cannot be 0\");\n        require(_dilutionBound <= MAX_DILUTION_BOUND, \"_dilutionBound exceeds limit\");\n        require(_approvedTokens.length > 0, \"need at least one approved token\");\n        require(_proposalDeposit >= _processingReward, \"_proposalDeposit cannot be smaller than _processingReward\");\n\n        summoner = _summoner;\n\n        depositToken = IERC20(_approvedTokens[0]);\n\n        for (uint256 i = 0; i < _approvedTokens.length; i++) {\n            require(_approvedTokens[i] != address(0), \"_approvedToken cannot be 0\");\n            require(!tokenWhitelist[_approvedTokens[i]], \"duplicate approved token\");\n            tokenWhitelist[_approvedTokens[i]] = true;\n            approvedTokens.push(IERC20(_approvedTokens[i]));\n        }\n\n        guildBank = new GuildBank();\n\n        periodDuration = _periodDuration;\n        votingPeriodLength = _votingPeriodLength;\n        gracePeriodLength = _gracePeriodLength;\n        emergencyProcessingWait = _emergencyProcessingWait;\n        bailoutWait = _bailoutWait;\n        proposalDeposit = _proposalDeposit;\n        dilutionBound = _dilutionBound;\n        processingReward = _processingReward;\n\n        summoningTime = now;\n\n        members[summoner] = Member(summoner, 1, 0, true, 0, 0);\n        memberAddressByDelegateKey[summoner] = summoner;\n        totalShares = 1;\n\n        emit SummonComplete(summoner, 1);\n    }\n\n    /*****************\n    PROPOSAL FUNCTIONS\n    *****************/\n    function submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string memory details\n    ) public nonReentrant returns (uint256 proposalId) {\n        require(sharesRequested.add(lootRequested) <= MAX_NUMBER_OF_SHARES_AND_LOOT, \"too many shares requested\");\n        require(tokenWhitelist[tributeToken], \"tributeToken is not whitelisted\");\n        require(tokenWhitelist[paymentToken], \"payment is not whitelisted\");\n        require(applicant != address(0), \"applicant cannot be 0\");\n        require(members[applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n        // collect tribute from applicant and store it in the Moloch until the proposal is processed\n        require(IERC20(tributeToken).transferFrom(msg.sender, address(this), tributeOffered), \"tribute token transfer failed\");\n\n        bool[6] memory flags;\n\n        _submitProposal(applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken, details, flags);\n        return proposalCount - 1; // return proposalId - contracts calling submit might want it\n    }\n\n    function submitWhitelistProposal(address tokenToWhitelist, string memory details) public nonReentrant returns (uint256 proposalId) {\n        require(tokenToWhitelist != address(0), \"must provide token address\");\n        require(!tokenWhitelist[tokenToWhitelist], \"cannot already have whitelisted the token\");\n\n        bool[6] memory flags;\n        flags[4] = true;\n\n        _submitProposal(address(0), 0, 0, 0, tokenToWhitelist, 0, address(0), details, flags);\n        return proposalCount - 1;\n    }\n\n    function submitGuildKickProposal(address memberToKick, string memory details) public nonReentrant returns (uint256 proposalId) {\n        Member memory member = members[memberToKick];\n\n        require(member.shares > 0 || member.loot > 0, \"member must have at least one share or one loot\");\n        require(memberToKick != summoner, \"the summoner may not be kicked\");\n        require(members[memberToKick].jailed == 0, \"member must not already be jailed\");\n\n        bool[6] memory flags;\n        flags[5] = true;\n\n        _submitProposal(memberToKick, 0, 0, 0, address(0), 0, address(0), details, flags);\n        return proposalCount - 1;\n    }\n\n    function _submitProposal(\n        address applicant,\n        uint256 sharesRequested,\n        uint256 lootRequested,\n        uint256 tributeOffered,\n        address tributeToken,\n        uint256 paymentRequested,\n        address paymentToken,\n        string memory details,\n        bool[6] memory flags\n    ) internal {\n        Proposal memory proposal = Proposal({\n            applicant : applicant,\n            proposer : msg.sender,\n            sponsor : address(0),\n            sharesRequested : sharesRequested,\n            lootRequested : lootRequested,\n            tributeOffered : tributeOffered,\n            tributeToken : IERC20(tributeToken),\n            paymentRequested : paymentRequested,\n            paymentToken : IERC20(paymentToken),\n            startingPeriod : 0,\n            yesVotes : 0,\n            noVotes : 0,\n            flags : flags,\n            details : details,\n            maxTotalSharesAndLootAtYesVote : 0\n        });\n\n        proposals[proposalCount] = proposal;\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        emit SubmitProposal(proposalCount, msg.sender, memberAddress, applicant, sharesRequested, lootRequested, tributeOffered, tributeToken, paymentRequested, paymentToken);\n        proposalCount += 1;\n    }\n    // SWC-114-Transaction Order Dependence: L266-305\n    function sponsorProposal(uint256 proposalId) public nonReentrant onlyDelegate {\n        // collect proposal deposit from sponsor and store it in the Moloch until the proposal is processed\n        require(depositToken.transferFrom(msg.sender, address(this), proposalDeposit), \"proposal deposit token transfer failed\");\n\n        Proposal storage proposal = proposals[proposalId];\n\n        require(proposal.proposer != address(0), 'proposal must have been proposed');\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\n        require(!proposal.flags[3], \"proposal has been cancelled\");\n        require(members[proposal.applicant].jailed == 0, \"proposal applicant must not be jailed\");\n\n        // whitelist proposal\n        if (proposal.flags[4]) {\n            require(!tokenWhitelist[address(proposal.tributeToken)], \"cannot already have whitelisted the token\");\n            require(!proposedToWhitelist[address(proposal.tributeToken)], 'already proposed to whitelist');\n            proposedToWhitelist[address(proposal.tributeToken)] = true;\n\n        // guild kick proposal\n        } else if (proposal.flags[5]) {\n            require(!proposedToKick[proposal.applicant], 'already proposed to kick');\n            proposedToKick[proposal.applicant] = true;\n        }\n\n        // compute startingPeriod for proposal\n        uint256 startingPeriod = max(\n            getCurrentPeriod(),\n            proposalQueue.length == 0 ? 0 : proposals[proposalQueue[proposalQueue.length.sub(1)]].startingPeriod\n        ).add(1);\n\n        proposal.startingPeriod = startingPeriod;\n\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        proposal.sponsor = memberAddress;\n\n        proposal.flags[0] = true;\n\n        // append proposal to the queue\n        proposalQueue.push(proposalId);\n        emit SponsorProposal(msg.sender, memberAddress, proposalId, proposalQueue.length.sub(1), startingPeriod);\n    }\n\n    function submitVote(uint256 proposalIndex, uint8 uintVote) public nonReentrant onlyDelegate {\n        address memberAddress = memberAddressByDelegateKey[msg.sender];\n        Member storage member = members[memberAddress];\n\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\n        Proposal storage proposal = proposals[proposalQueue[proposalIndex]];\n\n        require(uintVote < 3, \"must be less than 3\");\n        Vote vote = Vote(uintVote);\n\n        require(getCurrentPeriod() >= proposal.startingPeriod, \"voting period has not started\");\n        require(!hasVotingPeriodExpired(proposal.startingPeriod), \"proposal voting period has expired\");\n        require(proposal.votesByMember[memberAddress] == Vote.Null, \"member has already voted\");\n        require(vote == Vote.Yes || vote == Vote.No, \"vote must be either Yes or No\");\n\n        proposal.votesByMember[memberAddress] = vote;\n\n        if (vote == Vote.Yes) {\n            proposal.yesVotes = proposal.yesVotes.add(member.shares);\n\n            // set highest index (latest) yes vote - must be processed for member to ragequit\n            if (proposalIndex > member.highestIndexYesVote) {\n                member.highestIndexYesVote = proposalIndex;\n            }\n\n            // set maximum of total shares encountered at a yes vote - used to bound dilution for yes voters\n            if (totalShares.add(totalLoot) > proposal.maxTotalSharesAndLootAtYesVote) {\n                proposal.maxTotalSharesAndLootAtYesVote = totalShares.add(totalLoot);\n            }\n\n        } else if (vote == Vote.No) {\n            proposal.noVotes = proposal.noVotes.add(member.shares);\n        }\n\n        emit SubmitVote(proposalIndex, msg.sender, memberAddress, uintVote);\n    }\n\n    function processProposal(uint256 proposalIndex) public nonReentrant {\n        _validateProposalForProcessing(proposalIndex);\n\n        uint256 proposalId = proposalQueue[proposalIndex];\n        Proposal storage proposal = proposals[proposalId];\n\n        require(!proposal.flags[4] && !proposal.flags[5], \"must be a standard proposal\");\n\n        proposal.flags[1] = true; // processed\n\n        (bool didPass, bool emergencyProcessing) = _didPass(proposalIndex);\n\n        // Make the proposal fail if the new total number of shares and loot exceeds the limit\n        if (totalShares.add(totalLoot).add(proposal.sharesRequested).add(proposal.lootRequested) > MAX_NUMBER_OF_SHARES_AND_LOOT) {\n            didPass = false;\n        }\n\n        // Make the proposal fail if it is requesting more tokens as payment than the available guild bank balance\n        if (!emergencyProcessing && proposal.paymentToken != IERC20(0) && proposal.paymentRequested > proposal.paymentToken.balanceOf(address(guildBank))) {\n            didPass = false;\n        }\n\n        // PROPOSAL PASSED\n        if (didPass) {\n            proposal.flags[2] = true; // didPass\n\n            // if the applicant is already a member, add to their existing shares & loot\n            if (members[proposal.applicant].exists) {\n                members[proposal.applicant].shares = members[proposal.applicant].shares.add(proposal.sharesRequested);\n                members[proposal.applicant].loot = members[proposal.applicant].loot.add(proposal.lootRequested);\n\n            // the applicant is a new member, create a new record for them\n            } else {\n                // if the applicant address is already taken by a member's delegateKey, reset it to their member address\n                if (members[memberAddressByDelegateKey[proposal.applicant]].exists) {\n                    address memberToOverride = memberAddressByDelegateKey[proposal.applicant];\n                    memberAddressByDelegateKey[memberToOverride] = memberToOverride;\n                    members[memberToOverride].delegateKey = memberToOverride;\n                }\n\n                // use applicant address as delegateKey by default\n                members[proposal.applicant] = Member(proposal.applicant, proposal.sharesRequested, proposal.lootRequested, true, 0, 0);\n                memberAddressByDelegateKey[proposal.applicant] = proposal.applicant;\n            }\n\n            // mint new shares & loot\n            totalShares = totalShares.add(proposal.sharesRequested);\n            totalLoot = totalLoot.add(proposal.lootRequested);\n\n            require(\n                proposal.tributeToken.transfer(address(guildBank), proposal.tributeOffered),\n                \"token transfer to guild bank failed\"\n            );\n\n            require(\n                guildBank.withdrawToken(proposal.paymentToken, proposal.applicant, proposal.paymentRequested),\n                \"token payment to applicant failed\"\n            );\n\n\n        // PROPOSAL FAILED\n        } else {\n            // return all tokens to the applicant (skip if emergency processing)v\n            // SWC-105-Unprotected Ether Withdrawal: L408-413\n            if (!emergencyProcessing) {\n                require(\n                    proposal.tributeToken.transfer(proposal.proposer, proposal.tributeOffered),\n                    \"failing vote token transfer failed\"\n                );\n            }\n        }\n\n        _returnDeposit(proposal.sponsor);\n\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\n    }\n\n    function processWhitelistProposal(uint256 proposalIndex) public nonReentrant {\n        _validateProposalForProcessing(proposalIndex);\n\n        uint256 proposalId = proposalQueue[proposalIndex];\n        Proposal storage proposal = proposals[proposalId];\n\n        require(proposal.flags[4], \"must be a whitelist proposal\");\n\n        proposal.flags[1] = true; // processed\n\n        (bool didPass,) = _didPass(proposalIndex);\n\n        if (didPass) {\n            proposal.flags[2] = true; // didPass\n\n            tokenWhitelist[address(proposal.tributeToken)] = true;\n            approvedTokens.push(proposal.tributeToken);\n        }\n\n        proposedToWhitelist[address(proposal.tributeToken)] = false;\n\n        _returnDeposit(proposal.sponsor);\n\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\n    }\n\n    function processGuildKickProposal(uint256 proposalIndex) public nonReentrant {\n        _validateProposalForProcessing(proposalIndex);\n\n        uint256 proposalId = proposalQueue[proposalIndex];\n        Proposal storage proposal = proposals[proposalId];\n\n        require(proposal.flags[5], \"must be a guild kick proposal\");\n\n        proposal.flags[1] = true; // processed\n\n        (bool didPass,) = _didPass(proposalIndex);\n\n        if (didPass) {\n            proposal.flags[2] = true; // didPass\n            Member storage member = members[proposal.applicant];\n            member.jailed = proposalIndex;\n\n            // transfer shares to loot\n            member.loot = member.loot.add(member.shares);\n            totalShares = totalShares.sub(member.shares);\n            totalLoot = totalLoot.add(member.shares);\n            member.shares = 0; // revoke all shares\n        }\n\n        proposedToKick[proposal.applicant] = false;\n\n        _returnDeposit(proposal.sponsor);\n\n        emit ProcessProposal(proposalIndex, proposalId, didPass);\n    }\n\n    function _didPass(uint256 proposalIndex) internal returns (bool didPass, bool emergencyProcessing) {\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\n\n        didPass = proposal.yesVotes > proposal.noVotes;\n\n        // Make the proposal fail (and skip returning tribute) if emergencyProcessingWait is exceeded\n        emergencyProcessing = false;\n        if (getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength).add(emergencyProcessingWait)) {\n            emergencyWarning = true;\n            lastEmergencyProposalIndex = proposalIndex;\n            emergencyProcessing = true;\n            didPass = false;\n        }\n\n        // Make the proposal fail if it was in the grace period during the last emergency processing\n        if (emergencyWarning) {\n            if (proposal.startingPeriod < proposals[proposalQueue[lastEmergencyProposalIndex]].startingPeriod.add(emergencyProcessingWait)) {\n                didPass = false;\n            }\n        }\n\n        // Make the proposal fail if the dilutionBound is exceeded\n        if ((totalShares.add(totalLoot)).mul(dilutionBound) < proposal.maxTotalSharesAndLootAtYesVote) {\n            didPass = false;\n        }\n\n        // Make the proposal fail if the applicant is jailed\n        // - for standard proposals, we don't want the applicant to get any shares/loot/payment\n        // - for guild kick proposals, we should never be able to propose to kick a jailed member (or have two kick proposals active), so it doesn't matter\n        if (members[proposal.applicant].jailed != 0) {\n            didPass = false;\n        }\n\n        return (didPass, emergencyProcessing);\n    }\n\n    function _validateProposalForProcessing(uint256 proposalIndex) internal view {\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\n        Proposal memory proposal = proposals[proposalQueue[proposalIndex]];\n\n        require(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength), \"proposal is not ready to be processed\");\n        require(proposal.flags[1] == false, \"proposal has already been processed\");\n        require(proposalIndex == 0 || proposals[proposalQueue[proposalIndex.sub(1)]].flags[1], \"previous proposal must be processed\");\n    }\n\n    function _returnDeposit(address sponsor) internal {\n        require(\n            depositToken.transfer(msg.sender, processingReward),\n            \"failed to send processing reward to msg.sender\"\n        );\n\n        require(\n            depositToken.transfer(sponsor, proposalDeposit.sub(processingReward)),\n            \"failed to return proposal deposit to sponsor\"\n        );\n    }\n\n    function ragequit(uint256 sharesToBurn, uint256 lootToBurn) public nonReentrant onlyMember {\n        _ragequit(msg.sender, sharesToBurn, lootToBurn, approvedTokens);\n    }\n\n    function safeRagequit(uint256 sharesToBurn, uint256 lootToBurn, IERC20[] memory tokenList) public nonReentrant onlyMember {\n        // all tokens in tokenList must be in the tokenWhitelist\n        for (uint256 i=0; i < tokenList.length; i++) {\n            require(tokenWhitelist[address(tokenList[i])], \"token must be whitelisted\");\n\n            if (i > 0) {\n                require(tokenList[i] > tokenList[i - 1], \"token list must be unique and in ascending order\");\n            }\n        }\n\n        _ragequit(msg.sender, sharesToBurn, lootToBurn, tokenList);\n    }\n\n    function _ragequit(address memberAddress, uint256 sharesToBurn, uint256 lootToBurn, IERC20[] memory tokenList) internal {\n        uint256 initialTotalSharesAndLoot = totalShares.add(totalLoot);\n\n        Member storage member = members[memberAddress];\n\n        require(member.shares >= sharesToBurn, \"insufficient shares\");\n        require(member.loot >= lootToBurn, \"insufficient loot\");\n\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\n\n        uint256 sharesAndLootToBurn = sharesToBurn.add(lootToBurn);\n\n        // burn shares and loot\n        member.shares = member.shares.sub(sharesToBurn);\n        member.loot = member.loot.sub(lootToBurn);\n        totalShares = totalShares.sub(sharesToBurn);\n        totalLoot = totalLoot.sub(lootToBurn);\n\n        // instruct guildBank to transfer fair share of tokens to the ragequitter\n        require(\n            guildBank.withdraw(memberAddress, sharesAndLootToBurn, initialTotalSharesAndLoot, tokenList),\n            \"withdrawal of tokens from guildBank failed\"\n        );\n\n        emit Ragequit(msg.sender, sharesToBurn, lootToBurn);\n    }\n\n    function ragekick(address memberToKick) public nonReentrant {\n        Member storage member = members[memberToKick];\n\n        require(member.jailed != 0, \"member must be in jail\");\n        require(member.loot > 0, \"member must have some loot\"); // note - should be impossible for jailed member to have shares\n        require(canRagequit(member.highestIndexYesVote), \"cannot ragequit until highest index proposal member voted YES on is processed\");\n        require(!canBailout(memberToKick), \"bailoutWait has passed, member must be bailed out\");\n\n        _ragequit(memberToKick, 0, member.loot, approvedTokens);\n    }\n\n    function bailout(address memberToBail) public nonReentrant {\n        Member storage member = members[memberToBail];\n\n        require(member.jailed != 0, \"member must be in jail\");\n        require(member.loot > 0, \"member must have some loot\"); // note - should be impossible for jailed member to have shares\n        require(canBailout(memberToBail), \"cannot bailout yet\");\n\n        members[summoner].loot = members[summoner].loot.add(member.loot);\n        member.loot = 0;\n    }\n\n    function cancelProposal(uint256 proposalId) public nonReentrant {\n        Proposal storage proposal = proposals[proposalId];\n        require(!proposal.flags[0], \"proposal has already been sponsored\");\n        require(!proposal.flags[3], \"proposal has already been cancelled\");\n        require(msg.sender == proposal.proposer, \"solely the proposer can cancel\");\n\n        proposal.flags[3] = true; // cancelled\n\n        require(\n            proposal.tributeToken.transfer(proposal.proposer, proposal.tributeOffered),\n            \"failed to return tribute to proposer\"\n        );\n\n        emit CancelProposal(proposalId, msg.sender);\n    }\n\n    function updateDelegateKey(address newDelegateKey) public nonReentrant onlyShareholder {\n        require(newDelegateKey != address(0), \"newDelegateKey cannot be 0\");\n\n        // skip checks if member is setting the delegate key to their member address\n        if (newDelegateKey != msg.sender) {\n            require(!members[newDelegateKey].exists, \"cannot overwrite existing members\");\n            require(!members[memberAddressByDelegateKey[newDelegateKey]].exists, \"cannot overwrite existing delegate keys\");\n        }\n\n        Member storage member = members[msg.sender];\n        memberAddressByDelegateKey[member.delegateKey] = address(0);\n        memberAddressByDelegateKey[newDelegateKey] = msg.sender;\n        member.delegateKey = newDelegateKey;\n\n        emit UpdateDelegateKey(msg.sender, newDelegateKey);\n    }\n\n    /***************\n    GETTER FUNCTIONS\n    ***************/\n    // SWC-101-Integer Overflow and Underflow: L638-640\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x >= y ? x : y;\n    }\n\n    function getCurrentPeriod() public view returns (uint256) {\n        return now.sub(summoningTime).div(periodDuration);\n    }\n\n    function getProposalQueueLength() public view returns (uint256) {\n        return proposalQueue.length;\n    }\n\n    function getProposalFlags(uint256 proposalId) public view returns (bool[6] memory) {\n        return proposals[proposalId].flags;\n    }\n\n    // can only ragequit if the latest proposal you voted YES on has been processed\n    function canRagequit(uint256 highestIndexYesVote) public view returns (bool) {\n        require(highestIndexYesVote < proposalQueue.length, \"proposal does not exist\");\n        return proposals[proposalQueue[highestIndexYesVote]].flags[1];\n    }\n\n    function canBailout(address memberToBail) public view returns (bool) {\n        Member memory member = members[memberToBail];\n\n        // get the starting period of the proposal to start the bailout wait from\n        // - either the guild kick proposal or the member's highest index yes vote\n        uint256 bailoutWaitStartingPeriod = member.highestIndexYesVote > member.jailed\n            ? proposals[proposalQueue[member.highestIndexYesVote]].startingPeriod\n            : proposals[proposalQueue[member.jailed]].startingPeriod;\n\n        // bailout wait starts after proposal grace period ends\n        return getCurrentPeriod() >= bailoutWaitStartingPeriod.add(votingPeriodLength).add(gracePeriodLength).add(bailoutWait);\n    }\n\n    function hasVotingPeriodExpired(uint256 startingPeriod) public view returns (bool) {\n        return getCurrentPeriod() >= startingPeriod.add(votingPeriodLength);\n    }\n\n    function getMemberProposalVote(address memberAddress, uint256 proposalIndex) public view returns (Vote) {\n        require(members[memberAddress].exists, \"member does not exist\");\n        require(proposalIndex < proposalQueue.length, \"proposal does not exist\");\n        return proposals[proposalQueue[proposalIndex]].votesByMember[memberAddress];\n    }\n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "contract": "LockedTokens",
        "function": null,
        "line": 1,
        "line_end": 1,
        "name": "Overflow bugs",
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 312,
        "line_end": 312,
        "name": "Overflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 313,
        "line_end": 313,
        "name": "Overflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 328,
        "line_end": 328,
        "name": "Underflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 319,
        "line_end": 319,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 320,
        "line_end": 320,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 378,
        "line_end": 378,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 392,
        "line_end": 392,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 335,
        "line_end": 335,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 392,
        "line_end": 392,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 319,
        "line_end": 319,
        "name": "Overflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 320,
        "line_end": 320,
        "name": "Overflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 335,
        "line_end": 335,
        "name": "Underflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 194,
        "line_end": 194,
        "name": "Concurrency bug",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 83,
        "line_end": 83,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 114,
        "line_end": 114,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 188,
        "line_end": 188,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 113,
        "line_end": 113,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 153,
        "line_end": 153,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 209,
        "line_end": 209,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "contract": "GNTDeposit",
        "function": null,
        "line": 113,
        "line_end": 113,
        "name": "Overflow bugs",
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "contract": "GNTDeposit",
        "function": null,
        "line": 123,
        "line_end": 123,
        "name": "Overflow bugs",
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GNTPaymentChannels",
        "function": null,
        "line": 505,
        "line_end": 505,
        "name": "Overflow bugs",
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GNTPaymentChannels",
        "function": null,
        "line": 560,
        "line_end": 560,
        "name": "Overflow bugs",
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GNTPaymentChannels",
        "function": null,
        "line": 549,
        "line_end": 549,
        "name": "Underflow bugs",
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 319,
        "line_end": 319,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 320,
        "line_end": 320,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 378,
        "line_end": 378,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 392,
        "line_end": 392,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 335,
        "line_end": 335,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "GolemNetworkTokenBatching",
        "function": null,
        "line": 392,
        "line_end": 392,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 319,
        "line_end": 319,
        "name": "Overflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 320,
        "line_end": 320,
        "name": "Overflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "contract": "TokenProxy",
        "function": null,
        "line": 335,
        "line_end": 335,
        "name": "Underflow bugs",
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 194,
        "line_end": 194,
        "name": "Concurrency bug",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 83,
        "line_end": 83,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 114,
        "line_end": 114,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 188,
        "line_end": 188,
        "name": "Overflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 113,
        "line_end": 113,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 153,
        "line_end": 153,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "contract": "GolemNetworkToken",
        "function": null,
        "line": 209,
        "line_end": 209,
        "name": "Underflow bugs",
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 350,
        "line_end": 350,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 350,
        "line_end": 350,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 353,
        "line_end": 353,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 353,
        "line_end": 353,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 356,
        "line_end": 356,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 356,
        "line_end": 356,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 359,
        "line_end": 359,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 359,
        "line_end": 359,
        "name": "Overflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "contract": "PolyDistribution",
        "function": null,
        "line": 418,
        "line_end": 418,
        "name": "Underflow bugs",
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 433,
        "line_end": 433,
        "name": "Concurrency bug",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 504,
        "line_end": 504,
        "name": "Concurrency bug",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 232,
        "line_end": 232,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 232,
        "line_end": 232,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 302,
        "line_end": 302,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 383,
        "line_end": 383,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 383,
        "line_end": 383,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 415,
        "line_end": 415,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 419,
        "line_end": 419,
        "name": "Overflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 232,
        "line_end": 232,
        "name": "Truncation bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 302,
        "line_end": 302,
        "name": "Truncation bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 383,
        "line_end": 383,
        "name": "Truncation bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 417,
        "line_end": 417,
        "name": "Truncation bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 315,
        "line_end": 315,
        "name": "Underflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 345,
        "line_end": 345,
        "name": "Underflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 424,
        "line_end": 424,
        "name": "Underflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 425,
        "line_end": 425,
        "name": "Underflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "contract": "ROSCA",
        "function": null,
        "line": 432,
        "line_end": 432,
        "name": "Underflow bugs",
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "contract": "FLUX",
        "function": null,
        "line": 115,
        "line_end": 115,
        "name": "Overflow bugs",
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "contract": "StandardMintableToken",
        "function": null,
        "line": 157,
        "line_end": 157,
        "name": "Overflow bugs",
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "check": "TP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "contract": "StandardMintableToken",
        "function": null,
        "line": 134,
        "line_end": 134,
        "name": "Underflow bugs",
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "contract": "StandardMintableToken",
        "function": null,
        "line": 146,
        "line_end": 146,
        "name": "Underflow bugs",
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "contract": "CHAINSQUARE",
        "function": null,
        "line": 115,
        "line_end": 115,
        "name": "Overflow bugs",
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "contract": "TokenERC20",
        "function": null,
        "line": 58,
        "line_end": 58,
        "name": "Overflow bugs",
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "contract": "TokenERC20",
        "function": null,
        "line": 65,
        "line_end": 65,
        "name": "Overflow bugs",
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "contract": "TokenERC20",
        "function": null,
        "line": 165,
        "line_end": 165,
        "name": "Underflow bugs",
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "contract": "TokenERC20",
        "function": null,
        "line": 184,
        "line_end": 184,
        "name": "Underflow bugs",
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "contract": "ProPoolLib",
        "function": null,
        "line": 1436,
        "line_end": 1436,
        "name": "Concurrency bug",
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "contract": "ProPoolLib",
        "function": null,
        "line": 1532,
        "line_end": 1532,
        "name": "Overflow bugs",
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "contract": "ProPoolLib",
        "function": null,
        "line": 670,
        "line_end": 670,
        "name": "Underflow bugs",
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "contract": "ProPoolLib",
        "function": null,
        "line": 673,
        "line_end": 673,
        "name": "Underflow bugs",
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "contract": "ProPoolLib",
        "function": null,
        "line": 681,
        "line_end": 681,
        "name": "Underflow bugs",
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 41,
        "line_end": 41,
        "name": "Division bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 40,
        "line_end": 40,
        "name": "Overflow bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 642,
        "line_end": 642,
        "name": "Concurrency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 661,
        "line_end": 661,
        "name": "Concurrency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 615,
        "line_end": 615,
        "name": "Overflow bugs",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 651,
        "line_end": 651,
        "name": "Time dependency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 651,
        "line_end": 651,
        "name": "Time dependency bug",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/EvenDistroCrowdsaleLib.sol",
        "contract": "CrowdsaleLib",
        "function": null,
        "line": 729,
        "line_end": 729,
        "name": "Underflow bugs",
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 41,
        "line_end": 41,
        "name": "Division bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "contract": "BasicMathLib",
        "function": null,
        "line": 40,
        "line_end": 40,
        "name": "Overflow bugs",
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "contract": "TokenLib",
        "function": null,
        "line": 176,
        "line_end": 176,
        "name": "Overflow bugs",
        "code_segment": "library TokenLib {\n  using BasicMathLib for uint256;\n\n  struct TokenStorage {\n    bool initialized;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    uint256 initialSupply;\n    address owner;\n    uint8 decimals;\n    bool stillMinting;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event OwnerChange(address from, address to);\n  event Burn(address indexed burner, uint256 value);\n  event MintingClosed(bool mintingClosed);\n\n  \n  \n  \n  \n  \n  \n  \n  function init(TokenStorage storage self,\n                address _owner,\n                string _name,\n                string _symbol,\n                uint8 _decimals,\n                uint256 _initial_supply,\n                bool _allowMinting)\n                public\n  {\n    require(!self.initialized);\n    self.initialized = true;\n    self.name = _name;\n    self.symbol = _symbol;\n    self.totalSupply = _initial_supply;\n    self.initialSupply = _initial_supply;\n    self.decimals = _decimals;\n    self.owner = _owner;\n    self.stillMinting = _allowMinting;\n    self.balances[_owner] = _initial_supply;\n  }\n\n  \n  \n  \n  \n  \n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    bool err;\n    uint256 balance;\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n    require(!err);\n    self.balances[msg.sender] = balance;\n    //It's not possible to overflow token supply\n    self.balances[_to] = self.balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  \n  function transferFrom(TokenStorage storage self,\n                        address _from,\n                        address _to,\n                        uint256 _value)\n                        public\n                        returns (bool)\n  {\n    var _allowance = self.allowed[_from][msg.sender];\n    bool err;\n    uint256 balanceOwner;\n    uint256 balanceSpender;\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n    require(!err);\n\n    (err,balanceSpender) = _allowance.minus(_value);\n    require(!err);\n\n    self.balances[_from] = balanceOwner;\n    self.allowed[_from][msg.sender] = balanceSpender;\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n    return self.balances[_owner];\n  }\n\n  \n  \n  \n  \n  \n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n    // must set to zero before changing approval amount in accordance with spec\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n    self.allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  function allowance(TokenStorage storage self, address _owner, address _spender)\n                     public\n                     view\n                     returns (uint256 remaining) {\n    return self.allowed[_owner][_spender];\n  }\n\n  \n  \n  \n  \n  \n  \n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n                          public returns (bool)\n  {\n    uint256 _newAllowed;\n    bool err;\n\n    if(_increase) {\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n      require(!err);\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n    } else {\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n        self.allowed[msg.sender][_spender] = 0;\n      } else {\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n        self.allowed[msg.sender][_spender] = _newAllowed;\n      }\n    }\n\n    Approval(msg.sender, _spender, _newAllowed);\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n    self.owner = _newOwner;\n    OwnerChange(msg.sender, _newOwner);\n    return true;\n  }\n\n  \n  \n  \n  \n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n    require((self.owner == msg.sender) && self.stillMinting);\n    uint256 _newAmount;\n    bool err;\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n    require(!err);\n\n    self.totalSupply =  _newAmount;\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n    Transfer(0x0, self.owner, _amount);\n    return true;\n  }\n\n  \n  \n  \n  function closeMint(TokenStorage storage self) public returns (bool) {\n    require(self.owner == msg.sender);\n\n    self.stillMinting = false;\n    MintingClosed(true);\n    return true;\n  }\n\n  \n  \n  \n  \n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n      uint256 _newBalance;\n      bool err;\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n      require(!err);\n\n      self.balances[msg.sender] = _newBalance;\n      self.totalSupply = self.totalSupply - _amount;\n      Burn(msg.sender, _amount);\n      Transfer(msg.sender, 0x0, _amount);\n      return true;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "contract": "TokenLib",
        "function": null,
        "line": 177,
        "line_end": 177,
        "name": "Overflow bugs",
        "code_segment": "library TokenLib {\n  using BasicMathLib for uint256;\n\n  struct TokenStorage {\n    bool initialized;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    uint256 initialSupply;\n    address owner;\n    uint8 decimals;\n    bool stillMinting;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event OwnerChange(address from, address to);\n  event Burn(address indexed burner, uint256 value);\n  event MintingClosed(bool mintingClosed);\n\n  \n  \n  \n  \n  \n  \n  \n  function init(TokenStorage storage self,\n                address _owner,\n                string _name,\n                string _symbol,\n                uint8 _decimals,\n                uint256 _initial_supply,\n                bool _allowMinting)\n                public\n  {\n    require(!self.initialized);\n    self.initialized = true;\n    self.name = _name;\n    self.symbol = _symbol;\n    self.totalSupply = _initial_supply;\n    self.initialSupply = _initial_supply;\n    self.decimals = _decimals;\n    self.owner = _owner;\n    self.stillMinting = _allowMinting;\n    self.balances[_owner] = _initial_supply;\n  }\n\n  \n  \n  \n  \n  \n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    bool err;\n    uint256 balance;\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n    require(!err);\n    self.balances[msg.sender] = balance;\n    //It's not possible to overflow token supply\n    self.balances[_to] = self.balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  \n  function transferFrom(TokenStorage storage self,\n                        address _from,\n                        address _to,\n                        uint256 _value)\n                        public\n                        returns (bool)\n  {\n    var _allowance = self.allowed[_from][msg.sender];\n    bool err;\n    uint256 balanceOwner;\n    uint256 balanceSpender;\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n    require(!err);\n\n    (err,balanceSpender) = _allowance.minus(_value);\n    require(!err);\n\n    self.balances[_from] = balanceOwner;\n    self.allowed[_from][msg.sender] = balanceSpender;\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n    return self.balances[_owner];\n  }\n\n  \n  \n  \n  \n  \n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n    // must set to zero before changing approval amount in accordance with spec\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n    self.allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  function allowance(TokenStorage storage self, address _owner, address _spender)\n                     public\n                     view\n                     returns (uint256 remaining) {\n    return self.allowed[_owner][_spender];\n  }\n\n  \n  \n  \n  \n  \n  \n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n                          public returns (bool)\n  {\n    uint256 _newAllowed;\n    bool err;\n\n    if(_increase) {\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n      require(!err);\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n    } else {\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n        self.allowed[msg.sender][_spender] = 0;\n      } else {\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n        self.allowed[msg.sender][_spender] = _newAllowed;\n      }\n    }\n\n    Approval(msg.sender, _spender, _newAllowed);\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n    self.owner = _newOwner;\n    OwnerChange(msg.sender, _newOwner);\n    return true;\n  }\n\n  \n  \n  \n  \n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n    require((self.owner == msg.sender) && self.stillMinting);\n    uint256 _newAmount;\n    bool err;\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n    require(!err);\n\n    self.totalSupply =  _newAmount;\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n    Transfer(0x0, self.owner, _amount);\n    return true;\n  }\n\n  \n  \n  \n  function closeMint(TokenStorage storage self) public returns (bool) {\n    require(self.owner == msg.sender);\n\n    self.stillMinting = false;\n    MintingClosed(true);\n    return true;\n  }\n\n  \n  \n  \n  \n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n      uint256 _newBalance;\n      bool err;\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n      require(!err);\n\n      self.balances[msg.sender] = _newBalance;\n      self.totalSupply = self.totalSupply - _amount;\n      Burn(msg.sender, _amount);\n      Transfer(msg.sender, 0x0, _amount);\n      return true;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 305,
        "line_end": 305,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 337,
        "line_end": 337,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 499,
        "line_end": 499,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 525,
        "line_end": 525,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 531,
        "line_end": 531,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 811,
        "line_end": 811,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 818,
        "line_end": 818,
        "name": "Overflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 14,
        "line_end": 14,
        "name": "Truncation bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 14,
        "line_end": 14,
        "name": "Truncation bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "contract": "TestLibBytes",
        "function": null,
        "line": 12,
        "line_end": 12,
        "name": "Underflow bugs",
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "AddressArray",
        "function": null,
        "line": 82,
        "line_end": 82,
        "name": "Overflow bugs",
        "code_segment": "library AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "DummyDex",
        "function": null,
        "line": 526,
        "line_end": 526,
        "name": "Overflow bugs",
        "code_segment": "contract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "DummyDex",
        "function": null,
        "line": 526,
        "line_end": 526,
        "name": "Overflow bugs",
        "code_segment": "contract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "DummyDex",
        "function": null,
        "line": 533,
        "line_end": 533,
        "name": "Overflow bugs",
        "code_segment": "contract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "DummyDex",
        "function": null,
        "line": 534,
        "line_end": 534,
        "name": "Overflow bugs",
        "code_segment": "contract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "ERC20Base",
        "function": null,
        "line": 428,
        "line_end": 428,
        "name": "Truncation bugs",
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "ERC20Base",
        "function": null,
        "line": 452,
        "line_end": 452,
        "name": "Truncation bugs",
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "contract": "ERC20Base",
        "function": null,
        "line": 458,
        "line_end": 458,
        "name": "Truncation bugs",
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "contract": "ERC20StandardToken",
        "function": null,
        "line": 146,
        "line_end": 146,
        "name": "Overflow bugs",
        "code_segment": "contract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "contract": "FloatingSupplyToken",
        "function": null,
        "line": 146,
        "line_end": 146,
        "name": "Overflow bugs",
        "code_segment": "contract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "contract": "MintableToken",
        "function": null,
        "line": 146,
        "line_end": 146,
        "name": "Overflow bugs",
        "code_segment": "contract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "contract": "PreapprovedToken",
        "function": null,
        "line": 146,
        "line_end": 146,
        "name": "Overflow bugs",
        "code_segment": "contract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-setprotocol/set-protocol-contracts-b4acf144c10b1d9f3ecde4ee2820931df1cb8e4a/contracts/external/DappHub/median.sol",
        "contract": "Median",
        "function": null,
        "line": 223,
        "line_end": 223,
        "name": "Truncation bugs",
        "code_segment": "contract Median is DSAuth {\n\n    uint128        val;\n    uint48  public age;\n\n    bytes32 public wat = \"ETHUSD\";\n    uint256 public min; // minimum valid feeds\n\n    // Authorized oracles, set by an auth\n    mapping (address => bool) public orcl;\n\n    event LogPrice(uint128 val, uint48 age);\n\n    function read() public view returns (bytes32) {\n        require(val > 0, \"Invalid price feed\");\n        return bytes32(uint256(val));\n    }\n\n    function peek() public view returns (bytes32,bool) {\n        return (bytes32(uint256(val)), val > 0);\n    }\n\n    function recover(uint256 val_, uint256 age_, uint8 v, bytes32 r, bytes32 s, bytes32 wat_) internal pure returns (address) {\n        return ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", keccak256(abi.encodePacked(val_, age_, wat_)))),\n            v, r, s\n        );\n    }\n\n    function poke(\n        uint256[] calldata val_, uint256[] calldata age_,\n        uint8[] calldata v, bytes32[] calldata r, bytes32[] calldata s) external\n    {\n        uint256 l = val_.length;\n        require(l >= min, \"Not enough signed messages\");\n        require(l % 2 != 0, \"Need odd number of messages\");\n\n        // Array to store signer addresses, to check for uniqueness later\n        address[] memory signers = new address[](l);\n\n        for (uint i = 0; i < l; i++) {\n            // Validate the values were signed by an authorized oracle\n            address signer = recover(val_[i], age_[i], v[i], r[i], s[i], wat);\n            // Check that signer is an oracle\n            require(orcl[signer], \"Signature by invalid oracle\");\n\n            // Price feed age greater than last medianizer age\n            require(age_[i] > uint256(age), \"Stale message\");\n\n            // Check for ordered values (TODO: better out of bounds check?)\n            if ((i + 1) < l) {\n                // require(val_[i] <= val_[i + 1], \"Messages not in order\");\n            }\n\n            // Check for uniqueness (TODO: is this the best we can do?)\n            for (uint j = 0; j < i; j++) {\n                require(signers[j] != signer, \"Oracle already signed\");\n            }\n            signers[i] = signer;\n        }\n\n        // Write the value and timestamp to storage\n        // require(med_ == val_[(l - 1) / 2], \"Sanity check fail\");\n        val = uint128(val_[(l - 1) / 2]);\n        age = uint48(block.timestamp);\n\n        emit LogPrice(val, age); // some event\n    }\n\n    function lift(address a) public auth {\n        require(a != address(0x0), \"No oracle 0\");\n        orcl[a] = true;\n    }\n\n    function drop(address a) public auth {\n        orcl[a] = false;\n    }\n\n    function setMin(uint256 min_) public auth {\n        require(min_ > 0, \"Minimum valid oracles cannot be 0\");\n        min = min_;\n    }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "contract": "KeyHolderLibrary",
        "function": null,
        "line": 103,
        "line_end": 103,
        "name": "Callstack bug",
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "contract": "KeyHolderLibrary",
        "function": null,
        "line": 1,
        "line_end": 1,
        "name": "Overflow bugs",
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "contract": "KeyHolderLibrary",
        "function": null,
        "line": 56,
        "line_end": 56,
        "name": "Overflow bugs",
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "contract": "KeyHolderLibrary",
        "function": null,
        "line": 61,
        "line_end": 61,
        "name": "Overflow bugs",
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "contract": "RewardsDistribution",
        "function": null,
        "line": 316,
        "line_end": 316,
        "name": "Overflow bugs",
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "contract": "RewardsDistribution",
        "function": null,
        "line": 420,
        "line_end": 420,
        "name": "Underflow bugs",
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "contract": "RewardsDistribution",
        "function": null,
        "line": 423,
        "line_end": 423,
        "name": "Underflow bugs",
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "contract": "RewardsDistribution",
        "function": null,
        "line": 445,
        "line_end": 445,
        "name": "Underflow bugs",
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "contract": "ReentrancyMock",
        "function": null,
        "line": 29,
        "line_end": 29,
        "name": "Overflow bugs",
        "code_segment": "contract ReentrancyMock is ReentrancyGuard {\n\n  uint256 public counter;\n\n  constructor() public {\n    counter = 0;\n  }\n\n  function callback() external nonReentrant {\n    count();\n  }\n\n  function countLocalRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      countLocalRecursive(n - 1);\n    }\n  }\n\n  function countThisRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      // solium-disable-next-line security/no-low-level-calls\n      bool result = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n      require(result == true);\n    }\n  }\n\n  function countAndCall(ReentrancyAttack attacker) public nonReentrant {\n    count();\n    bytes4 func = bytes4(keccak256(\"callback()\"));\n    attacker.callSender(func);\n  }\n\n  function count() private {\n    counter += 1;\n  }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "contract": "ReentrancyMock",
        "function": null,
        "line": 81,
        "line_end": 81,
        "name": "Overflow bugs",
        "code_segment": "contract ReentrancyMock is ReentrancyGuard {\n\n  uint256 public counter;\n\n  constructor() public {\n    counter = 0;\n  }\n\n  function callback() external nonReentrant {\n    count();\n  }\n\n  function countLocalRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      countLocalRecursive(n - 1);\n    }\n  }\n\n  function countThisRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      // solium-disable-next-line security/no-low-level-calls\n      bool result = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n      require(result == true);\n    }\n  }\n\n  function countAndCall(ReentrancyAttack attacker) public nonReentrant {\n    count();\n    bytes4 func = bytes4(keccak256(\"callback()\"));\n    attacker.callSender(func);\n  }\n\n  function count() private {\n    counter += 1;\n  }\n\n}",
        "check": "FP"
    },
    {
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Lido-WstETH/lido-dao-ea6fa222004b88e6a24b566a51e5b56b0079272d/contracts/0.4.24/test_helpers/LidoMockForOracle.sol",
        "contract": "LidoMockForOracle",
        "function": null,
        "line": 25,
        "line_end": 25,
        "name": "Overflow bugs",
        "code_segment": "contract LidoMockForOracle {\n    uint256 private totalPooledEther;\n\n    function totalSupply() external view returns (uint256) {\n        return totalPooledEther;\n    }\n\n    function pushBeacon(uint256 /*_beaconValidators*/, uint256 _beaconBalance) external {\n        totalPooledEther = _beaconBalance;\n    }\n\n    function getTotalShares() public view returns (uint256) {\n        return 42;\n    }\n\n    function pretendTotalPooledEtherGweiForTest(uint256 _val) public {\n        totalPooledEther = _val * 1e9; // gwei to wei\n    }\n}",
        "check": "FP"
    }
]