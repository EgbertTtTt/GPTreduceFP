[
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract IOwnable {\n    function transferOwnership(address newOwner)\n        public;\n}\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract Ownable is IOwnable {\n    address public owner;\n\n    constructor ()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"ONLY_CONTRACT_OWNER\"\n        );\n        _;\n    }\n\n    function transferOwnership(address newOwner)\n        public\n        onlyOwner\n    {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\nlibrary LibBytes {\n\n    using LibBytes for bytes;\n\n    \n    \n    \n    \n    \n    function rawAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := input\n        }\n        return memoryAddress;\n    }\n    \n    \n    \n    \n    function contentAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := add(input, 32)\n        }\n        return memoryAddress;\n    }\n\n    \n    \n    \n    \n    function memCopy(\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        internal\n        pure\n    {\n        if (length < 32) {\n            // Handle a partial word by reading destination and masking\n            // off the bits we are interested in.\n            // This correctly handles overlap, zero lengths and source == dest\n            assembly {\n                let mask := sub(exp(256, sub(32, length)), 1)\n                let s := and(mload(source), not(mask))\n                let d := and(mload(dest), mask)\n                mstore(dest, or(s, d))\n            }\n        } else {\n            // Skip the O(length) loop when source == dest.\n            if (source == dest) {\n                return;\n            }\n\n            // For large copies we copy whole words at a time. The final\n            // word is aligned to the end of the range (instead of after the\n            // previous) to handle partial words. So a copy will look like this:\n            //\n            //  ####\n            //      ####\n            //          ####\n            //            ####\n            //\n            // We handle overlap in the source and destination range by\n            // changing the copying direction. This prevents us from\n            // overwriting parts of source that we still need to copy.\n            //\n            // This correctly handles source == dest\n            //\n            if (source > dest) {\n                assembly {\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n                    // is easier to compare with in the loop, and these\n                    // are also the addresses we need for copying the\n                    // last bytes.\n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    // Remember the last 32 bytes of source\n                    // This needs to be done here and not after the loop\n                    // because we may have overwritten the last bytes in\n                    // source already due to overlap.\n                    let last := mload(sEnd)\n\n                    // Copy whole words front to back\n                    // Note: the first check is always true,\n                    // this could have been a do-while loop.\n                    // solhint-disable-next-line no-empty-blocks\n                    for {} lt(source, sEnd) {} {\n                        mstore(dest, mload(source))\n                        source := add(source, 32)\n                        dest := add(dest, 32)\n                    }\n                    \n                    // Write the last 32 bytes\n                    mstore(dEnd, last)\n                }\n            } else {\n                assembly {\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n                    // are the starting points when copying a word at the end.\n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    // Remember the first 32 bytes of source\n                    // This needs to be done here and not after the loop\n                    // because we may have overwritten the first bytes in\n                    // source already due to overlap.\n                    let first := mload(source)\n\n                    // Copy whole words back to front\n                    // We use a signed comparisson here to allow dEnd to become\n                    // negative (happens when source and dest < 32). Valid\n                    // addresses in local memory will never be larger than\n                    // 2**255, so they can be safely re-interpreted as signed.\n                    // Note: the first check is always true,\n                    // this could have been a do-while loop.\n                    // solhint-disable-next-line no-empty-blocks\n                    for {} slt(dest, dEnd) {} {\n                        mstore(dEnd, mload(sEnd))\n                        sEnd := sub(sEnd, 32)\n                        dEnd := sub(dEnd, 32)\n                    }\n                    \n                    // Write the first 32 bytes\n                    mstore(dest, first)\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    function slice(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        require(\n            from <= to,\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n        );\n        require(\n            to < b.length,\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n        );\n        \n        // Create a new bytes structure and copy contents\n        result = new bytes(to - from);\n        memCopy(\n            result.contentAddress(),\n            b.contentAddress() + from,\n            result.length);\n        return result;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function sliceDestructive(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        require(\n            from <= to,\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n        );\n        require(\n            to < b.length,\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n        );\n        \n        // Create a new bytes structure around [from, to) in-place.\n        assembly {\n            result := add(b, from)\n            mstore(result, sub(to, from))\n        }\n        return result;\n    }\n\n    \n    \n    \n    function popLastByte(bytes memory b)\n        internal\n        pure\n        returns (bytes1 result)\n    {\n        require(\n            b.length > 0,\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n        );\n\n        // Store last byte.\n        result = b[b.length - 1];\n\n        assembly {\n            // Decrement length of byte array.\n            let newLen := sub(mload(b), 1)\n            mstore(b, newLen)\n        }\n        return result;\n    }\n\n    \n    \n    \n    function popLast20Bytes(bytes memory b)\n        internal\n        pure\n        returns (address result)\n    {\n        require(\n            b.length >= 20,\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n        );\n\n        // Store last 20 bytes.\n        result = readAddress(b, b.length - 20);\n\n        assembly {\n            // Subtract 20 from byte array length.\n            let newLen := sub(mload(b), 20)\n            mstore(b, newLen)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function equals(\n        bytes memory lhs,\n        bytes memory rhs\n    )\n        internal\n        pure\n        returns (bool equal)\n    {\n        // Keccak gas cost is 30 + numWords * 6. This is a cheap way to compare.\n        // We early exit on unequal lengths, but keccak would also correctly\n        // handle this.\n        return lhs.length == rhs.length && keccak256(lhs) == keccak256(rhs);\n    }\n\n    \n    \n    \n    \n    function readAddress(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (address result)\n    {\n        require(\n            b.length >= index + 20,  // 20 is length of address\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n        );\n\n        // Add offset to index:\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n        index += 20;\n\n        // Read address from array memory\n        assembly {\n            // 1. Add index to address of bytes array\n            // 2. Load 32-byte word from memory\n            // 3. Apply 20-byte mask to obtain address\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        internal\n        pure\n    {\n        require(\n            b.length >= index + 20,  // 20 is length of address\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n        );\n\n        // Add offset to index:\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n        index += 20;\n\n        // Store address into array memory\n        assembly {\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n            // First fetch the 32-byte word where we'll be storing the address, then\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n            // 1. Add index to address of bytes array\n            // 2. Load 32-byte word from memory\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n            let neighbors := and(\n                mload(add(b, index)),\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n            )\n            \n            // Make sure input address is clean.\n            // (Solidity does not guarantee this)\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // Store the neighbors and address into memory\n            mstore(add(b, index), xor(input, neighbors))\n        }\n    }\n\n    \n    \n    \n    \n    function readBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        require(\n            b.length >= index + 32,\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n        );\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, index))\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        internal\n        pure\n    {\n        require(\n            b.length >= index + 32,\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n        );\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            mstore(add(b, index), input)\n        }\n    }\n\n    \n    \n    \n    \n    function readUint256(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256 result)\n    {\n        return uint256(readBytes32(b, index));\n    }\n\n    \n    \n    \n    \n    function writeUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        internal\n        pure\n    {\n        writeBytes32(b, index, bytes32(input));\n    }\n\n    \n    \n    \n    \n    function readBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        require(\n            b.length >= index + 4,\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n        );\n        assembly {\n            result := mload(add(b, 32))\n            // Solidity does not require us to clean the trailing bytes.\n            // We do it anyway\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    \n    function readBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        // Read length of nested bytes\n        uint256 nestedBytesLength = readUint256(b, index);\n        index += 32;\n\n        // Assert length of <b> is valid, given\n        // length of nested bytes\n        require(\n            b.length >= index + nestedBytesLength,\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n        );\n        \n        // Return a pointer to the byte array as it exists inside `b`\n        assembly {\n            result := add(b, index)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        internal\n        pure\n    {\n        // Assert length of <b> is valid, given\n        // length of input\n        require(\n            b.length >= index + 32 + input.length,  // 32 bytes to store length\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n        );\n\n        // Copy <input> into <b>\n        memCopy(\n            b.contentAddress() + index,\n            input.rawAddress(), // includes length of <input>\n            input.length + 32   // +32 bytes to store <input> length\n        );\n    }\n\n    \n    \n    \n    function deepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        internal\n        pure\n    {\n        uint256 sourceLen = source.length;\n        // Dest length must be >= source length, or some bytes would not be copied.\n        require(\n            dest.length >= sourceLen,\n            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n        );\n        memCopy(\n            dest.contentAddress(),\n            source.contentAddress(),\n            sourceLen\n        );\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IAssetProxyDispatcher {\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external;\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address);\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract MAssetProxyDispatcher is\n    IAssetProxyDispatcher {\n\n    // Logs registration of new asset proxy\n    event AssetProxyRegistered(\n        bytes4 id,              // Id of new registered AssetProxy.\n        address assetProxy      // Address of new registered AssetProxy.\n    );\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal;\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IAuthorizable is\n    IOwnable {\n\n    \n    \n    function addAuthorizedAddress(address target)\n        external;\n\n    \n    \n    function removeAuthorizedAddress(address target)\n        external;\n\n    \n    \n    \n    function removeAuthorizedAddressAtIndex(\n        address target,\n        uint256 index\n    )\n        external;\n    \n    \n    \n    function getAuthorizedAddresses()\n        external\n        view\n        returns (address[] memory);\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IAssetProxy is\n    IAuthorizable {\n\n    \n    \n    \n    \n    \n    function transferFrom(\n        bytes assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        external;\n    \n    \n    \n    function getProxyId()\n        external\n        pure\n        returns (bytes4);\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract IOwnable {\n    function transferOwnership(address newOwner)\n        public;\n}\n\n/*\n * Ownable\n *\n * Base contract with an owner.\n * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner.\n */\ncontract Ownable is IOwnable {\n    address public owner;\n\n    constructor ()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(\n            msg.sender == owner,\n            \"ONLY_CONTRACT_OWNER\"\n        );\n        _;\n    }\n\n    function transferOwnership(address newOwner)\n        public\n        onlyOwner\n    {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\nlibrary LibBytes {\n\n    using LibBytes for bytes;\n\n    \n    \n    \n    \n    \n    function rawAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := input\n        }\n        return memoryAddress;\n    }\n    \n    \n    \n    \n    function contentAddress(bytes memory input)\n        internal\n        pure\n        returns (uint256 memoryAddress)\n    {\n        assembly {\n            memoryAddress := add(input, 32)\n        }\n        return memoryAddress;\n    }\n\n    \n    \n    \n    \n    function memCopy(\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        internal\n        pure\n    {\n        if (length < 32) {\n            // Handle a partial word by reading destination and masking\n            // off the bits we are interested in.\n            // This correctly handles overlap, zero lengths and source == dest\n            assembly {\n                let mask := sub(exp(256, sub(32, length)), 1)\n                let s := and(mload(source), not(mask))\n                let d := and(mload(dest), mask)\n                mstore(dest, or(s, d))\n            }\n        } else {\n            // Skip the O(length) loop when source == dest.\n            if (source == dest) {\n                return;\n            }\n\n            // For large copies we copy whole words at a time. The final\n            // word is aligned to the end of the range (instead of after the\n            // previous) to handle partial words. So a copy will look like this:\n            //\n            //  ####\n            //      ####\n            //          ####\n            //            ####\n            //\n            // We handle overlap in the source and destination range by\n            // changing the copying direction. This prevents us from\n            // overwriting parts of source that we still need to copy.\n            //\n            // This correctly handles source == dest\n            //\n            if (source > dest) {\n                assembly {\n                    // We subtract 32 from `sEnd` and `dEnd` because it\n                    // is easier to compare with in the loop, and these\n                    // are also the addresses we need for copying the\n                    // last bytes.\n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    // Remember the last 32 bytes of source\n                    // This needs to be done here and not after the loop\n                    // because we may have overwritten the last bytes in\n                    // source already due to overlap.\n                    let last := mload(sEnd)\n\n                    // Copy whole words front to back\n                    // Note: the first check is always true,\n                    // this could have been a do-while loop.\n                    // solhint-disable-next-line no-empty-blocks\n                    for {} lt(source, sEnd) {} {\n                        mstore(dest, mload(source))\n                        source := add(source, 32)\n                        dest := add(dest, 32)\n                    }\n                    \n                    // Write the last 32 bytes\n                    mstore(dEnd, last)\n                }\n            } else {\n                assembly {\n                    // We subtract 32 from `sEnd` and `dEnd` because those\n                    // are the starting points when copying a word at the end.\n                    length := sub(length, 32)\n                    let sEnd := add(source, length)\n                    let dEnd := add(dest, length)\n\n                    // Remember the first 32 bytes of source\n                    // This needs to be done here and not after the loop\n                    // because we may have overwritten the first bytes in\n                    // source already due to overlap.\n                    let first := mload(source)\n\n                    // Copy whole words back to front\n                    // We use a signed comparisson here to allow dEnd to become\n                    // negative (happens when source and dest < 32). Valid\n                    // addresses in local memory will never be larger than\n                    // 2**255, so they can be safely re-interpreted as signed.\n                    // Note: the first check is always true,\n                    // this could have been a do-while loop.\n                    // solhint-disable-next-line no-empty-blocks\n                    for {} slt(dest, dEnd) {} {\n                        mstore(dEnd, mload(sEnd))\n                        sEnd := sub(sEnd, 32)\n                        dEnd := sub(dEnd, 32)\n                    }\n                    \n                    // Write the first 32 bytes\n                    mstore(dest, first)\n                }\n            }\n        }\n    }\n\n    \n    \n    \n    \n    \n    function slice(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        require(\n            from <= to,\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n        );\n        require(\n            to < b.length,\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n        );\n        \n        // Create a new bytes structure and copy contents\n        result = new bytes(to - from);\n        memCopy(\n            result.contentAddress(),\n            b.contentAddress() + from,\n            result.length);\n        return result;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function sliceDestructive(\n        bytes memory b,\n        uint256 from,\n        uint256 to\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        require(\n            from <= to,\n            \"FROM_LESS_THAN_TO_REQUIRED\"\n        );\n        require(\n            to < b.length,\n            \"TO_LESS_THAN_LENGTH_REQUIRED\"\n        );\n        \n        // Create a new bytes structure around [from, to) in-place.\n        assembly {\n            result := add(b, from)\n            mstore(result, sub(to, from))\n        }\n        return result;\n    }\n\n    \n    \n    \n    function popLastByte(bytes memory b)\n        internal\n        pure\n        returns (bytes1 result)\n    {\n        require(\n            b.length > 0,\n            \"GREATER_THAN_ZERO_LENGTH_REQUIRED\"\n        );\n\n        // Store last byte.\n        result = b[b.length - 1];\n\n        assembly {\n            // Decrement length of byte array.\n            let newLen := sub(mload(b), 1)\n            mstore(b, newLen)\n        }\n        return result;\n    }\n\n    \n    \n    \n    function popLast20Bytes(bytes memory b)\n        internal\n        pure\n        returns (address result)\n    {\n        require(\n            b.length >= 20,\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n        );\n\n        // Store last 20 bytes.\n        result = readAddress(b, b.length - 20);\n\n        assembly {\n            // Subtract 20 from byte array length.\n            let newLen := sub(mload(b), 20)\n            mstore(b, newLen)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function equals(\n        bytes memory lhs,\n        bytes memory rhs\n    )\n        internal\n        pure\n        returns (bool equal)\n    {\n        // Keccak gas cost is 30 + numWords * 6. This is a cheap way to compare.\n        // We early exit on unequal lengths, but keccak would also correctly\n        // handle this.\n        return lhs.length == rhs.length && keccak256(lhs) == keccak256(rhs);\n    }\n\n    \n    \n    \n    \n    function readAddress(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (address result)\n    {\n        require(\n            b.length >= index + 20,  // 20 is length of address\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n        );\n\n        // Add offset to index:\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n        index += 20;\n\n        // Read address from array memory\n        assembly {\n            // 1. Add index to address of bytes array\n            // 2. Load 32-byte word from memory\n            // 3. Apply 20-byte mask to obtain address\n            result := and(mload(add(b, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        internal\n        pure\n    {\n        require(\n            b.length >= index + 20,  // 20 is length of address\n            \"GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED\"\n        );\n\n        // Add offset to index:\n        // 1. Arrays are prefixed by 32-byte length parameter (add 32 to index)\n        // 2. Account for size difference between address length and 32-byte storage word (subtract 12 from index)\n        index += 20;\n\n        // Store address into array memory\n        assembly {\n            // The address occupies 20 bytes and mstore stores 32 bytes.\n            // First fetch the 32-byte word where we'll be storing the address, then\n            // apply a mask so we have only the bytes in the word that the address will not occupy.\n            // Then combine these bytes with the address and store the 32 bytes back to memory with mstore.\n\n            // 1. Add index to address of bytes array\n            // 2. Load 32-byte word from memory\n            // 3. Apply 12-byte mask to obtain extra bytes occupying word of memory where we'll store the address\n            let neighbors := and(\n                mload(add(b, index)),\n                0xffffffffffffffffffffffff0000000000000000000000000000000000000000\n            )\n            \n            // Make sure input address is clean.\n            // (Solidity does not guarantee this)\n            input := and(input, 0xffffffffffffffffffffffffffffffffffffffff)\n\n            // Store the neighbors and address into memory\n            mstore(add(b, index), xor(input, neighbors))\n        }\n    }\n\n    \n    \n    \n    \n    function readBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        require(\n            b.length >= index + 32,\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n        );\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            result := mload(add(b, index))\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        internal\n        pure\n    {\n        require(\n            b.length >= index + 32,\n            \"GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED\"\n        );\n\n        // Arrays are prefixed by a 256 bit length parameter\n        index += 32;\n\n        // Read the bytes32 from array memory\n        assembly {\n            mstore(add(b, index), input)\n        }\n    }\n\n    \n    \n    \n    \n    function readUint256(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (uint256 result)\n    {\n        return uint256(readBytes32(b, index));\n    }\n\n    \n    \n    \n    \n    function writeUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        internal\n        pure\n    {\n        writeBytes32(b, index, bytes32(input));\n    }\n\n    \n    \n    \n    \n    function readBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes4 result)\n    {\n        require(\n            b.length >= index + 4,\n            \"GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED\"\n        );\n        assembly {\n            result := mload(add(b, 32))\n            // Solidity does not require us to clean the trailing bytes.\n            // We do it anyway\n            result := and(result, 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    \n    function readBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        // Read length of nested bytes\n        uint256 nestedBytesLength = readUint256(b, index);\n        index += 32;\n\n        // Assert length of <b> is valid, given\n        // length of nested bytes\n        require(\n            b.length >= index + nestedBytesLength,\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n        );\n        \n        // Return a pointer to the byte array as it exists inside `b`\n        assembly {\n            result := add(b, index)\n        }\n        return result;\n    }\n\n    \n    \n    \n    \n    function writeBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        internal\n        pure\n    {\n        // Assert length of <b> is valid, given\n        // length of input\n        require(\n            b.length >= index + 32 + input.length,  // 32 bytes to store length\n            \"GREATER_OR_EQUAL_TO_NESTED_BYTES_LENGTH_REQUIRED\"\n        );\n\n        // Copy <input> into <b>\n        memCopy(\n            b.contentAddress() + index,\n            input.rawAddress(), // includes length of <input>\n            input.length + 32   // +32 bytes to store <input> length\n        );\n    }\n\n    \n    \n    \n    function deepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        internal\n        pure\n    {\n        uint256 sourceLen = source.length;\n        // Dest length must be >= source length, or some bytes would not be copied.\n        require(\n            dest.length >= sourceLen,\n            \"GREATER_OR_EQUAL_TO_SOURCE_BYTES_LENGTH_REQUIRED\"\n        );\n        memCopy(\n            dest.contentAddress(),\n            source.contentAddress(),\n            sourceLen\n        );\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IAssetProxyDispatcher {\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external;\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address);\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract MAssetProxyDispatcher is\n    IAssetProxyDispatcher {\n\n    // Logs registration of new asset proxy\n    event AssetProxyRegistered(\n        bytes4 id,              // Id of new registered AssetProxy.\n        address assetProxy      // Address of new registered AssetProxy.\n    );\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal;\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IAuthorizable is\n    IOwnable {\n\n    \n    \n    function addAuthorizedAddress(address target)\n        external;\n\n    \n    \n    function removeAuthorizedAddress(address target)\n        external;\n\n    \n    \n    \n    function removeAuthorizedAddressAtIndex(\n        address target,\n        uint256 index\n    )\n        external;\n    \n    \n    \n    function getAuthorizedAddresses()\n        external\n        view\n        returns (address[] memory);\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IAssetProxy is\n    IAuthorizable {\n\n    \n    \n    \n    \n    \n    function transferFrom(\n        bytes assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        external;\n    \n    \n    \n    function getProxyId()\n        external\n        pure\n        returns (bytes4);\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract TokenLockable is RpSafeMath, Ownable {\n    mapping(address => uint256) public lockedTokens;\n\n    /**\n        @dev Locked tokens cannot be withdrawn using the withdrawTokens function.\n    */\n    function lockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeAdd(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Unlocks previusly locked tokens.\n    */\n    function unlockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Withdraws tokens from the contract.\n\n        @param token Token to withdraw\n        @param to Destination of the tokens\n        @param amount Amount to withdraw \n    */\n    function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\n        require(to != address(0));\n        return token.transfer(to, amount);\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract ERC721 {\n   // ERC20 compatible functions\n   function name() constant returns (string _name);\n   function symbol() constant returns (string _symbol);\n   function totalSupply() constant returns (uint256 _totalSupply);\n   function balanceOf(address _owner) constant returns (uint _balance);\n   // Functions that define ownership\n   function ownerOf(uint256) constant returns (address owner);\n   function approve(address, uint256) public returns (bool);\n   function takeOwnership(uint256) public returns (bool);\n   function transfer(address, uint256) public returns (bool);\n   // Events\n   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n}\n\ncontract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract TokenLockable is RpSafeMath, Ownable {\n    mapping(address => uint256) public lockedTokens;\n\n    /**\n        @dev Locked tokens cannot be withdrawn using the withdrawTokens function.\n    */\n    function lockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeAdd(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Unlocks previusly locked tokens.\n    */\n    function unlockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Withdraws tokens from the contract.\n\n        @param token Token to withdraw\n        @param to Destination of the tokens\n        @param amount Amount to withdraw \n    */\n    function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\n        require(to != address(0));\n        return token.transfer(to, amount);\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract ERC721 {\n   // ERC20 compatible functions\n   function name() constant returns (string _name);\n   function symbol() constant returns (string _symbol);\n   function totalSupply() constant returns (uint256 _totalSupply);\n   function balanceOf(address _owner) constant returns (uint _balance);\n   // Functions that define ownership\n   function ownerOf(uint256) constant returns (address owner);\n   function approve(address, uint256) public returns (bool);\n   function takeOwnership(uint256) public returns (bool);\n   function transfer(address, uint256) public returns (bool);\n   // Events\n   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n}\n\ncontract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender)\n    public view returns (uint256);\n\n  function transferFrom(address from, address to, uint256 value)\n    public returns (bool);\n\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n\n// File: contracts\\JarvisPlusToken.sol\n/*\n *\n *  This is the defination of Jarvis+ Token.\n *  Name = \"Jarvis+ Token\"\n *  Symbol = \"JAR\"\n *  Decimals = 18\n *\n */\ncontract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ninterface tokenRecipient {\n    function receiveApproval (address from, uint256 value, address token, bytes extraData) external;\n}\n\n/**\n * DreamTeam token contract. It implements the next capabilities:\n * 1. Standard ERC20 functionality. [OK]\n * 2. Additional utility function approveAndCall. [OK]\n * 3. Function to rescue \"lost forever\" tokens, which were accidentally sent to the contract address. [OK]\n * 4. Additional transfer and approve functions which allow to distinct the transaction signer and executor,\n *    which enables accounts with no Ether on their balances to make token transfers and use DreamTeam services. [ALPHA]\n * 5. Token sale distribution rules. [OK]\n */\ncontract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L6\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L6\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L6\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L6\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L6\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n// SWC-100-Function Default Visibility: L2-24\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n// SWC-100-Function Default Visibility: L2-24\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n// SWC-100-Function Default Visibility: L2-24\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Gasless Send",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function _transferOwnership(address _newOwner) internal {\n        require(_newOwner != address(0), \"Can't transfer to 0x0\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n\ncontract ProjectWallet {\n\n    function transfer(address _receiver, uint256 _amt) public returns (bool);\n\n}\n\ncontract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function _transferOwnership(address _newOwner) internal {\n        require(_newOwner != address(0), \"Can't transfer to 0x0\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n\ncontract ProjectWallet {\n\n    function transfer(address _receiver, uint256 _amt) public returns (bool);\n\n}\n\ncontract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function _transferOwnership(address _newOwner) internal {\n        require(_newOwner != address(0), \"Can't transfer to 0x0\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n\ncontract ProjectWallet {\n\n    function transfer(address _receiver, uint256 _amt) public returns (bool);\n\n}\n\ncontract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n\n    event OwnershipRenounced(address indexed previousOwner);\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n    constructor() public {\n        owner = msg.sender;\n    }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n    function renounceOwnership() public onlyOwner {\n        emit OwnershipRenounced(owner);\n        owner = address(0);\n    }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        _transferOwnership(_newOwner);\n    }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n    function _transferOwnership(address _newOwner) internal {\n        require(_newOwner != address(0), \"Can't transfer to 0x0\");\n        emit OwnershipTransferred(owner, _newOwner);\n        owner = _newOwner;\n    }\n}\n\ncontract ProjectWallet {\n\n    function transfer(address _receiver, uint256 _amt) public returns (bool);\n\n}\n\ncontract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.19;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\n\n\ncontract ReceivingContract {\n    function onTokenReceived(address _from, uint _value, bytes _data) public;\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  // SWC-114-Transaction Order Dependence: L14\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\ncontract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncontract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}\n\n// Copyright 2018 Golem Factory\n// Licensed under the GNU General Public License v3. See the LICENSE file.\n// SWC-102-Outdated Compiler Version: L5\n\n\n\n\n\n\ncontract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\ncontract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\n/* Holds all tGNT after simulated crowdfunding on testnet. */\n/* To receive some tGNT just call create. */\ncontract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\n/* Holds all tGNT after simulated crowdfunding on testnet. */\n/* To receive some tGNT just call create. */\ncontract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20 {\n  function balanceOf(address who) public view returns (uint256);\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}\n\n/*\nCopyright (c) 2016 Smart Contract Solutions, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title POLY token initial distribution\n *\n * @dev Distribute purchasers, airdrop, reserve, and founder tokens\n */\ncontract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.11;\n\n\n/**\n * Authors: Justin Jones, Marshall Stokes\n * Published: 2017 by Sprux LLC\n */\n/* Contract provides functions so only contract owner can execute a function */\ncontract owned {\n    address public owner; //the contract owner\n\n    function owned() {\n        owner = msg.sender; //constructor initializes the creator as the owner on initialization\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw; // functions with onlyOwner will throw and exception if not the contract owner\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner { // transfer contract owner to new owner\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n/**\n * Centrally issued Ethereum token.\n *\n * Token supply is created in the token contract creation and allocated to one owner for distribution. This token is mintable, so more tokens\n * can be added to the total supply and assigned to an address supplied at contract execution.\n *\n */\ncontract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L7\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L7\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L7\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L7\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2018-04-27\n*/\n// SWC-103-Floating Pragma: L7\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n\t/**\n\t* @dev Multiplies two numbers, throws on overflow.\n\t*/\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tif (a == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tc = a * b;\n\t\tassert(c / a == b);\n\t\treturn c;\n\t}\n\n\t/**\n\t* @dev Integer division of two numbers, truncating the quotient.\n\t*/\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\t// uint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn a / b;\n\t}\n\n\t/**\n\t* @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n\t*/\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\t/**\n\t* @dev Adds two numbers, throws on overflow.\n\t*/\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n\t\tc = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n\tfunction totalSupply() public view returns (uint256);\n\tfunction balanceOf(address who) public view returns (uint256);\n\tfunction transfer(address to, uint256 value) public returns (bool);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n\tfunction allowance(address owner, address spender) public view returns (uint256);\n\tfunction transferFrom(address from, address to, uint256 value) public returns (bool);\n\tfunction approve(address spender, uint256 value) public returns (bool);\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}\n\ncontract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\". This adds two-phase\n * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n * designates a new owner but does not actually transfer ownership. The new owner then accepts \n * ownership and completes the transfer.\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n\n    event OwnershipTransferred(\n      address indexed previousOwner,\n      address indexed newOwner\n    );\n\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor() public {\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Account is not owner\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"Account is not pending owner\");\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Empty address\");\n        pendingOwner = _newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() onlyPendingOwner public {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\n/**\n* @title Lockable\n* @dev Base contract which allows children to lock certain methods from being called by clients.\n* Locked methods are deemed unsafe by default, but must be implemented in children functionality to adhere by\n* some inherited standard, for example. \n*/\ncontract Lockable is Ownable {\n\t// Events\n\tevent Unlocked();\n\tevent Locked();\n\n\t// Modifiers\n\t/**\n\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n\t*/\n\tmodifier whenUnlocked() {\n\t\trequire(!isLocked(), \"Contact is locked\");\n\t\t_;\n\t}\n\n\t// Methods\n\t/**\n\t* @dev called by the owner to enable method\n\t*/\n\tfunction unlock() public onlyOwner  {\n\t\tsetLock(false);\n\t\temit Unlocked();\n\t}\n\n\t/**\n\t* @dev called by the owner to disable method, back to normal state\n\t*/\n\tfunction lock() public  onlyOwner {\n\t\tsetLock(true);\n\t\temit Locked();\n\t}\n\n\tfunction setLock(bool value) internal {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v = value ? 1 : 0;\n        assembly {\n            sstore(slot, v)\n        }\n    }\n\n    function isLocked() public view returns (bool) {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v;\n        assembly {\n            v := sload(slot)\n        }\n        return v != 0;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/helpers/Lockable.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\". This adds two-phase\n * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n * designates a new owner but does not actually transfer ownership. The new owner then accepts \n * ownership and completes the transfer.\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n\n    event OwnershipTransferred(\n      address indexed previousOwner,\n      address indexed newOwner\n    );\n\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor() public {\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Account is not owner\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"Account is not pending owner\");\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Empty address\");\n        pendingOwner = _newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() onlyPendingOwner public {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\n/**\n* @title Lockable\n* @dev Base contract which allows children to lock certain methods from being called by clients.\n* Locked methods are deemed unsafe by default, but must be implemented in children functionality to adhere by\n* some inherited standard, for example. \n*/\ncontract Lockable is Ownable {\n\t// Events\n\tevent Unlocked();\n\tevent Locked();\n\n\t// Modifiers\n\t/**\n\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n\t*/\n\tmodifier whenUnlocked() {\n\t\trequire(!isLocked(), \"Contact is locked\");\n\t\t_;\n\t}\n\n\t// Methods\n\t/**\n\t* @dev called by the owner to enable method\n\t*/\n\tfunction unlock() public onlyOwner  {\n\t\tsetLock(false);\n\t\temit Unlocked();\n\t}\n\n\t/**\n\t* @dev called by the owner to disable method, back to normal state\n\t*/\n\tfunction lock() public  onlyOwner {\n\t\tsetLock(true);\n\t\temit Locked();\n\t}\n\n\tfunction setLock(bool value) internal {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v = value ? 1 : 0;\n        assembly {\n            sstore(slot, v)\n        }\n    }\n\n    function isLocked() public view returns (bool) {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v;\n        assembly {\n            v := sload(slot)\n        }\n        return v != 0;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/helpers/Lockable.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\". This adds two-phase\n * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n * designates a new owner but does not actually transfer ownership. The new owner then accepts \n * ownership and completes the transfer.\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n\n    event OwnershipTransferred(\n      address indexed previousOwner,\n      address indexed newOwner\n    );\n\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor() public {\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Account is not owner\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"Account is not pending owner\");\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Empty address\");\n        pendingOwner = _newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() onlyPendingOwner public {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\n/**\n* @title Lockable\n* @dev Base contract which allows children to lock certain methods from being called by clients.\n* Locked methods are deemed unsafe by default, but must be implemented in children functionality to adhere by\n* some inherited standard, for example. \n*/\ncontract Lockable is Ownable {\n\t// Events\n\tevent Unlocked();\n\tevent Locked();\n\n\t// Modifiers\n\t/**\n\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n\t*/\n\tmodifier whenUnlocked() {\n\t\trequire(!isLocked(), \"Contact is locked\");\n\t\t_;\n\t}\n\n\t// Methods\n\t/**\n\t* @dev called by the owner to enable method\n\t*/\n\tfunction unlock() public onlyOwner  {\n\t\tsetLock(false);\n\t\temit Unlocked();\n\t}\n\n\t/**\n\t* @dev called by the owner to disable method, back to normal state\n\t*/\n\tfunction lock() public  onlyOwner {\n\t\tsetLock(true);\n\t\temit Locked();\n\t}\n\n\tfunction setLock(bool value) internal {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v = value ? 1 : 0;\n        assembly {\n            sstore(slot, v)\n        }\n    }\n\n    function isLocked() public view returns (bool) {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v;\n        assembly {\n            v := sload(slot)\n        }\n        return v != 0;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/helpers/Lockable.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\". This adds two-phase\n * ownership control to OpenZeppelin's Ownable class. In this model, the original owner \n * designates a new owner but does not actually transfer ownership. The new owner then accepts \n * ownership and completes the transfer.\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n\n\n    event OwnershipTransferred(\n      address indexed previousOwner,\n      address indexed newOwner\n    );\n\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n    * account.\n    */\n    constructor() public {\n        owner = msg.sender;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Account is not owner\");\n        _;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner, \"Account is not pending owner\");\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != address(0), \"Empty address\");\n        pendingOwner = _newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() onlyPendingOwner public {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n}\n\n/**\n* @title Lockable\n* @dev Base contract which allows children to lock certain methods from being called by clients.\n* Locked methods are deemed unsafe by default, but must be implemented in children functionality to adhere by\n* some inherited standard, for example. \n*/\ncontract Lockable is Ownable {\n\t// Events\n\tevent Unlocked();\n\tevent Locked();\n\n\t// Modifiers\n\t/**\n\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n\t*/\n\tmodifier whenUnlocked() {\n\t\trequire(!isLocked(), \"Contact is locked\");\n\t\t_;\n\t}\n\n\t// Methods\n\t/**\n\t* @dev called by the owner to enable method\n\t*/\n\tfunction unlock() public onlyOwner  {\n\t\tsetLock(false);\n\t\temit Unlocked();\n\t}\n\n\t/**\n\t* @dev called by the owner to disable method, back to normal state\n\t*/\n\tfunction lock() public  onlyOwner {\n\t\tsetLock(true);\n\t\temit Locked();\n\t}\n\n\tfunction setLock(bool value) internal {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v = value ? 1 : 0;\n        assembly {\n            sstore(slot, v)\n        }\n    }\n\n    function isLocked() public view returns (bool) {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v;\n        assembly {\n            v := sload(slot)\n        }\n        return v != 0;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/helpers/Lockable.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic {\n  uint public totalSupply;\n  function balanceOf(address who) public constant returns (uint);\n  function transfer(address to, uint value) public returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint);\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\n  function approve(address spender, uint value) public returns (bool ok);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n\n  uint8 public decimals;\n\n}\n\n/**\n * Originally from  https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n  function mul(uint a, uint b) internal constant returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal constant returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal constant returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal constant returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint a, uint b) internal constant returns (uint) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint a, uint b) internal constant returns (uint) {\n    return a < b ? a : b;\n  }\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances. \n */\ncontract BasicToken is ERC20Basic, Burnable, Mintable {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n  /**\n   * Obsolete. Removed this check based on:\n   * https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/\n   * @dev Fix for the ERC20 short address attack.\n   *\n   * modifier onlyPayloadSize(uint size) {\n   *    require(msg.data.length >= size + 4);\n   *    _;\n   * }\n   */\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint value) public returns (bool success) {\n    balances[msg.sender] = balances[msg.sender].sub(value);\n    balances[to] = balances[to].add(value);\n    Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public constant returns (uint balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint value) internal {\n    balances[account] = balances[account].sub(value);\n    totalSupply = totalSupply.sub(value);\n    Burned(account, value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint amount) internal {\n    totalSupply = totalSupply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n  }\n  \n}\n\n/**\n * Originally by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Modified by https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint value) public returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n    allowed[msg.sender][spender] = value;\n    Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public constant returns (uint remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint addedValue) public\n  returns (bool success) {\n      uint oldValue = allowed[msg.sender][spender];\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint subtractedValue) public\n  returns (bool success) {\n\n      uint oldVal = allowed[msg.sender][spender];\n\n      if (subtractedValue > oldVal) {\n          allowed[msg.sender][spender] = 0;\n      } else {\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n      }\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n  \n}\n\n// SWC-135-Code With No Effects\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control \n * functions, this simplifies the implementation of \"user permissions\". \n */\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner. \n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to. \n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is StandardToken, Ownable {\n\n  /* The finalizer contract that allows lifting the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Since the owner of this contract is (or should be) the crowdsale,\n   * it can only be called by a corresponding exposed API in the crowdsale contract in case of input error.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (e.g. a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens into the wild.\n   *\n   * Can be called only from the release agent that should typically be the finalize agent ICO contract.\n   * In the scope of the crowdsale, it is only called if the crowdsale has been a success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   */\n  modifier canTransfer(address sender) {\n    require(released || transferAgents[sender]);\n    _;\n  }\n\n  /** The function can be called only before or after the tokens have been released */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  /** We restrict transfer by overriding it */\n  function transfer(address to, uint value) public canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(to, value);\n  }\n\n  /** We restrict transferFrom by overriding it */\n  function transferFrom(address from, address to, uint value) public canTransfer(from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(from, to, value);\n  }\n\n}\n\n/**\n * Inspired by Lunyr.\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n *\n * The Upgrade agent is the interface used to implement a token\n * migration in the case of an emergency.\n * The function upgradeFrom has to implement the part of the creation\n * of new tokens on behalf of the user doing the upgrade.\n *\n * The new token can implement this interface directly, or use.\n */\ncontract UpgradeAgent {\n\n  /** This value should be the same as the original token's total supply */\n  uint public originalSupply;\n\n  /** Interface to ensure the contract is correctly configured */\n  function isUpgradeAgent() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n  Upgrade an account\n\n  When the token contract is in the upgrade status the each user will\n  have to call `upgrade(value)` function from UpgradeableToken.\n\n  The upgrade function adjust the balance of the user and the supply\n  of the previous token and then call `upgradeFrom(value)`.\n\n  The UpgradeAgent is the responsible to create the tokens for the user\n  in the new contract.\n\n  * @param from Account to upgrade.\n  * @param value Tokens to upgrade.\n\n  */\n  function upgradeFrom(address from, uint value) public;\n\n}\n\n/**\n * First envisioned by Golem and Lunyr projects.\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n */\ncontract UpgradeableToken is ERC20Basic, Burnable {\n  using SafeMath for uint;\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint public totalUpgraded = 0;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet. This allows changing the upgrade agent while there is time.\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed from, address to, uint value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address master) internal {\n    setUpgradeMaster(master);\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint value) public {\n    UpgradeState state = getUpgradeState();\n    // Ensure it's not called in a bad state\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n    // Validate input value.\n    require(value != 0);\n\n    // Upgrade agent reissues the tokens\n    upgradeAgent.upgradeFrom(msg.sender, value);\n    \n    // Take tokens out from circulation\n    burnTokens(msg.sender, value);\n    totalUpgraded = totalUpgraded.add(value);\n\n    Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles the upgrade process\n   */\n  function setUpgradeAgent(address agent) onlyMaster external {\n    // Check whether the token is in a state that we could think of upgrading\n    require(canUpgrade());\n\n    require(agent != 0x0);\n    // Upgrade has already begun for an agent\n    require(getUpgradeState() != UpgradeState.Upgrading);\n\n    upgradeAgent = UpgradeAgent(agent);\n\n    // Bad interface\n    require(upgradeAgent.isUpgradeAgent());\n    // Make sure that token supplies match in source and target\n    require(upgradeAgent.originalSupply() == totalSupply);\n\n    UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if (!canUpgrade()) return UpgradeState.NotAllowed;\n    else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function changeUpgradeMaster(address new_master) onlyMaster public {\n    setUpgradeMaster(new_master);\n  }\n\n  /**\n   * Internal upgrade master setter.\n   */\n  function setUpgradeMaster(address new_master) private {\n    require(new_master != 0x0);\n    upgradeMaster = new_master;\n  }\n\n  /**\n   * Child contract can override to provide the condition in which the upgrade can begin.\n   */\n  function canUpgrade() public constant returns(bool) {\n     return true;\n  }\n\n\n  modifier onlyMaster() {\n    require(msg.sender == upgradeMaster);\n    _;\n  }\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n// This contract aims to provide an inheritable way to recover tokens from a contract not meant to hold tokens\n// To use this contract, have your token-ignoring contract inherit this one and implement getLostAndFoundMaster to decide who can move lost tokens.\n// Of course, this contract imposes support costs upon whoever is the lost and found master.\ncontract LostAndFoundToken {\n  /**\n   * @return Address of the account that handles movements.\n   */\n  function getLostAndFoundMaster() internal constant returns (address);\n\n  /**\n   * @param agent Address that will be able to move tokens with transferFrom\n   * @param tokens Amount of tokens approved for transfer\n   * @param token_contract Contract of the token\n   */\n  function enableLostAndFound(address agent, uint tokens, ERC20 token_contract) public {\n    require(msg.sender == getLostAndFoundMaster());\n    token_contract.approve(agent, tokens);\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableToken is ERC20Basic, Mintable, Ownable {\n\n  using SafeMath for uint;\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state);\n\n\n  function MintableToken(uint initialSupply, address multisig, bool mintable) internal {\n    require(multisig != address(0));\n    // Cannot create a token without supply and no minting\n    require(mintable || initialSupply != 0);\n    // Create initially all balance on the team multisig\n    if (initialSupply > 0)\n        mintInternal(multisig, initialSupply);\n    // No more new supply allowed after the token creation\n    mintingFinished = !mintable;\n  }\n\n  /**\n   * Create new tokens and allocate them to an address.\n   *\n   * Only callable by a mint agent (e.g. crowdsale contract).\n   */\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n    mintInternal(receiver, amount);\n\n    // TODO: Remove this. It may be confused with anonymous transfers in the upcoming fork.\n    // This will make the mint transaction appear in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Transfer(0, receiver, amount);\n\n    Minted(receiver, amount);\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  modifier onlyMintAgent() {\n    // Only mint agents are allowed to mint new tokens\n    require(mintAgents[msg.sender]);\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A crowdsale token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through the approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n * - ERC20 tokens transferred to this contract can be recovered by a lost and found master\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic {\n  uint public totalSupply;\n  function balanceOf(address who) public constant returns (uint);\n  function transfer(address to, uint value) public returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint);\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\n  function approve(address spender, uint value) public returns (bool ok);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n\n  uint8 public decimals;\n\n}\n\n/**\n * Originally from  https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n  function mul(uint a, uint b) internal constant returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal constant returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal constant returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal constant returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint a, uint b) internal constant returns (uint) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint a, uint b) internal constant returns (uint) {\n    return a < b ? a : b;\n  }\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances. \n */\ncontract BasicToken is ERC20Basic, Burnable, Mintable {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n  /**\n   * Obsolete. Removed this check based on:\n   * https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/\n   * @dev Fix for the ERC20 short address attack.\n   *\n   * modifier onlyPayloadSize(uint size) {\n   *    require(msg.data.length >= size + 4);\n   *    _;\n   * }\n   */\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint value) public returns (bool success) {\n    balances[msg.sender] = balances[msg.sender].sub(value);\n    balances[to] = balances[to].add(value);\n    Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public constant returns (uint balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint value) internal {\n    balances[account] = balances[account].sub(value);\n    totalSupply = totalSupply.sub(value);\n    Burned(account, value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint amount) internal {\n    totalSupply = totalSupply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n  }\n  \n}\n\n/**\n * Originally by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Modified by https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint value) public returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n    allowed[msg.sender][spender] = value;\n    Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public constant returns (uint remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint addedValue) public\n  returns (bool success) {\n      uint oldValue = allowed[msg.sender][spender];\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint subtractedValue) public\n  returns (bool success) {\n\n      uint oldVal = allowed[msg.sender][spender];\n\n      if (subtractedValue > oldVal) {\n          allowed[msg.sender][spender] = 0;\n      } else {\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n      }\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n  \n}\n\n// SWC-135-Code With No Effects\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control \n * functions, this simplifies the implementation of \"user permissions\". \n */\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner. \n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to. \n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is StandardToken, Ownable {\n\n  /* The finalizer contract that allows lifting the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Since the owner of this contract is (or should be) the crowdsale,\n   * it can only be called by a corresponding exposed API in the crowdsale contract in case of input error.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (e.g. a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens into the wild.\n   *\n   * Can be called only from the release agent that should typically be the finalize agent ICO contract.\n   * In the scope of the crowdsale, it is only called if the crowdsale has been a success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   */\n  modifier canTransfer(address sender) {\n    require(released || transferAgents[sender]);\n    _;\n  }\n\n  /** The function can be called only before or after the tokens have been released */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  /** We restrict transfer by overriding it */\n  function transfer(address to, uint value) public canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(to, value);\n  }\n\n  /** We restrict transferFrom by overriding it */\n  function transferFrom(address from, address to, uint value) public canTransfer(from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(from, to, value);\n  }\n\n}\n\n/**\n * Inspired by Lunyr.\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n *\n * The Upgrade agent is the interface used to implement a token\n * migration in the case of an emergency.\n * The function upgradeFrom has to implement the part of the creation\n * of new tokens on behalf of the user doing the upgrade.\n *\n * The new token can implement this interface directly, or use.\n */\ncontract UpgradeAgent {\n\n  /** This value should be the same as the original token's total supply */\n  uint public originalSupply;\n\n  /** Interface to ensure the contract is correctly configured */\n  function isUpgradeAgent() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n  Upgrade an account\n\n  When the token contract is in the upgrade status the each user will\n  have to call `upgrade(value)` function from UpgradeableToken.\n\n  The upgrade function adjust the balance of the user and the supply\n  of the previous token and then call `upgradeFrom(value)`.\n\n  The UpgradeAgent is the responsible to create the tokens for the user\n  in the new contract.\n\n  * @param from Account to upgrade.\n  * @param value Tokens to upgrade.\n\n  */\n  function upgradeFrom(address from, uint value) public;\n\n}\n\n/**\n * First envisioned by Golem and Lunyr projects.\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n */\ncontract UpgradeableToken is ERC20Basic, Burnable {\n  using SafeMath for uint;\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint public totalUpgraded = 0;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet. This allows changing the upgrade agent while there is time.\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed from, address to, uint value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address master) internal {\n    setUpgradeMaster(master);\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint value) public {\n    UpgradeState state = getUpgradeState();\n    // Ensure it's not called in a bad state\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n    // Validate input value.\n    require(value != 0);\n\n    // Upgrade agent reissues the tokens\n    upgradeAgent.upgradeFrom(msg.sender, value);\n    \n    // Take tokens out from circulation\n    burnTokens(msg.sender, value);\n    totalUpgraded = totalUpgraded.add(value);\n\n    Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles the upgrade process\n   */\n  function setUpgradeAgent(address agent) onlyMaster external {\n    // Check whether the token is in a state that we could think of upgrading\n    require(canUpgrade());\n\n    require(agent != 0x0);\n    // Upgrade has already begun for an agent\n    require(getUpgradeState() != UpgradeState.Upgrading);\n\n    upgradeAgent = UpgradeAgent(agent);\n\n    // Bad interface\n    require(upgradeAgent.isUpgradeAgent());\n    // Make sure that token supplies match in source and target\n    require(upgradeAgent.originalSupply() == totalSupply);\n\n    UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if (!canUpgrade()) return UpgradeState.NotAllowed;\n    else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function changeUpgradeMaster(address new_master) onlyMaster public {\n    setUpgradeMaster(new_master);\n  }\n\n  /**\n   * Internal upgrade master setter.\n   */\n  function setUpgradeMaster(address new_master) private {\n    require(new_master != 0x0);\n    upgradeMaster = new_master;\n  }\n\n  /**\n   * Child contract can override to provide the condition in which the upgrade can begin.\n   */\n  function canUpgrade() public constant returns(bool) {\n     return true;\n  }\n\n\n  modifier onlyMaster() {\n    require(msg.sender == upgradeMaster);\n    _;\n  }\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n// This contract aims to provide an inheritable way to recover tokens from a contract not meant to hold tokens\n// To use this contract, have your token-ignoring contract inherit this one and implement getLostAndFoundMaster to decide who can move lost tokens.\n// Of course, this contract imposes support costs upon whoever is the lost and found master.\ncontract LostAndFoundToken {\n  /**\n   * @return Address of the account that handles movements.\n   */\n  function getLostAndFoundMaster() internal constant returns (address);\n\n  /**\n   * @param agent Address that will be able to move tokens with transferFrom\n   * @param tokens Amount of tokens approved for transfer\n   * @param token_contract Contract of the token\n   */\n  function enableLostAndFound(address agent, uint tokens, ERC20 token_contract) public {\n    require(msg.sender == getLostAndFoundMaster());\n    token_contract.approve(agent, tokens);\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableToken is ERC20Basic, Mintable, Ownable {\n\n  using SafeMath for uint;\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state);\n\n\n  function MintableToken(uint initialSupply, address multisig, bool mintable) internal {\n    require(multisig != address(0));\n    // Cannot create a token without supply and no minting\n    require(mintable || initialSupply != 0);\n    // Create initially all balance on the team multisig\n    if (initialSupply > 0)\n        mintInternal(multisig, initialSupply);\n    // No more new supply allowed after the token creation\n    mintingFinished = !mintable;\n  }\n\n  /**\n   * Create new tokens and allocate them to an address.\n   *\n   * Only callable by a mint agent (e.g. crowdsale contract).\n   */\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n    mintInternal(receiver, amount);\n\n    // TODO: Remove this. It may be confused with anonymous transfers in the upcoming fork.\n    // This will make the mint transaction appear in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Transfer(0, receiver, amount);\n\n    Minted(receiver, amount);\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  modifier onlyMintAgent() {\n    // Only mint agents are allowed to mint new tokens\n    require(mintAgents[msg.sender]);\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A crowdsale token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through the approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n * - ERC20 tokens transferred to this contract can be recovered by a lost and found master\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic {\n  uint public totalSupply;\n  function balanceOf(address who) public constant returns (uint);\n  function transfer(address to, uint value) public returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint);\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\n  function approve(address spender, uint value) public returns (bool ok);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n\n  uint8 public decimals;\n\n}\n\n/**\n * Originally from  https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n  function mul(uint a, uint b) internal constant returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal constant returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal constant returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal constant returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint a, uint b) internal constant returns (uint) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint a, uint b) internal constant returns (uint) {\n    return a < b ? a : b;\n  }\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances. \n */\ncontract BasicToken is ERC20Basic, Burnable, Mintable {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n  /**\n   * Obsolete. Removed this check based on:\n   * https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/\n   * @dev Fix for the ERC20 short address attack.\n   *\n   * modifier onlyPayloadSize(uint size) {\n   *    require(msg.data.length >= size + 4);\n   *    _;\n   * }\n   */\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint value) public returns (bool success) {\n    balances[msg.sender] = balances[msg.sender].sub(value);\n    balances[to] = balances[to].add(value);\n    Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public constant returns (uint balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint value) internal {\n    balances[account] = balances[account].sub(value);\n    totalSupply = totalSupply.sub(value);\n    Burned(account, value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint amount) internal {\n    totalSupply = totalSupply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n  }\n  \n}\n\n/**\n * Originally by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Modified by https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint value) public returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n    allowed[msg.sender][spender] = value;\n    Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public constant returns (uint remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint addedValue) public\n  returns (bool success) {\n      uint oldValue = allowed[msg.sender][spender];\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint subtractedValue) public\n  returns (bool success) {\n\n      uint oldVal = allowed[msg.sender][spender];\n\n      if (subtractedValue > oldVal) {\n          allowed[msg.sender][spender] = 0;\n      } else {\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n      }\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n  \n}\n\n// SWC-135-Code With No Effects\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control \n * functions, this simplifies the implementation of \"user permissions\". \n */\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner. \n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to. \n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is StandardToken, Ownable {\n\n  /* The finalizer contract that allows lifting the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Since the owner of this contract is (or should be) the crowdsale,\n   * it can only be called by a corresponding exposed API in the crowdsale contract in case of input error.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (e.g. a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens into the wild.\n   *\n   * Can be called only from the release agent that should typically be the finalize agent ICO contract.\n   * In the scope of the crowdsale, it is only called if the crowdsale has been a success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   */\n  modifier canTransfer(address sender) {\n    require(released || transferAgents[sender]);\n    _;\n  }\n\n  /** The function can be called only before or after the tokens have been released */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  /** We restrict transfer by overriding it */\n  function transfer(address to, uint value) public canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(to, value);\n  }\n\n  /** We restrict transferFrom by overriding it */\n  function transferFrom(address from, address to, uint value) public canTransfer(from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(from, to, value);\n  }\n\n}\n\n/**\n * Inspired by Lunyr.\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n *\n * The Upgrade agent is the interface used to implement a token\n * migration in the case of an emergency.\n * The function upgradeFrom has to implement the part of the creation\n * of new tokens on behalf of the user doing the upgrade.\n *\n * The new token can implement this interface directly, or use.\n */\ncontract UpgradeAgent {\n\n  /** This value should be the same as the original token's total supply */\n  uint public originalSupply;\n\n  /** Interface to ensure the contract is correctly configured */\n  function isUpgradeAgent() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n  Upgrade an account\n\n  When the token contract is in the upgrade status the each user will\n  have to call `upgrade(value)` function from UpgradeableToken.\n\n  The upgrade function adjust the balance of the user and the supply\n  of the previous token and then call `upgradeFrom(value)`.\n\n  The UpgradeAgent is the responsible to create the tokens for the user\n  in the new contract.\n\n  * @param from Account to upgrade.\n  * @param value Tokens to upgrade.\n\n  */\n  function upgradeFrom(address from, uint value) public;\n\n}\n\n/**\n * First envisioned by Golem and Lunyr projects.\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n */\ncontract UpgradeableToken is ERC20Basic, Burnable {\n  using SafeMath for uint;\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint public totalUpgraded = 0;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet. This allows changing the upgrade agent while there is time.\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed from, address to, uint value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address master) internal {\n    setUpgradeMaster(master);\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint value) public {\n    UpgradeState state = getUpgradeState();\n    // Ensure it's not called in a bad state\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n    // Validate input value.\n    require(value != 0);\n\n    // Upgrade agent reissues the tokens\n    upgradeAgent.upgradeFrom(msg.sender, value);\n    \n    // Take tokens out from circulation\n    burnTokens(msg.sender, value);\n    totalUpgraded = totalUpgraded.add(value);\n\n    Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles the upgrade process\n   */\n  function setUpgradeAgent(address agent) onlyMaster external {\n    // Check whether the token is in a state that we could think of upgrading\n    require(canUpgrade());\n\n    require(agent != 0x0);\n    // Upgrade has already begun for an agent\n    require(getUpgradeState() != UpgradeState.Upgrading);\n\n    upgradeAgent = UpgradeAgent(agent);\n\n    // Bad interface\n    require(upgradeAgent.isUpgradeAgent());\n    // Make sure that token supplies match in source and target\n    require(upgradeAgent.originalSupply() == totalSupply);\n\n    UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if (!canUpgrade()) return UpgradeState.NotAllowed;\n    else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function changeUpgradeMaster(address new_master) onlyMaster public {\n    setUpgradeMaster(new_master);\n  }\n\n  /**\n   * Internal upgrade master setter.\n   */\n  function setUpgradeMaster(address new_master) private {\n    require(new_master != 0x0);\n    upgradeMaster = new_master;\n  }\n\n  /**\n   * Child contract can override to provide the condition in which the upgrade can begin.\n   */\n  function canUpgrade() public constant returns(bool) {\n     return true;\n  }\n\n\n  modifier onlyMaster() {\n    require(msg.sender == upgradeMaster);\n    _;\n  }\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n// This contract aims to provide an inheritable way to recover tokens from a contract not meant to hold tokens\n// To use this contract, have your token-ignoring contract inherit this one and implement getLostAndFoundMaster to decide who can move lost tokens.\n// Of course, this contract imposes support costs upon whoever is the lost and found master.\ncontract LostAndFoundToken {\n  /**\n   * @return Address of the account that handles movements.\n   */\n  function getLostAndFoundMaster() internal constant returns (address);\n\n  /**\n   * @param agent Address that will be able to move tokens with transferFrom\n   * @param tokens Amount of tokens approved for transfer\n   * @param token_contract Contract of the token\n   */\n  function enableLostAndFound(address agent, uint tokens, ERC20 token_contract) public {\n    require(msg.sender == getLostAndFoundMaster());\n    token_contract.approve(agent, tokens);\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableToken is ERC20Basic, Mintable, Ownable {\n\n  using SafeMath for uint;\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state);\n\n\n  function MintableToken(uint initialSupply, address multisig, bool mintable) internal {\n    require(multisig != address(0));\n    // Cannot create a token without supply and no minting\n    require(mintable || initialSupply != 0);\n    // Create initially all balance on the team multisig\n    if (initialSupply > 0)\n        mintInternal(multisig, initialSupply);\n    // No more new supply allowed after the token creation\n    mintingFinished = !mintable;\n  }\n\n  /**\n   * Create new tokens and allocate them to an address.\n   *\n   * Only callable by a mint agent (e.g. crowdsale contract).\n   */\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n    mintInternal(receiver, amount);\n\n    // TODO: Remove this. It may be confused with anonymous transfers in the upcoming fork.\n    // This will make the mint transaction appear in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Transfer(0, receiver, amount);\n\n    Minted(receiver, amount);\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  modifier onlyMintAgent() {\n    // Only mint agents are allowed to mint new tokens\n    require(mintAgents[msg.sender]);\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A crowdsale token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through the approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n * - ERC20 tokens transferred to this contract can be recovered by a lost and found master\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic {\n  uint public totalSupply;\n  function balanceOf(address who) public constant returns (uint);\n  function transfer(address to, uint value) public returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint);\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\n  function approve(address spender, uint value) public returns (bool ok);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n\n  uint8 public decimals;\n\n}\n\n/**\n * Originally from  https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n  function mul(uint a, uint b) internal constant returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal constant returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal constant returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal constant returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint a, uint b) internal constant returns (uint) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint a, uint b) internal constant returns (uint) {\n    return a < b ? a : b;\n  }\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances. \n */\ncontract BasicToken is ERC20Basic, Burnable, Mintable {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n  /**\n   * Obsolete. Removed this check based on:\n   * https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/\n   * @dev Fix for the ERC20 short address attack.\n   *\n   * modifier onlyPayloadSize(uint size) {\n   *    require(msg.data.length >= size + 4);\n   *    _;\n   * }\n   */\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint value) public returns (bool success) {\n    balances[msg.sender] = balances[msg.sender].sub(value);\n    balances[to] = balances[to].add(value);\n    Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public constant returns (uint balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint value) internal {\n    balances[account] = balances[account].sub(value);\n    totalSupply = totalSupply.sub(value);\n    Burned(account, value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint amount) internal {\n    totalSupply = totalSupply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n  }\n  \n}\n\n/**\n * Originally by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Modified by https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint value) public returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n    allowed[msg.sender][spender] = value;\n    Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public constant returns (uint remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint addedValue) public\n  returns (bool success) {\n      uint oldValue = allowed[msg.sender][spender];\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint subtractedValue) public\n  returns (bool success) {\n\n      uint oldVal = allowed[msg.sender][spender];\n\n      if (subtractedValue > oldVal) {\n          allowed[msg.sender][spender] = 0;\n      } else {\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n      }\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n  \n}\n\n// SWC-135-Code With No Effects\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control \n * functions, this simplifies the implementation of \"user permissions\". \n */\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner. \n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to. \n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is StandardToken, Ownable {\n\n  /* The finalizer contract that allows lifting the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Since the owner of this contract is (or should be) the crowdsale,\n   * it can only be called by a corresponding exposed API in the crowdsale contract in case of input error.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (e.g. a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens into the wild.\n   *\n   * Can be called only from the release agent that should typically be the finalize agent ICO contract.\n   * In the scope of the crowdsale, it is only called if the crowdsale has been a success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   */\n  modifier canTransfer(address sender) {\n    require(released || transferAgents[sender]);\n    _;\n  }\n\n  /** The function can be called only before or after the tokens have been released */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  /** We restrict transfer by overriding it */\n  function transfer(address to, uint value) public canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(to, value);\n  }\n\n  /** We restrict transferFrom by overriding it */\n  function transferFrom(address from, address to, uint value) public canTransfer(from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(from, to, value);\n  }\n\n}\n\n/**\n * Inspired by Lunyr.\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n *\n * The Upgrade agent is the interface used to implement a token\n * migration in the case of an emergency.\n * The function upgradeFrom has to implement the part of the creation\n * of new tokens on behalf of the user doing the upgrade.\n *\n * The new token can implement this interface directly, or use.\n */\ncontract UpgradeAgent {\n\n  /** This value should be the same as the original token's total supply */\n  uint public originalSupply;\n\n  /** Interface to ensure the contract is correctly configured */\n  function isUpgradeAgent() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n  Upgrade an account\n\n  When the token contract is in the upgrade status the each user will\n  have to call `upgrade(value)` function from UpgradeableToken.\n\n  The upgrade function adjust the balance of the user and the supply\n  of the previous token and then call `upgradeFrom(value)`.\n\n  The UpgradeAgent is the responsible to create the tokens for the user\n  in the new contract.\n\n  * @param from Account to upgrade.\n  * @param value Tokens to upgrade.\n\n  */\n  function upgradeFrom(address from, uint value) public;\n\n}\n\n/**\n * First envisioned by Golem and Lunyr projects.\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n */\ncontract UpgradeableToken is ERC20Basic, Burnable {\n  using SafeMath for uint;\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint public totalUpgraded = 0;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet. This allows changing the upgrade agent while there is time.\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed from, address to, uint value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address master) internal {\n    setUpgradeMaster(master);\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint value) public {\n    UpgradeState state = getUpgradeState();\n    // Ensure it's not called in a bad state\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n    // Validate input value.\n    require(value != 0);\n\n    // Upgrade agent reissues the tokens\n    upgradeAgent.upgradeFrom(msg.sender, value);\n    \n    // Take tokens out from circulation\n    burnTokens(msg.sender, value);\n    totalUpgraded = totalUpgraded.add(value);\n\n    Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles the upgrade process\n   */\n  function setUpgradeAgent(address agent) onlyMaster external {\n    // Check whether the token is in a state that we could think of upgrading\n    require(canUpgrade());\n\n    require(agent != 0x0);\n    // Upgrade has already begun for an agent\n    require(getUpgradeState() != UpgradeState.Upgrading);\n\n    upgradeAgent = UpgradeAgent(agent);\n\n    // Bad interface\n    require(upgradeAgent.isUpgradeAgent());\n    // Make sure that token supplies match in source and target\n    require(upgradeAgent.originalSupply() == totalSupply);\n\n    UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if (!canUpgrade()) return UpgradeState.NotAllowed;\n    else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function changeUpgradeMaster(address new_master) onlyMaster public {\n    setUpgradeMaster(new_master);\n  }\n\n  /**\n   * Internal upgrade master setter.\n   */\n  function setUpgradeMaster(address new_master) private {\n    require(new_master != 0x0);\n    upgradeMaster = new_master;\n  }\n\n  /**\n   * Child contract can override to provide the condition in which the upgrade can begin.\n   */\n  function canUpgrade() public constant returns(bool) {\n     return true;\n  }\n\n\n  modifier onlyMaster() {\n    require(msg.sender == upgradeMaster);\n    _;\n  }\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n// This contract aims to provide an inheritable way to recover tokens from a contract not meant to hold tokens\n// To use this contract, have your token-ignoring contract inherit this one and implement getLostAndFoundMaster to decide who can move lost tokens.\n// Of course, this contract imposes support costs upon whoever is the lost and found master.\ncontract LostAndFoundToken {\n  /**\n   * @return Address of the account that handles movements.\n   */\n  function getLostAndFoundMaster() internal constant returns (address);\n\n  /**\n   * @param agent Address that will be able to move tokens with transferFrom\n   * @param tokens Amount of tokens approved for transfer\n   * @param token_contract Contract of the token\n   */\n  function enableLostAndFound(address agent, uint tokens, ERC20 token_contract) public {\n    require(msg.sender == getLostAndFoundMaster());\n    token_contract.approve(agent, tokens);\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableToken is ERC20Basic, Mintable, Ownable {\n\n  using SafeMath for uint;\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state);\n\n\n  function MintableToken(uint initialSupply, address multisig, bool mintable) internal {\n    require(multisig != address(0));\n    // Cannot create a token without supply and no minting\n    require(mintable || initialSupply != 0);\n    // Create initially all balance on the team multisig\n    if (initialSupply > 0)\n        mintInternal(multisig, initialSupply);\n    // No more new supply allowed after the token creation\n    mintingFinished = !mintable;\n  }\n\n  /**\n   * Create new tokens and allocate them to an address.\n   *\n   * Only callable by a mint agent (e.g. crowdsale contract).\n   */\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n    mintInternal(receiver, amount);\n\n    // TODO: Remove this. It may be confused with anonymous transfers in the upcoming fork.\n    // This will make the mint transaction appear in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Transfer(0, receiver, amount);\n\n    Minted(receiver, amount);\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  modifier onlyMintAgent() {\n    // Only mint agents are allowed to mint new tokens\n    require(mintAgents[msg.sender]);\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A crowdsale token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through the approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n * - ERC20 tokens transferred to this contract can be recovered by a lost and found master\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Basic {\n  uint public totalSupply;\n  function balanceOf(address who) public constant returns (uint);\n  function transfer(address to, uint value) public returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint);\n  function transferFrom(address from, address to, uint value) public returns (bool ok);\n  function approve(address spender, uint value) public returns (bool ok);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * A token that defines fractional units as decimals.\n */\ncontract FractionalERC20 is ERC20 {\n\n  uint8 public decimals;\n\n}\n\n/**\n * Originally from  https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Math operations with safety checks\n */\nlibrary SafeMath {\n  function mul(uint a, uint b) internal constant returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint a, uint b) internal constant returns (uint) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint a, uint b) internal constant returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint a, uint b) internal constant returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint a, uint b) internal constant returns (uint) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint a, uint b) internal constant returns (uint) {\n    return a < b ? a : b;\n  }\n}\n\n// Interface for burning tokens\ncontract Burnable {\n  // @dev Destroys tokens for an account\n  // @param account Account whose tokens are destroyed\n  // @param value Amount of tokens to destroy\n  function burnTokens(address account, uint value) internal;\n  event Burned(address account, uint value);\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n/**\n * Internal interface for the minting of tokens.\n */\ncontract Mintable {\n\n  /**\n   * @dev Mints tokens for an account\n   */\n  function mintInternal(address receiver, uint amount) internal;\n\n  /** Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n}\n\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances. \n */\ncontract BasicToken is ERC20Basic, Burnable, Mintable {\n  using SafeMath for uint;\n\n  mapping(address => uint) balances;\n\n  /**\n   * Obsolete. Removed this check based on:\n   * https://blog.coinfabrik.com/smart-contract-short-address-attack-mitigation-failure/\n   * @dev Fix for the ERC20 short address attack.\n   *\n   * modifier onlyPayloadSize(uint size) {\n   *    require(msg.data.length >= size + 4);\n   *    _;\n   * }\n   */\n\n  /**\n   * @dev transfer token for a specified address\n   * @param to The address to transfer to.\n   * @param value The amount to be transferred.\n   */\n  function transfer(address to, uint value) public returns (bool success) {\n    balances[msg.sender] = balances[msg.sender].sub(value);\n    balances[to] = balances[to].add(value);\n    Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Gets the balance of the specified address.\n   * @param account The address whose balance is to be queried.\n   * @return An uint representing the amount owned by the passed address.\n   */\n  function balanceOf(address account) public constant returns (uint balance) {\n    return balances[account];\n  }\n\n  /**\n   * @dev Provides an internal function for destroying tokens. Useful for upgrades.\n   */\n  function burnTokens(address account, uint value) internal {\n    balances[account] = balances[account].sub(value);\n    totalSupply = totalSupply.sub(value);\n    Burned(account, value);\n  }\n\n  /**\n   * @dev Provides an internal minting function.\n   */\n  function mintInternal(address receiver, uint amount) internal {\n    totalSupply = totalSupply.add(amount);\n    balances[receiver] = balances[receiver].add(amount);\n  }\n  \n}\n\n/**\n * Originally by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n * Modified by https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n */\ncontract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint value) public returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n    allowed[msg.sender][spender] = value;\n    Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public constant returns (uint remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint addedValue) public\n  returns (bool success) {\n      uint oldValue = allowed[msg.sender][spender];\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint subtractedValue) public\n  returns (bool success) {\n\n      uint oldVal = allowed[msg.sender][spender];\n\n      if (subtractedValue > oldVal) {\n          allowed[msg.sender][spender] = 0;\n      } else {\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n      }\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n  \n}\n\n// SWC-135-Code With No Effects\n/**\n * Originally from https://github.com/OpenZeppelin/zeppelin-solidity\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control \n * functions, this simplifies the implementation of \"user permissions\". \n */\ncontract Ownable {\n  address public owner;\n\n\n  /** \n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() internal {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner. \n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to. \n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    owner = newOwner;\n  }\n\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * Define interface for releasing the token transfer after a successful crowdsale.\n */\ncontract ReleasableToken is StandardToken, Ownable {\n\n  /* The finalizer contract that allows lifting the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Since the owner of this contract is (or should be) the crowdsale,\n   * it can only be called by a corresponding exposed API in the crowdsale contract in case of input error.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (e.g. a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens into the wild.\n   *\n   * Can be called only from the release agent that should typically be the finalize agent ICO contract.\n   * In the scope of the crowdsale, it is only called if the crowdsale has been a success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   */\n  modifier canTransfer(address sender) {\n    require(released || transferAgents[sender]);\n    _;\n  }\n\n  /** The function can be called only before or after the tokens have been released */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  /** We restrict transfer by overriding it */\n  function transfer(address to, uint value) public canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(to, value);\n  }\n\n  /** We restrict transferFrom by overriding it */\n  function transferFrom(address from, address to, uint value) public canTransfer(from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(from, to, value);\n  }\n\n}\n\n/**\n * Inspired by Lunyr.\n * Originally from https://github.com/TokenMarketNet/ico\n */\n/**\n * Upgrade agent transfers tokens to a new contract.\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\n *\n * The Upgrade agent is the interface used to implement a token\n * migration in the case of an emergency.\n * The function upgradeFrom has to implement the part of the creation\n * of new tokens on behalf of the user doing the upgrade.\n *\n * The new token can implement this interface directly, or use.\n */\ncontract UpgradeAgent {\n\n  /** This value should be the same as the original token's total supply */\n  uint public originalSupply;\n\n  /** Interface to ensure the contract is correctly configured */\n  function isUpgradeAgent() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n  Upgrade an account\n\n  When the token contract is in the upgrade status the each user will\n  have to call `upgrade(value)` function from UpgradeableToken.\n\n  The upgrade function adjust the balance of the user and the supply\n  of the previous token and then call `upgradeFrom(value)`.\n\n  The UpgradeAgent is the responsible to create the tokens for the user\n  in the new contract.\n\n  * @param from Account to upgrade.\n  * @param value Tokens to upgrade.\n\n  */\n  function upgradeFrom(address from, uint value) public;\n\n}\n\n/**\n * First envisioned by Golem and Lunyr projects.\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\n *\n */\ncontract UpgradeableToken is ERC20Basic, Burnable {\n  using SafeMath for uint;\n\n  /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */\n  address public upgradeMaster;\n\n  /** The next contract where the tokens will be migrated. */\n  UpgradeAgent public upgradeAgent;\n\n  /** How many tokens we have upgraded by now. */\n  uint public totalUpgraded = 0;\n\n  /**\n   * Upgrade states.\n   *\n   * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\n   * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\n   * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet. This allows changing the upgrade agent while there is time.\n   * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\n   *\n   */\n  enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\n\n  /**\n   * Somebody has upgraded some of his tokens.\n   */\n  event Upgrade(address indexed from, address to, uint value);\n\n  /**\n   * New upgrade agent available.\n   */\n  event UpgradeAgentSet(address agent);\n\n  /**\n   * Do not allow construction without upgrade master set.\n   */\n  function UpgradeableToken(address master) internal {\n    setUpgradeMaster(master);\n  }\n\n  /**\n   * Allow the token holder to upgrade some of their tokens to a new contract.\n   */\n  function upgrade(uint value) public {\n    UpgradeState state = getUpgradeState();\n    // Ensure it's not called in a bad state\n    require(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading);\n\n    // Validate input value.\n    require(value != 0);\n\n    // Upgrade agent reissues the tokens\n    upgradeAgent.upgradeFrom(msg.sender, value);\n    \n    // Take tokens out from circulation\n    burnTokens(msg.sender, value);\n    totalUpgraded = totalUpgraded.add(value);\n\n    Upgrade(msg.sender, upgradeAgent, value);\n  }\n\n  /**\n   * Set an upgrade agent that handles the upgrade process\n   */\n  function setUpgradeAgent(address agent) onlyMaster external {\n    // Check whether the token is in a state that we could think of upgrading\n    require(canUpgrade());\n\n    require(agent != 0x0);\n    // Upgrade has already begun for an agent\n    require(getUpgradeState() != UpgradeState.Upgrading);\n\n    upgradeAgent = UpgradeAgent(agent);\n\n    // Bad interface\n    require(upgradeAgent.isUpgradeAgent());\n    // Make sure that token supplies match in source and target\n    require(upgradeAgent.originalSupply() == totalSupply);\n\n    UpgradeAgentSet(upgradeAgent);\n  }\n\n  /**\n   * Get the state of the token upgrade.\n   */\n  function getUpgradeState() public constant returns(UpgradeState) {\n    if (!canUpgrade()) return UpgradeState.NotAllowed;\n    else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\n    else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\n    else return UpgradeState.Upgrading;\n  }\n\n  /**\n   * Change the upgrade master.\n   *\n   * This allows us to set a new owner for the upgrade mechanism.\n   */\n  function changeUpgradeMaster(address new_master) onlyMaster public {\n    setUpgradeMaster(new_master);\n  }\n\n  /**\n   * Internal upgrade master setter.\n   */\n  function setUpgradeMaster(address new_master) private {\n    require(new_master != 0x0);\n    upgradeMaster = new_master;\n  }\n\n  /**\n   * Child contract can override to provide the condition in which the upgrade can begin.\n   */\n  function canUpgrade() public constant returns(bool) {\n     return true;\n  }\n\n\n  modifier onlyMaster() {\n    require(msg.sender == upgradeMaster);\n    _;\n  }\n}\n\n/**\n * Authored by https://www.coinfabrik.com/\n */\n// This contract aims to provide an inheritable way to recover tokens from a contract not meant to hold tokens\n// To use this contract, have your token-ignoring contract inherit this one and implement getLostAndFoundMaster to decide who can move lost tokens.\n// Of course, this contract imposes support costs upon whoever is the lost and found master.\ncontract LostAndFoundToken {\n  /**\n   * @return Address of the account that handles movements.\n   */\n  function getLostAndFoundMaster() internal constant returns (address);\n\n  /**\n   * @param agent Address that will be able to move tokens with transferFrom\n   * @param tokens Amount of tokens approved for transfer\n   * @param token_contract Contract of the token\n   */\n  function enableLostAndFound(address agent, uint tokens, ERC20 token_contract) public {\n    require(msg.sender == getLostAndFoundMaster());\n    token_contract.approve(agent, tokens);\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A token that can increase its supply by another contract.\n *\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\n *\n */\ncontract MintableToken is ERC20Basic, Mintable, Ownable {\n\n  using SafeMath for uint;\n\n  bool public mintingFinished = false;\n\n  /** List of agents that are allowed to create new tokens */\n  mapping (address => bool) public mintAgents;\n\n  event MintingAgentChanged(address addr, bool state);\n\n\n  function MintableToken(uint initialSupply, address multisig, bool mintable) internal {\n    require(multisig != address(0));\n    // Cannot create a token without supply and no minting\n    require(mintable || initialSupply != 0);\n    // Create initially all balance on the team multisig\n    if (initialSupply > 0)\n        mintInternal(multisig, initialSupply);\n    // No more new supply allowed after the token creation\n    mintingFinished = !mintable;\n  }\n\n  /**\n   * Create new tokens and allocate them to an address.\n   *\n   * Only callable by a mint agent (e.g. crowdsale contract).\n   */\n  function mint(address receiver, uint amount) onlyMintAgent canMint public {\n    mintInternal(receiver, amount);\n\n    // TODO: Remove this. It may be confused with anonymous transfers in the upcoming fork.\n    // This will make the mint transaction appear in EtherScan.io\n    // We can remove this after there is a standardized minting event\n    Transfer(0, receiver, amount);\n\n    Minted(receiver, amount);\n  }\n\n  /**\n   * Owner can allow a crowdsale contract to mint new tokens.\n   */\n  function setMintAgent(address addr, bool state) onlyOwner canMint public {\n    mintAgents[addr] = state;\n    MintingAgentChanged(addr, state);\n  }\n\n  modifier onlyMintAgent() {\n    // Only mint agents are allowed to mint new tokens\n    require(mintAgents[msg.sender]);\n    _;\n  }\n\n  /** Make sure we are not done yet. */\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n}\n\n/**\n * Originally from https://github.com/TokenMarketNet/ico\n * Modified by https://www.coinfabrik.com/\n */\n/**\n * A crowdsale token.\n *\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\n *\n * - The token transfer() is disabled until the crowdsale is over\n * - The token contract gives an opt-in upgrade path to a new contract\n * - The same token can be part of several crowdsales through the approve() mechanism\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\n * - ERC20 tokens transferred to this contract can be recovered by a lost and found master\n *\n */\ncontract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\npragma experimental ABIEncoderV2;\n\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract LibEIP712 {\n    // EIP191 header for EIP712 prefix\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    // EIP712 Domain Name value\n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\n\n    // EIP712 Domain Version value\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\n\n    // Hash of the EIP712 Domain Separator Schema\n    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 Domain Separator data\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor ()\n        public\n    {\n        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            address(this)\n        ));\n    }\n\n    \n    \n    \n    function hashEIP712Message(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(EIP191_HEADER, EIP712_DOMAIN_HASH, hashStruct));\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract LibOrder is\n    LibEIP712 {\n\n    // Hash for the EIP712 Order Schema\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"Order(\",\n        \"address makerAddress,\",\n        \"address takerAddress,\",\n        \"address feeRecipientAddress,\",\n        \"address senderAddress,\",\n        \"uint256 makerAssetAmount,\",\n        \"uint256 takerAssetAmount,\",\n        \"uint256 makerFee,\",\n        \"uint256 takerFee,\",\n        \"uint256 expirationTimeSeconds,\",\n        \"uint256 salt,\",\n        \"bytes makerAssetData,\",\n        \"bytes takerAssetData\",\n        \")\"\n    ));\n\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n    // An order's state is unaffected by external factors, like account balances.\n    enum OrderStatus {\n        INVALID,                     // Default value\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n        FILLABLE,                    // Order is fillable\n        EXPIRED,                     // Order has already expired\n        FULLY_FILLED,                // Order is fully filled\n        CANCELLED                    // Order has been cancelled\n    }\n\n    // solhint-disable max-line-length\n    struct Order {\n        address makerAddress;           // Address that created the order.      \n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n    }\n    // solhint-enable max-line-length\n\n    struct OrderInfo {\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n    \n    \n    \n    function getOrderHash(Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        orderHash = hashEIP712Message(hashOrder(order));\n        return orderHash;\n    }\n\n    \n    \n    \n    function hashOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encode(\n        //     order.makerAddress,\n        //     order.takerAddress,\n        //     order.feeRecipientAddress,\n        //     order.senderAddress,\n        //     order.makerAssetAmount,\n        //     order.takerAssetAmount,\n        //     order.makerFee,\n        //     order.takerFee,\n        //     order.expirationTimeSeconds,\n        //     order.salt,\n        //     keccak256(order.makerAssetData),\n        //     keccak256(order.takerAssetData)\n        // ));\n\n        assembly {\n            // Backup\n            // solhint-disable-next-line space-after-comma\n            let temp1 := mload(sub(order,  32))\n            let temp2 := mload(add(order, 320))\n            let temp3 := mload(add(order, 352))\n            \n            // Hash in place\n            // solhint-disable-next-line space-after-comma\n            mstore(sub(order,  32), schemaHash)\n            mstore(add(order, 320), makerAssetDataHash)\n            mstore(add(order, 352), takerAssetDataHash)\n            result := keccak256(sub(order, 32), 416)\n            \n            // Restore\n            // solhint-disable-next-line space-after-comma\n            mstore(sub(order,  32), temp1)\n            mstore(add(order, 320), temp2)\n            mstore(add(order, 352), temp3)\n        }\n        return result;\n    }\n}\n\ncontract SafeMath {\n    function safeMul(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(\n            c / a == b,\n            \"UINT256_OVERFLOW\"\n        );\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        require(\n            b <= a,\n            \"UINT256_UNDERFLOW\"\n        );\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 c = a + b;\n        require(\n            c >= a,\n            \"UINT256_OVERFLOW\"\n        );\n        return c;\n    }\n\n    function max64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min64(uint64 a, uint64 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n\n    function max256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a >= b ? a : b;\n    }\n\n    function min256(uint256 a, uint256 b)\n        internal\n        pure\n        returns (uint256)\n    {\n        return a < b ? a : b;\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract LibFillResults is\n    SafeMath {\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\n    }\n\n    struct MatchedFillResults {\n        FillResults left;                    // Amounts filled and fees paid of left order.\n        FillResults right;                   // Amounts filled and fees paid of right order.\n        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order's makerAsset, paid to taker.\n    }\n\n    \n    \n    \n    \n    function addFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\n        internal\n        pure\n    {\n        totalFillResults.makerAssetFilledAmount = safeAdd(totalFillResults.makerAssetFilledAmount, singleFillResults.makerAssetFilledAmount);\n        totalFillResults.takerAssetFilledAmount = safeAdd(totalFillResults.takerAssetFilledAmount, singleFillResults.takerAssetFilledAmount);\n        totalFillResults.makerFeePaid = safeAdd(totalFillResults.makerFeePaid, singleFillResults.makerFeePaid);\n        totalFillResults.takerFeePaid = safeAdd(totalFillResults.takerFeePaid, singleFillResults.takerFeePaid);\n    }\n}\n\n/*\n\n  Copyright 2018 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract IExchangeCore {\n\n    \n    \n    \n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\n        external;\n\n    \n    \n    \n    \n    \n    function fillOrder(\n        LibOrder.Order memory order,\n        uint256 takerAssetFillAmount,\n        bytes memory signature\n    )\n        public\n        returns (LibFillResults.FillResults memory fillResults);\n\n    \n    \n    function cancelOrder(LibOrder.Order memory order)\n        public;\n\n    \n    \n    \n    \n    function getOrderInfo(LibOrder.Order memory order)\n        public\n        view\n        returns (LibOrder.OrderInfo memory orderInfo);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IExchangeCore.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "**Answer:** No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\ncontract Ownable {\n    address private _contract_owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = msg.sender;\n        _contract_owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _contract_owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_contract_owner == msg.sender, \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_contract_owner, newOwner);\n        _contract_owner = newOwner;\n    }\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\nlibrary AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}\n\ncontract ApproveAndCallFallBack {\n    function receiveApproval(\n        address from,\n        uint256 _amount,\n        address _token,\n        bytes memory _data\n    ) public;\n}\n\ncontract TransferEventCallBack {\n  function onTransfer(address _from, address _to, uint256 _amount) public;\n}\n\ncontract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}\n\nlibrary SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}\n\ncontract TokenInterface {\n  function destroyTokens(address _owner, uint _amount) public returns(bool);\n  function generateTokens(address _owner, uint _amount) public returns(bool);\n}\n\ncontract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Block Number Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-b1bbcf88cc3f49e5d67954003313ede4520ba00a/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-b1bbcf88cc3f49e5d67954003313ede4520ba00a/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-b1bbcf88cc3f49e5d67954003313ede4520ba00a/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-b1bbcf88cc3f49e5d67954003313ede4520ba00a/legacy/common/Pausable.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\ncontract ProjectWallet {\n\n    function transfer(address _receiver, uint256 _amt) public returns (bool);\n\n}\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender) public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract BasicProjectWallet is ProjectWallet {\n\n    address private token;\n    address private authoriser;\n    bytes32 public name;\n\n  /**\n   * @dev Constructor\n   * @param _token address The ixo token address\n   * @param _authoriser address The address of the contract that\n   * @param _name bytes32 The project name\n   */\n    constructor(address _token, address _authoriser, bytes32 _name) public {\n        token = _token;\n        authoriser = _authoriser;\n        name = _name;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Transfer tokens to the receiver\n   * @param _receiver The address which will receive the funds.\n   * @param _amt The amount of tokens to transfer.\n   */\n    function transfer(\n        address _receiver,\n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        ERC20(token).transfer(_receiver, _amt);\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/BasicProjectWallet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\ncontract ProjectWallet {\n\n    function transfer(address _receiver, uint256 _amt) public returns (bool);\n\n}\n\ncontract ERC20 {\n    function totalSupply() public view returns (uint256);\n\n    function balanceOf(address _who) public view returns (uint256);\n\n    function allowance(address _owner, address _spender) public view returns (uint256);\n\n    function transfer(address _to, uint256 _value) public returns (bool);\n\n    function approve(address _spender, uint256 _value) public returns (bool);\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\n\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 value\n    );\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\ncontract BasicProjectWallet is ProjectWallet {\n\n    address private token;\n    address private authoriser;\n    bytes32 public name;\n\n  /**\n   * @dev Constructor\n   * @param _token address The ixo token address\n   * @param _authoriser address The address of the contract that\n   * @param _name bytes32 The project name\n   */\n    constructor(address _token, address _authoriser, bytes32 _name) public {\n        token = _token;\n        authoriser = _authoriser;\n        name = _name;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Transfer tokens to the receiver\n   * @param _receiver The address which will receive the funds.\n   * @param _amt The amount of tokens to transfer.\n   */\n    function transfer(\n        address _receiver,\n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        ERC20(token).transfer(_receiver, _amt);\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/BasicProjectWallet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// https://docs.synthetix.io/contracts/LimitedSetup\ncontract LimitedSetup {\n    uint setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration) public {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract State is Owned {\n    address public associatedContract;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n/**\n * @notice  This contract is based on the code available from this blog\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\n * and extensible option. This ensures data schema changes can be implemented without\n * requiring upgrades to the storage contract.\n */\n// https://docs.synthetix.io/contracts/EternalStorage\ncontract EternalStorage is State {\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== DATA TYPES ========== */\n    mapping(bytes32 => uint) UIntStorage;\n    mapping(bytes32 => string) StringStorage;\n    mapping(bytes32 => address) AddressStorage;\n    mapping(bytes32 => bytes) BytesStorage;\n    mapping(bytes32 => bytes32) Bytes32Storage;\n    mapping(bytes32 => bool) BooleanStorage;\n    mapping(bytes32 => int) IntStorage;\n\n    // UIntStorage;\n    function getUIntValue(bytes32 record) external view returns (uint) {\n        return UIntStorage[record];\n    }\n\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\n        UIntStorage[record] = value;\n    }\n\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\n        delete UIntStorage[record];\n    }\n\n    // StringStorage\n    function getStringValue(bytes32 record) external view returns (string memory) {\n        return StringStorage[record];\n    }\n\n    function setStringValue(bytes32 record, string value) external onlyAssociatedContract {\n        StringStorage[record] = value;\n    }\n\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\n        delete StringStorage[record];\n    }\n\n    // AddressStorage\n    function getAddressValue(bytes32 record) external view returns (address) {\n        return AddressStorage[record];\n    }\n\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\n        AddressStorage[record] = value;\n    }\n\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\n        delete AddressStorage[record];\n    }\n\n    // BytesStorage\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\n        return BytesStorage[record];\n    }\n\n    function setBytesValue(bytes32 record, bytes value) external onlyAssociatedContract {\n        BytesStorage[record] = value;\n    }\n\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\n        delete BytesStorage[record];\n    }\n\n    // Bytes32Storage\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\n        return Bytes32Storage[record];\n    }\n\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\n        Bytes32Storage[record] = value;\n    }\n\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\n        delete Bytes32Storage[record];\n    }\n\n    // BooleanStorage\n    function getBooleanValue(bytes32 record) external view returns (bool) {\n        return BooleanStorage[record];\n    }\n\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\n        BooleanStorage[record] = value;\n    }\n\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\n        delete BooleanStorage[record];\n    }\n\n    // IntStorage\n    function getIntValue(bytes32 record) external view returns (int) {\n        return IntStorage[record];\n    }\n\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\n        IntStorage[record] = value;\n    }\n\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\n        delete IntStorage[record];\n    }\n}\n\n// https://docs.synthetix.io/contracts/FeePoolEternalStorage\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n    bytes32 constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    /**\n     * @dev Constructor.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\n\n    /**\n     * @notice Import data from FeePool.lastFeeWithdrawal\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\n     * @param accounts Array of addresses that have claimed\n     * @param feePeriodIDs Array feePeriodIDs with the accounts last claim\n     */\n    function importFeeWithdrawalData(address[] accounts, uint[] feePeriodIDs) external onlyOwner onlyDuringSetup {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/FeePoolEternalStorage.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n  function approve(address to, uint256 tokenId) public;\n  function getApproved(uint256 tokenId)\n    public view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) public;\n  function isApprovedForAll(address owner, address operator)\n    public view returns (bool);\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n    public;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes data\n  )\n    public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safeTransfer`. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes data\n  )\n    public\n    returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    internal\n  {\n    _registerInterface(_InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev internal method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n  function name() external view returns (string);\n  function symbol() external view returns (string);\n  function tokenURI(uint256 tokenId) external view returns (string);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n  function approve(address to, uint256 tokenId) public;\n  function getApproved(uint256 tokenId)\n    public view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) public;\n  function isApprovedForAll(address owner, address operator)\n    public view returns (bool);\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n    public;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes data\n  )\n    public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safeTransfer`. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes data\n  )\n    public\n    returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    internal\n  {\n    _registerInterface(_InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev internal method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n  function name() external view returns (string);\n  function symbol() external view returns (string);\n  function tokenURI(uint256 tokenId) external view returns (string);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n  function approve(address to, uint256 tokenId) public;\n  function getApproved(uint256 tokenId)\n    public view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) public;\n  function isApprovedForAll(address owner, address operator)\n    public view returns (bool);\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n    public;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes data\n  )\n    public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safeTransfer`. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes data\n  )\n    public\n    returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    internal\n  {\n    _registerInterface(_InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev internal method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n  function name() external view returns (string);\n  function symbol() external view returns (string);\n  function tokenURI(uint256 tokenId) external view returns (string);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n  function approve(address to, uint256 tokenId) public;\n  function getApproved(uint256 tokenId)\n    public view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) public;\n  function isApprovedForAll(address owner, address operator)\n    public view returns (bool);\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n    public;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes data\n  )\n    public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safeTransfer`. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes data\n  )\n    public\n    returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    internal\n  {\n    _registerInterface(_InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev internal method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n  function name() external view returns (string);\n  function symbol() external view returns (string);\n  function tokenURI(uint256 tokenId) external view returns (string);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n  function approve(address to, uint256 tokenId) public;\n  function getApproved(uint256 tokenId)\n    public view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) public;\n  function isApprovedForAll(address owner, address operator)\n    public view returns (bool);\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n    public;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes data\n  )\n    public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safeTransfer`. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes data\n  )\n    public\n    returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    internal\n  {\n    _registerInterface(_InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev internal method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n  function name() external view returns (string);\n  function symbol() external view returns (string);\n  function tokenURI(uint256 tokenId) external view returns (string);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721 is IERC165 {\n\n  event Transfer(\n    address indexed from,\n    address indexed to,\n    uint256 indexed tokenId\n  );\n  event Approval(\n    address indexed owner,\n    address indexed approved,\n    uint256 indexed tokenId\n  );\n  event ApprovalForAll(\n    address indexed owner,\n    address indexed operator,\n    bool approved\n  );\n\n  function balanceOf(address owner) public view returns (uint256 balance);\n  function ownerOf(uint256 tokenId) public view returns (address owner);\n\n  function approve(address to, uint256 tokenId) public;\n  function getApproved(uint256 tokenId)\n    public view returns (address operator);\n\n  function setApprovalForAll(address operator, bool _approved) public;\n  function isApprovedForAll(address owner, address operator)\n    public view returns (bool);\n\n  function transferFrom(address from, address to, uint256 tokenId) public;\n  function safeTransferFrom(address from, address to, uint256 tokenId)\n    public;\n\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes data\n  )\n    public;\n}\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   * after a `safeTransfer`. This function MUST return the function selector,\n   * otherwise the caller will revert the transaction. The selector to be\n   * returned can be obtained as `this.onERC721Received.selector`. This\n   * function MAY throw to revert and reject the transfer.\n   * Note: the ERC721 contract address is always the message sender.\n   * @param operator The address which called `safeTransferFrom` function\n   * @param from The address which previously owned the token\n   * @param tokenId The NFT identifier which is being transferred\n   * @param data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes data\n  )\n    public\n    returns(bytes4);\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   * as the code is not actually created until after the constructor finishes.\n   * @param account address of the account to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address account) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    // solium-disable-next-line security/no-inline-assembly\n    assembly { size := extcodesize(account) }\n    return size > 0;\n  }\n\n}\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n\n  bytes4 private constant _InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    internal\n  {\n    _registerInterface(_InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev internal method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract IERC721Metadata is IERC721 {\n  function name() external view returns (string);\n  function symbol() external view returns (string);\n  function tokenURI(uint256 tokenId) external view returns (string);\n}\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  \n  uint256 private _guardCounter;\n\n  constructor() internal {\n    // The counter starts at one to prevent changing it from zero to a non-zero\n    // value, which is a more expensive operation.\n    _guardCounter = 1;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and make it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}\n\ncontract ReentrancyAttack {\n\n  function callSender(bytes4 data) public {\n    // solium-disable-next-line security/no-low-level-calls\n    require(msg.sender.call(abi.encodeWithSelector(data)));\n  }\n\n}\n\ncontract ReentrancyMock is ReentrancyGuard {\n\n  uint256 public counter;\n\n  constructor() public {\n    counter = 0;\n  }\n\n  function callback() external nonReentrant {\n    count();\n  }\n\n  function countLocalRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      countLocalRecursive(n - 1);\n    }\n  }\n\n  function countThisRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      // solium-disable-next-line security/no-low-level-calls\n      bool result = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n      require(result == true);\n    }\n  }\n\n  function countAndCall(ReentrancyAttack attacker) public nonReentrant {\n    count();\n    bytes4 func = bytes4(keccak256(\"callback()\"));\n    attacker.callSender(func);\n  }\n\n  function count() private {\n    counter += 1;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/blockchain/source/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/blockchain/source/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/blockchain/source/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    }
]