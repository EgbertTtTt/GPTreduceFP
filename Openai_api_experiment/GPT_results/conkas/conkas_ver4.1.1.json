[
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Final Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "emergencyWithdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Final Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "0x27a59fb8",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Final Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "withdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Final Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenTranchePricing is Ownable {\n\n  using SafeMath for uint;\n\n  /**\n   * Define pricing schedule using tranches.\n   */\n  struct Tranche {\n      // Amount in tokens when this tranche becomes inactive\n      uint amount;\n      // Block interval [start, end)\n      // Starting block (included in the interval)\n      uint start;\n      // Ending block (excluded from the interval)\n      uint end;\n      // How many tokens per wei you will get while this tranche is active\n      uint price;\n  }\n  // We define offsets and size for the deserialization of ordered tuples in raw arrays\n  uint private constant amount_offset = 0;\n  uint private constant start_offset = 1;\n  uint private constant end_offset = 2;\n  uint private constant price_offset = 3;\n  uint private constant tranche_size = 4;\n\n  Tranche[] public tranches;\n  // SWC-101-Integer Overflow and Underflow: L45-69\n  \n  \n  function TokenTranchePricing(uint[] init_tranches) public {\n    // Need to have tuples, length check\n    require(init_tranches.length % tranche_size == 0);\n    // A tranche with amount zero can never be selected and is therefore useless.\n    // This check and the one inside the loop ensure no tranche can have an amount equal to zero.\n    require(init_tranches[amount_offset] > 0);\n\n    tranches.length = init_tranches.length / tranche_size;\n    for (uint i = 0; i < init_tranches.length / tranche_size; i++) {\n      // No invalid steps\n      uint amount = init_tranches[i * tranche_size + amount_offset];\n      uint start = init_tranches[i * tranche_size + start_offset];\n      uint end = init_tranches[i * tranche_size + end_offset];\n      require(block.number < start && start < end);\n      // Bail out when entering unnecessary tranches\n      // This is preferably checked before deploying contract into any blockchain.\n      require(i == 0 || (end >= tranches[i - 1].end && amount > tranches[i - 1].amount) ||\n              (end > tranches[i - 1].end && amount >= tranches[i - 1].amount));\n\n      tranches[i].amount = amount;\n      tranches[i].price = init_tranches[i * tranche_size + price_offset];\n      tranches[i].start = start;\n      tranches[i].end = end;\n    }\n  }\n\n  \n  \n  \n  function getCurrentTranche(uint tokensSold) private constant returns (Tranche) {\n    for (uint i = 0; i < tranches.length; i++) {\n      if (tranches[i].start <= block.number && block.number < tranches[i].end && tokensSold < tranches[i].amount) {\n        return tranches[i];\n      }\n    }\n    // No tranche is currently active\n    revert();\n  }\n\n  \n  \n  \n  function getCurrentPrice(uint tokensSold) public constant returns (uint result) {\n    return getCurrentTranche(tokensSold).price;\n  }\n\n}",
        "function": "tranches(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/TokenTranchePricing.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "owners(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "addOwner(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "sendTokens(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "addOwner(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "removeOwner(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "owners(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "addOwner(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "addOwner(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract MixinAssetProxyDispatcher is\n    Ownable,\n    MAssetProxyDispatcher {\n    // SWC-135-Code With No Effects: L32\n    using LibBytes for bytes;\n    \n    // Mapping from Asset Proxy Id's to their respective Asset Proxy\n    mapping (bytes4 => IAssetProxy) public assetProxies;\n\n    \n    \n    \n    function registerAssetProxy(address assetProxy)\n        external\n        onlyOwner\n    {\n        IAssetProxy assetProxyContract = IAssetProxy(assetProxy);\n\n        // Ensure that no asset proxy exists with current id.\n        bytes4 assetProxyId = assetProxyContract.getProxyId();\n        address currentAssetProxy = assetProxies[assetProxyId];\n        require(\n            currentAssetProxy == address(0),\n            \"ASSET_PROXY_ALREADY_EXISTS\"\n        );\n\n        // Add asset proxy and log registration.\n        assetProxies[assetProxyId] = assetProxyContract;\n        emit AssetProxyRegistered(\n            assetProxyId,\n            assetProxy\n        );\n    }\n\n    \n    \n    \n    function getAssetProxy(bytes4 assetProxyId)\n        external\n        view\n        returns (address)\n    {\n        return assetProxies[assetProxyId];\n    }\n\n    \n    \n    \n    \n    \n    function dispatchTransferFrom(\n        bytes memory assetData,\n        address from,\n        address to,\n        uint256 amount\n    )\n        internal\n    {\n        // Do nothing if no amount should be transferred.\n        if (amount > 0) {\n            // Ensure assetData length is valid\n            require(\n                assetData.length > 3,\n                \"LENGTH_GREATER_THAN_3_REQUIRED\"\n            );\n            \n            // Lookup assetProxy\n            bytes4 assetProxyId;\n            assembly {\n                assetProxyId := and(mload(\n                    add(assetData, 32)),\n                    0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n                )\n            }\n            address assetProxy = assetProxies[assetProxyId];\n\n            // Ensure that assetProxy exists\n            require(\n                assetProxy != address(0),\n                \"ASSET_PROXY_DOES_NOT_EXIST\"\n            );\n            \n            // We construct calldata for the `assetProxy.transferFrom` ABI.\n            // The layout of this calldata is in the table below.\n            // \n            // | Area     | Offset | Length  | Contents                                    |\n            // | -------- |--------|---------|-------------------------------------------- |\n            // | Header   | 0      | 4       | function selector                           |\n            // | Params   |        | 4 * 32  | function parameters:                        |\n            // |          | 4      |         |   1. offset to assetData (*)                |\n            // |          | 36     |         |   2. from                                   |\n            // |          | 68     |         |   3. to                                     |\n            // |          | 100    |         |   4. amount                                 |\n            // | Data     |        |         | assetData:                                  |\n            // |          | 132    | 32      | assetData Length                            |\n            // |          | 164    | **      | assetData Contents                          |\n\n            assembly {\n                \n                // `cdStart` is the start of the calldata for `assetProxy.transferFrom` (equal to free memory ptr).\n                let cdStart := mload(64)\n                // `dataAreaLength` is the total number of words needed to store `assetData`\n                //  As-per the ABI spec, this value is padded up to the nearest multiple of 32,\n                //  and includes 32-bytes for length.\n                let dataAreaLength := and(add(mload(assetData), 63), 0xFFFFFFFFFFFE0)\n                // `cdEnd` is the end of the calldata for `assetProxy.transferFrom`.\n                let cdEnd := add(cdStart, add(132, dataAreaLength))\n\n                \n                \n                // This area holds the 4-byte `transferFromSelector`.\n                // bytes4(keccak256(\"transferFrom(bytes,address,address,uint256)\")) = 0xa85e59e4\n                mstore(cdStart, 0xa85e59e400000000000000000000000000000000000000000000000000000000)\n                \n                \n                // Each parameter is padded to 32-bytes. The entire Params Area is 128 bytes.\n                // Notes:\n                //   1. The offset to `assetData` is the length of the Params Area (128 bytes).\n                //   2. A 20-byte mask is applied to addresses to zero-out the unused bytes.\n                mstore(add(cdStart, 4), 128)\n                mstore(add(cdStart, 36), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 68), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\n                mstore(add(cdStart, 100), amount)\n                \n                \n                // This area holds `assetData`.\n                let dataArea := add(cdStart, 132)\n                // solhint-disable-next-line no-empty-blocks\n                for {} lt(dataArea, cdEnd) {} {\n                    mstore(dataArea, mload(assetData))\n                    dataArea := add(dataArea, 32)\n                    assetData := add(assetData, 32)\n                }\n\n                \n                let success := call(\n                    gas,                    // forward all gas\n                    assetProxy,             // call address of asset proxy\n                    0,                      // don't send any ETH\n                    cdStart,                // pointer to start of input\n                    sub(cdEnd, cdStart),    // length of input  \n                    cdStart,                // write output over input\n                    512                     // reserve 512 bytes for output\n                )\n                if iszero(success) {\n                    revert(cdStart, returndatasize())\n                }\n            }\n        }\n    }\n}",
        "function": "registerAssetProxy(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/MixinAssetProxyDispatcher.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenLockable is RpSafeMath, Ownable {\n    mapping(address => uint256) public lockedTokens;\n\n    /**\n        @dev Locked tokens cannot be withdrawn using the withdrawTokens function.\n    */\n    function lockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeAdd(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Unlocks previusly locked tokens.\n    */\n    function unlockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Withdraws tokens from the contract.\n\n        @param token Token to withdraw\n        @param to Destination of the tokens\n        @param amount Amount to withdraw \n    */\n    function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\n        require(to != address(0));\n        return token.transfer(to, amount);\n    }\n}",
        "function": "withdrawTokens(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenLockable is RpSafeMath, Ownable {\n    mapping(address => uint256) public lockedTokens;\n\n    /**\n        @dev Locked tokens cannot be withdrawn using the withdrawTokens function.\n    */\n    function lockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeAdd(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Unlocks previusly locked tokens.\n    */\n    function unlockTokens(address token, uint256 amount) internal {\n        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\n    }\n\n    /**\n        @dev Withdraws tokens from the contract.\n\n        @param token Token to withdraw\n        @param to Destination of the tokens\n        @param amount Amount to withdraw \n    */\n    function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\n        require(to != address(0));\n        return token.transfer(to, amount);\n    }\n}",
        "function": "withdrawTokens(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Controller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public governance;\n    address public strategist;\n\n    address public onesplit;\n    address public rewards;\n    mapping(address => address) public vaults;\n    mapping(address => address) public strategies;\n    mapping(address => mapping(address => address)) public converters;\n\n    mapping(address => mapping(address => bool)) public approvedStrategies;\n\n    uint public split = 500;\n    uint public constant max = 10000;\n\n    constructor(address _rewards) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n        rewards = _rewards;\n    }\n\n    function setRewards(address _rewards) public {\n        require(msg.sender == governance, \"!governance\");\n        rewards = _rewards;\n    }\n\n    function setStrategist(address _strategist) public {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setSplit(uint _split) public {\n        require(msg.sender == governance, \"!governance\");\n        split = _split;\n    }\n\n    function setOneSplit(address _onesplit) public {\n        require(msg.sender == governance, \"!governance\");\n        onesplit = _onesplit;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setVault(address _token, address _vault) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n    }\n\n    function approveStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    function revokeStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    function setConverter(address _input, address _output, address _converter) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        converters[_input][_output] = _converter;\n    }\n\n    function setStrategy(address _token, address _strategy) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(approvedStrategies[_token][_strategy] == true, \"!approved\");\n\n        address _current = strategies[_token];\n        if (_current != address(0)) {\n            Strategy(_current).withdrawAll();\n        }\n        strategies[_token] = _strategy;\n    }\n\n    function earn(address _token, uint _amount) public {\n        address _strategy = strategies[_token];\n        address _want = Strategy(_strategy).want();\n        if (_want != _token) {\n            address converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(converter, _amount);\n            _amount = Converter(converter).convert(_strategy);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        Strategy(_strategy).deposit();\n    }\n\n    function balanceOf(address _token) external view returns (uint) {\n        return Strategy(strategies[_token]).balanceOf();\n    }\n\n    function withdrawAll(address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        Strategy(strategies[_token]).withdrawAll();\n    }\n\n    function inCaseTokensGetStuck(address _token, uint _amount) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        Strategy(_strategy).withdraw(_token);\n    }\n\n    function getExpectedReturn(address _strategy, address _token, uint parts) public view returns (uint expected) {\n        uint _balance = IERC20(_token).balanceOf(_strategy);\n        address _want = Strategy(_strategy).want();\n        (expected,) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\n    }\n\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\n    function yearn(address _strategy, address _token, uint parts) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        // This contract should never have value in it, but just incase since this is a public call\n        uint _before = IERC20(_token).balanceOf(address(this));\n        Strategy(_strategy).withdraw(_token);\n        uint _after =  IERC20(_token).balanceOf(address(this));\n        if (_after > _before) {\n            uint _amount = _after.sub(_before);\n            address _want = Strategy(_strategy).want();\n            uint[] memory _distribution;\n            uint _expected;\n            _before = IERC20(_want).balanceOf(address(this));\n            IERC20(_token).safeApprove(onesplit, 0);\n            IERC20(_token).safeApprove(onesplit, _amount);\n            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\n            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\n            _after = IERC20(_want).balanceOf(address(this));\n            if (_after > _before) {\n                _amount = _after.sub(_before);\n                uint _reward = _amount.mul(split).div(max);\n                earn(_want, _amount.sub(_reward));\n                IERC20(_want).safeTransfer(rewards, _reward);\n            }\n        }\n    }\n\n    function withdraw(address _token, uint _amount) public {\n        require(msg.sender == vaults[_token], \"!vault\");\n        Strategy(strategies[_token]).withdraw(_amount);\n    }\n}",
        "function": "0x72cb5d97",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-YFFII Smart Contract Audit/code/code.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Controller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public governance;\n    address public strategist;\n\n    address public onesplit;\n    address public rewards;\n    mapping(address => address) public vaults;\n    mapping(address => address) public strategies;\n    mapping(address => mapping(address => address)) public converters;\n\n    mapping(address => mapping(address => bool)) public approvedStrategies;\n\n    uint public split = 500;\n    uint public constant max = 10000;\n\n    constructor(address _rewards) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n        rewards = _rewards;\n    }\n\n    function setRewards(address _rewards) public {\n        require(msg.sender == governance, \"!governance\");\n        rewards = _rewards;\n    }\n\n    function setStrategist(address _strategist) public {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setSplit(uint _split) public {\n        require(msg.sender == governance, \"!governance\");\n        split = _split;\n    }\n\n    function setOneSplit(address _onesplit) public {\n        require(msg.sender == governance, \"!governance\");\n        onesplit = _onesplit;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setVault(address _token, address _vault) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n    }\n\n    function approveStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    function revokeStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    function setConverter(address _input, address _output, address _converter) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        converters[_input][_output] = _converter;\n    }\n\n    function setStrategy(address _token, address _strategy) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(approvedStrategies[_token][_strategy] == true, \"!approved\");\n\n        address _current = strategies[_token];\n        if (_current != address(0)) {\n            Strategy(_current).withdrawAll();\n        }\n        strategies[_token] = _strategy;\n    }\n\n    function earn(address _token, uint _amount) public {\n        address _strategy = strategies[_token];\n        address _want = Strategy(_strategy).want();\n        if (_want != _token) {\n            address converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(converter, _amount);\n            _amount = Converter(converter).convert(_strategy);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        Strategy(_strategy).deposit();\n    }\n\n    function balanceOf(address _token) external view returns (uint) {\n        return Strategy(strategies[_token]).balanceOf();\n    }\n\n    function withdrawAll(address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        Strategy(strategies[_token]).withdrawAll();\n    }\n\n    function inCaseTokensGetStuck(address _token, uint _amount) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        Strategy(_strategy).withdraw(_token);\n    }\n\n    function getExpectedReturn(address _strategy, address _token, uint parts) public view returns (uint expected) {\n        uint _balance = IERC20(_token).balanceOf(_strategy);\n        address _want = Strategy(_strategy).want();\n        (expected,) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\n    }\n\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\n    function yearn(address _strategy, address _token, uint parts) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        // This contract should never have value in it, but just incase since this is a public call\n        uint _before = IERC20(_token).balanceOf(address(this));\n        Strategy(_strategy).withdraw(_token);\n        uint _after =  IERC20(_token).balanceOf(address(this));\n        if (_after > _before) {\n            uint _amount = _after.sub(_before);\n            address _want = Strategy(_strategy).want();\n            uint[] memory _distribution;\n            uint _expected;\n            _before = IERC20(_want).balanceOf(address(this));\n            IERC20(_token).safeApprove(onesplit, 0);\n            IERC20(_token).safeApprove(onesplit, _amount);\n            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\n            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\n            _after = IERC20(_want).balanceOf(address(this));\n            if (_after > _before) {\n                _amount = _after.sub(_before);\n                uint _reward = _amount.mul(split).div(max);\n                earn(_want, _amount.sub(_reward));\n                IERC20(_want).safeTransfer(rewards, _reward);\n            }\n        }\n    }\n\n    function withdraw(address _token, uint _amount) public {\n        require(msg.sender == vaults[_token], \"!vault\");\n        Strategy(strategies[_token]).withdraw(_amount);\n    }\n}",
        "function": "0x197baa6d",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-YFFII Smart Contract Audit/code/code.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Controller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public governance;\n    address public strategist;\n\n    address public onesplit;\n    address public rewards;\n    mapping(address => address) public vaults;\n    mapping(address => address) public strategies;\n    mapping(address => mapping(address => address)) public converters;\n\n    mapping(address => mapping(address => bool)) public approvedStrategies;\n\n    uint public split = 500;\n    uint public constant max = 10000;\n\n    constructor(address _rewards) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n        rewards = _rewards;\n    }\n\n    function setRewards(address _rewards) public {\n        require(msg.sender == governance, \"!governance\");\n        rewards = _rewards;\n    }\n\n    function setStrategist(address _strategist) public {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setSplit(uint _split) public {\n        require(msg.sender == governance, \"!governance\");\n        split = _split;\n    }\n\n    function setOneSplit(address _onesplit) public {\n        require(msg.sender == governance, \"!governance\");\n        onesplit = _onesplit;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setVault(address _token, address _vault) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n    }\n\n    function approveStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    function revokeStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    function setConverter(address _input, address _output, address _converter) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        converters[_input][_output] = _converter;\n    }\n\n    function setStrategy(address _token, address _strategy) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(approvedStrategies[_token][_strategy] == true, \"!approved\");\n\n        address _current = strategies[_token];\n        if (_current != address(0)) {\n            Strategy(_current).withdrawAll();\n        }\n        strategies[_token] = _strategy;\n    }\n\n    function earn(address _token, uint _amount) public {\n        address _strategy = strategies[_token];\n        address _want = Strategy(_strategy).want();\n        if (_want != _token) {\n            address converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(converter, _amount);\n            _amount = Converter(converter).convert(_strategy);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        Strategy(_strategy).deposit();\n    }\n\n    function balanceOf(address _token) external view returns (uint) {\n        return Strategy(strategies[_token]).balanceOf();\n    }\n\n    function withdrawAll(address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        Strategy(strategies[_token]).withdrawAll();\n    }\n\n    function inCaseTokensGetStuck(address _token, uint _amount) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        Strategy(_strategy).withdraw(_token);\n    }\n\n    function getExpectedReturn(address _strategy, address _token, uint parts) public view returns (uint expected) {\n        uint _balance = IERC20(_token).balanceOf(_strategy);\n        address _want = Strategy(_strategy).want();\n        (expected,) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\n    }\n\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\n    function yearn(address _strategy, address _token, uint parts) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        // This contract should never have value in it, but just incase since this is a public call\n        uint _before = IERC20(_token).balanceOf(address(this));\n        Strategy(_strategy).withdraw(_token);\n        uint _after =  IERC20(_token).balanceOf(address(this));\n        if (_after > _before) {\n            uint _amount = _after.sub(_before);\n            address _want = Strategy(_strategy).want();\n            uint[] memory _distribution;\n            uint _expected;\n            _before = IERC20(_want).balanceOf(address(this));\n            IERC20(_token).safeApprove(onesplit, 0);\n            IERC20(_token).safeApprove(onesplit, _amount);\n            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\n            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\n            _after = IERC20(_want).balanceOf(address(this));\n            if (_after > _before) {\n                _amount = _after.sub(_before);\n                uint _reward = _amount.mul(split).div(max);\n                earn(_want, _amount.sub(_reward));\n                IERC20(_want).safeTransfer(rewards, _reward);\n            }\n        }\n    }\n\n    function withdraw(address _token, uint _amount) public {\n        require(msg.sender == vaults[_token], \"!vault\");\n        Strategy(strategies[_token]).withdraw(_amount);\n    }\n}",
        "function": "withdrawAll(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-YFFII Smart Contract Audit/code/code.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Controller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public governance;\n    address public strategist;\n\n    address public onesplit;\n    address public rewards;\n    mapping(address => address) public vaults;\n    mapping(address => address) public strategies;\n    mapping(address => mapping(address => address)) public converters;\n\n    mapping(address => mapping(address => bool)) public approvedStrategies;\n\n    uint public split = 500;\n    uint public constant max = 10000;\n\n    constructor(address _rewards) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n        rewards = _rewards;\n    }\n\n    function setRewards(address _rewards) public {\n        require(msg.sender == governance, \"!governance\");\n        rewards = _rewards;\n    }\n\n    function setStrategist(address _strategist) public {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setSplit(uint _split) public {\n        require(msg.sender == governance, \"!governance\");\n        split = _split;\n    }\n\n    function setOneSplit(address _onesplit) public {\n        require(msg.sender == governance, \"!governance\");\n        onesplit = _onesplit;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setVault(address _token, address _vault) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n    }\n\n    function approveStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    function revokeStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    function setConverter(address _input, address _output, address _converter) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        converters[_input][_output] = _converter;\n    }\n\n    function setStrategy(address _token, address _strategy) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(approvedStrategies[_token][_strategy] == true, \"!approved\");\n\n        address _current = strategies[_token];\n        if (_current != address(0)) {\n            Strategy(_current).withdrawAll();\n        }\n        strategies[_token] = _strategy;\n    }\n\n    function earn(address _token, uint _amount) public {\n        address _strategy = strategies[_token];\n        address _want = Strategy(_strategy).want();\n        if (_want != _token) {\n            address converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(converter, _amount);\n            _amount = Converter(converter).convert(_strategy);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        Strategy(_strategy).deposit();\n    }\n\n    function balanceOf(address _token) external view returns (uint) {\n        return Strategy(strategies[_token]).balanceOf();\n    }\n\n    function withdrawAll(address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        Strategy(strategies[_token]).withdrawAll();\n    }\n\n    function inCaseTokensGetStuck(address _token, uint _amount) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        Strategy(_strategy).withdraw(_token);\n    }\n\n    function getExpectedReturn(address _strategy, address _token, uint parts) public view returns (uint expected) {\n        uint _balance = IERC20(_token).balanceOf(_strategy);\n        address _want = Strategy(_strategy).want();\n        (expected,) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\n    }\n\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\n    function yearn(address _strategy, address _token, uint parts) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        // This contract should never have value in it, but just incase since this is a public call\n        uint _before = IERC20(_token).balanceOf(address(this));\n        Strategy(_strategy).withdraw(_token);\n        uint _after =  IERC20(_token).balanceOf(address(this));\n        if (_after > _before) {\n            uint _amount = _after.sub(_before);\n            address _want = Strategy(_strategy).want();\n            uint[] memory _distribution;\n            uint _expected;\n            _before = IERC20(_want).balanceOf(address(this));\n            IERC20(_token).safeApprove(onesplit, 0);\n            IERC20(_token).safeApprove(onesplit, _amount);\n            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\n            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\n            _after = IERC20(_want).balanceOf(address(this));\n            if (_after > _before) {\n                _amount = _after.sub(_before);\n                uint _reward = _amount.mul(split).div(max);\n                earn(_want, _amount.sub(_reward));\n                IERC20(_want).safeTransfer(rewards, _reward);\n            }\n        }\n    }\n\n    function withdraw(address _token, uint _amount) public {\n        require(msg.sender == vaults[_token], \"!vault\");\n        Strategy(strategies[_token]).withdraw(_amount);\n    }\n}",
        "function": "withdraw(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-YFFII Smart Contract Audit/code/code.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Controller {\n    using SafeERC20 for IERC20;\n    using Address for address;\n    using SafeMath for uint256;\n\n    address public governance;\n    address public strategist;\n\n    address public onesplit;\n    address public rewards;\n    mapping(address => address) public vaults;\n    mapping(address => address) public strategies;\n    mapping(address => mapping(address => address)) public converters;\n\n    mapping(address => mapping(address => bool)) public approvedStrategies;\n\n    uint public split = 500;\n    uint public constant max = 10000;\n\n    constructor(address _rewards) public {\n        governance = msg.sender;\n        strategist = msg.sender;\n        onesplit = address(0x50FDA034C0Ce7a8f7EFDAebDA7Aa7cA21CC1267e);\n        rewards = _rewards;\n    }\n\n    function setRewards(address _rewards) public {\n        require(msg.sender == governance, \"!governance\");\n        rewards = _rewards;\n    }\n\n    function setStrategist(address _strategist) public {\n        require(msg.sender == governance, \"!governance\");\n        strategist = _strategist;\n    }\n\n    function setSplit(uint _split) public {\n        require(msg.sender == governance, \"!governance\");\n        split = _split;\n    }\n\n    function setOneSplit(address _onesplit) public {\n        require(msg.sender == governance, \"!governance\");\n        onesplit = _onesplit;\n    }\n\n    function setGovernance(address _governance) public {\n        require(msg.sender == governance, \"!governance\");\n        governance = _governance;\n    }\n\n    function setVault(address _token, address _vault) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(vaults[_token] == address(0), \"vault\");\n        vaults[_token] = _vault;\n    }\n\n    function approveStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = true;\n    }\n\n    function revokeStrategy(address _token, address _strategy) public {\n        require(msg.sender == governance, \"!governance\");\n        approvedStrategies[_token][_strategy] = false;\n    }\n\n    function setConverter(address _input, address _output, address _converter) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        converters[_input][_output] = _converter;\n    }\n\n    function setStrategy(address _token, address _strategy) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        require(approvedStrategies[_token][_strategy] == true, \"!approved\");\n\n        address _current = strategies[_token];\n        if (_current != address(0)) {\n            Strategy(_current).withdrawAll();\n        }\n        strategies[_token] = _strategy;\n    }\n\n    function earn(address _token, uint _amount) public {\n        address _strategy = strategies[_token];\n        address _want = Strategy(_strategy).want();\n        if (_want != _token) {\n            address converter = converters[_token][_want];\n            IERC20(_token).safeTransfer(converter, _amount);\n            _amount = Converter(converter).convert(_strategy);\n            IERC20(_want).safeTransfer(_strategy, _amount);\n        } else {\n            IERC20(_token).safeTransfer(_strategy, _amount);\n        }\n        Strategy(_strategy).deposit();\n    }\n\n    function balanceOf(address _token) external view returns (uint) {\n        return Strategy(strategies[_token]).balanceOf();\n    }\n\n    function withdrawAll(address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!strategist\");\n        Strategy(strategies[_token]).withdrawAll();\n    }\n\n    function inCaseTokensGetStuck(address _token, uint _amount) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        IERC20(_token).safeTransfer(msg.sender, _amount);\n    }\n\n    function inCaseStrategyTokenGetStuck(address _strategy, address _token) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        Strategy(_strategy).withdraw(_token);\n    }\n\n    function getExpectedReturn(address _strategy, address _token, uint parts) public view returns (uint expected) {\n        uint _balance = IERC20(_token).balanceOf(_strategy);\n        address _want = Strategy(_strategy).want();\n        (expected,) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _balance, parts, 0);\n    }\n\n    // Only allows to withdraw non-core strategy tokens ~ this is over and above normal yield\n    function yearn(address _strategy, address _token, uint parts) public {\n        require(msg.sender == strategist || msg.sender == governance, \"!governance\");\n        // This contract should never have value in it, but just incase since this is a public call\n        uint _before = IERC20(_token).balanceOf(address(this));\n        Strategy(_strategy).withdraw(_token);\n        uint _after =  IERC20(_token).balanceOf(address(this));\n        if (_after > _before) {\n            uint _amount = _after.sub(_before);\n            address _want = Strategy(_strategy).want();\n            uint[] memory _distribution;\n            uint _expected;\n            _before = IERC20(_want).balanceOf(address(this));\n            IERC20(_token).safeApprove(onesplit, 0);\n            IERC20(_token).safeApprove(onesplit, _amount);\n            (_expected, _distribution) = OneSplitAudit(onesplit).getExpectedReturn(_token, _want, _amount, parts, 0);\n            OneSplitAudit(onesplit).swap(_token, _want, _amount, _expected, _distribution, 0);\n            _after = IERC20(_want).balanceOf(address(this));\n            if (_after > _before) {\n                _amount = _after.sub(_before);\n                uint _reward = _amount.mul(split).div(max);\n                earn(_want, _amount.sub(_reward));\n                IERC20(_want).safeTransfer(rewards, _reward);\n            }\n        }\n    }\n\n    function withdraw(address _token, uint _amount) public {\n        require(msg.sender == vaults[_token], \"!vault\");\n        Strategy(strategies[_token]).withdraw(_amount);\n    }\n}",
        "function": "0x4209f48",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-YFFII Smart Contract Audit/code/code.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "0x2a01dc2",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "0x17608969",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "0x2e0b78f6",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "0x2e0b78f6",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "function": "0x90816302",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "function": "balanceOf(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "function": "releaseAll()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BURST is ERC20Interface, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it\n\n    uint256 public _totalSupply;\n\n    mapping(address => uint) balances;\n    mapping(address => mapping(address => uint)) allowed;\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor() public {\n        name = \"BURST\";\n        symbol = \"BURST\";\n        decimals = 18;\n        _totalSupply = 31000000000000000000000000;\n\n        balances[msg.sender] = _totalSupply;\n        emit Transfer(address(0), msg.sender, _totalSupply);\n    }\n//SWC-101-Integer Overflow and Underflow: L60\n    function totalSupply() public view returns (uint) {\n        return _totalSupply  - balances[address(0)];\n    }\n\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\n        return allowed[tokenOwner][spender];\n    }\n//SWC-114-Transaction Order Dependence: L71-75\n    function approve(address spender, uint tokens) public returns (bool success) {\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function transfer(address to, uint tokens) public returns (bool success) {\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(msg.sender, to, tokens);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\n        balances[from] = safeSub(balances[from], tokens);\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\n        balances[to] = safeAdd(balances[to], tokens);\n        emit Transfer(from, to, tokens);\n        return true;\n    }\n}",
        "function": "totalSupply()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Burst Token Smart Contract/BURST-Token-33b0e2e7ec14828e000ae95e7d4cef77e0796acd/burst.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract AdminPausable {\n    address public admin;\n    address public successor;\n    bool public paused;\n    uint public expire;\n\n    constructor(address _admin) public {\n        admin = _admin;\n        paused = false;\n        expire = block.timestamp + 365 * 1 days;\n    }\n\n    event Paused(address pauser);\n    event Unpaused(address pauser);\n    event Extend(uint ndays);\n    event Claim(address claimer);\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"not admin\");\n        _;\n    }\n\n    modifier isPaused() {\n        require(paused, \"not paused right now\");\n        _;\n    }\n\n    modifier isNotPaused() {\n        require(!paused, \"paused right now\");\n        _;\n    }\n\n    modifier isNotExpired() {\n        require(block.timestamp < expire, \"expired\");\n        _;\n    }\n\n    function retire(address _successor) public onlyAdmin isNotExpired {\n        successor = _successor;\n    }\n\n    function claim() public isNotExpired {\n        require(msg.sender == successor, \"unauthorized\");\n        admin = successor;\n        emit Claim(admin);\n    }\n\n    function extend(uint n) public onlyAdmin isNotExpired {\n        require(n < 366, \"cannot extend for too long\"); // To prevent overflow\n        expire = expire + n * 1 days;\n        emit Extend(n);\n    }\n\n    function pause() public onlyAdmin isNotPaused isNotExpired {\n        paused = true;\n        emit Paused(msg.sender);\n    }\n\n    function unpause() public onlyAdmin isPaused {\n        paused = false;\n        emit Unpaused(msg.sender);\n    }\n}",
        "function": "0x79599f96",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinspect-Incognito Audit/bridge-eth-4879219669a38d601265582f815596b6775855b6/bridge/contracts/incognito_proxy.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LeverageService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Bid[] public bids;\n\n    \n    \n    struct Bid {\n        address payable owner;\n        uint256         pack;\n        uint256         percent;\n    }\n\n    \n    event BidCreated(uint256 id, address owner, uint256 pack, uint256 percent);\n\n    \n    event BidClosed(uint256 id, address who);\n\n    \n    event BidMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event LeverageFeeUpdated(uint256 _value);\n    event LeverageMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(bids[_id].owner == msg.sender, \"Bid isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(bids[_id].owner != address(0), \"Bid doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit LeverageFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit LeverageMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit LeverageFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit LeverageMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create(uint256 _percent) public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        require(_percent >= ILogic(settings.logicManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        // SWC-115-Authorization through tx.origin: L131\n        Bid memory _bid = Bid(\n            tx.origin,\n            msg.value,\n            _percent\n        );\n        uint256 _id = bids.push(_bid).sub(1);\n        emit BidCreated(_id, tx.origin, msg.value, _percent);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n        uint256 _eth = bids[_id].pack;\n        delete bids[_id];\n        msg.sender.transfer(_eth);\n        emit BidClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) {\n\n        address payable _owner = bids[_id].owner;\n        uint256 _eth = bids[_id].pack.mul(divider).div(bids[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(bids[_id].pack)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete bids[_id];\n        _owner.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), _owner, _box);\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv.sub(_sysTmv));\n        emit BidMatched(_id, _box, msg.sender, _owner);\n    }\n}",
        "function": "withdrawSystemETH(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/LeverageService.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LeverageService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Bid[] public bids;\n\n    \n    \n    struct Bid {\n        address payable owner;\n        uint256         pack;\n        uint256         percent;\n    }\n\n    \n    event BidCreated(uint256 id, address owner, uint256 pack, uint256 percent);\n\n    \n    event BidClosed(uint256 id, address who);\n\n    \n    event BidMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event LeverageFeeUpdated(uint256 _value);\n    event LeverageMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(bids[_id].owner == msg.sender, \"Bid isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(bids[_id].owner != address(0), \"Bid doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit LeverageFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit LeverageMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit LeverageFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit LeverageMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create(uint256 _percent) public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        require(_percent >= ILogic(settings.logicManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        // SWC-115-Authorization through tx.origin: L131\n        Bid memory _bid = Bid(\n            tx.origin,\n            msg.value,\n            _percent\n        );\n        uint256 _id = bids.push(_bid).sub(1);\n        emit BidCreated(_id, tx.origin, msg.value, _percent);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n        uint256 _eth = bids[_id].pack;\n        delete bids[_id];\n        msg.sender.transfer(_eth);\n        emit BidClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) {\n\n        address payable _owner = bids[_id].owner;\n        uint256 _eth = bids[_id].pack.mul(divider).div(bids[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(bids[_id].pack)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete bids[_id];\n        _owner.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), _owner, _box);\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv.sub(_sysTmv));\n        emit BidMatched(_id, _box, msg.sender, _owner);\n    }\n}",
        "function": "bids(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/LeverageService.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LeverageService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Bid[] public bids;\n\n    \n    \n    struct Bid {\n        address payable owner;\n        uint256         pack;\n        uint256         percent;\n    }\n\n    \n    event BidCreated(uint256 id, address owner, uint256 pack, uint256 percent);\n\n    \n    event BidClosed(uint256 id, address who);\n\n    \n    event BidMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event LeverageFeeUpdated(uint256 _value);\n    event LeverageMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(bids[_id].owner == msg.sender, \"Bid isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(bids[_id].owner != address(0), \"Bid doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit LeverageFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit LeverageMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit LeverageFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit LeverageMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create(uint256 _percent) public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        require(_percent >= ILogic(settings.logicManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        // SWC-115-Authorization through tx.origin: L131\n        Bid memory _bid = Bid(\n            tx.origin,\n            msg.value,\n            _percent\n        );\n        uint256 _id = bids.push(_bid).sub(1);\n        emit BidCreated(_id, tx.origin, msg.value, _percent);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n        uint256 _eth = bids[_id].pack;\n        delete bids[_id];\n        msg.sender.transfer(_eth);\n        emit BidClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) {\n\n        address payable _owner = bids[_id].owner;\n        uint256 _eth = bids[_id].pack.mul(divider).div(bids[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(bids[_id].pack)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete bids[_id];\n        _owner.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), _owner, _box);\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv.sub(_sysTmv));\n        emit BidMatched(_id, _box, msg.sender, _owner);\n    }\n}",
        "function": "create(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/LeverageService.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LeverageService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Bid[] public bids;\n\n    \n    \n    struct Bid {\n        address payable owner;\n        uint256         pack;\n        uint256         percent;\n    }\n\n    \n    event BidCreated(uint256 id, address owner, uint256 pack, uint256 percent);\n\n    \n    event BidClosed(uint256 id, address who);\n\n    \n    event BidMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event LeverageFeeUpdated(uint256 _value);\n    event LeverageMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(bids[_id].owner == msg.sender, \"Bid isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(bids[_id].owner != address(0), \"Bid doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit LeverageFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit LeverageMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit LeverageFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit LeverageMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create(uint256 _percent) public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        require(_percent >= ILogic(settings.logicManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        // SWC-115-Authorization through tx.origin: L131\n        Bid memory _bid = Bid(\n            tx.origin,\n            msg.value,\n            _percent\n        );\n        uint256 _id = bids.push(_bid).sub(1);\n        emit BidCreated(_id, tx.origin, msg.value, _percent);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n        uint256 _eth = bids[_id].pack;\n        delete bids[_id];\n        msg.sender.transfer(_eth);\n        emit BidClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) {\n\n        address payable _owner = bids[_id].owner;\n        uint256 _eth = bids[_id].pack.mul(divider).div(bids[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(bids[_id].pack)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete bids[_id];\n        _owner.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), _owner, _box);\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv.sub(_sysTmv));\n        emit BidMatched(_id, _box, msg.sender, _owner);\n    }\n}",
        "function": "create(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/LeverageService.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LeverageService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Bid[] public bids;\n\n    \n    \n    struct Bid {\n        address payable owner;\n        uint256         pack;\n        uint256         percent;\n    }\n\n    \n    event BidCreated(uint256 id, address owner, uint256 pack, uint256 percent);\n\n    \n    event BidClosed(uint256 id, address who);\n\n    \n    event BidMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event LeverageFeeUpdated(uint256 _value);\n    event LeverageMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(bids[_id].owner == msg.sender, \"Bid isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(bids[_id].owner != address(0), \"Bid doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit LeverageFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit LeverageMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit LeverageFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit LeverageMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create(uint256 _percent) public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        require(_percent >= ILogic(settings.logicManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        // SWC-115-Authorization through tx.origin: L131\n        Bid memory _bid = Bid(\n            tx.origin,\n            msg.value,\n            _percent\n        );\n        uint256 _id = bids.push(_bid).sub(1);\n        emit BidCreated(_id, tx.origin, msg.value, _percent);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n        uint256 _eth = bids[_id].pack;\n        delete bids[_id];\n        msg.sender.transfer(_eth);\n        emit BidClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) {\n\n        address payable _owner = bids[_id].owner;\n        uint256 _eth = bids[_id].pack.mul(divider).div(bids[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(bids[_id].pack)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete bids[_id];\n        _owner.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), _owner, _box);\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv.sub(_sysTmv));\n        emit BidMatched(_id, _box, msg.sender, _owner);\n    }\n}",
        "function": "close(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/LeverageService.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LeverageService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Bid[] public bids;\n\n    \n    \n    struct Bid {\n        address payable owner;\n        uint256         pack;\n        uint256         percent;\n    }\n\n    \n    event BidCreated(uint256 id, address owner, uint256 pack, uint256 percent);\n\n    \n    event BidClosed(uint256 id, address who);\n\n    \n    event BidMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event LeverageFeeUpdated(uint256 _value);\n    event LeverageMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(bids[_id].owner == msg.sender, \"Bid isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(bids[_id].owner != address(0), \"Bid doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit LeverageFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit LeverageMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit LeverageFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit LeverageMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create(uint256 _percent) public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        require(_percent >= ILogic(settings.logicManager()).withdrawPercent(msg.value), \"Collateralization is not enough\");\n        // SWC-115-Authorization through tx.origin: L131\n        Bid memory _bid = Bid(\n            tx.origin,\n            msg.value,\n            _percent\n        );\n        uint256 _id = bids.push(_bid).sub(1);\n        emit BidCreated(_id, tx.origin, msg.value, _percent);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n        uint256 _eth = bids[_id].pack;\n        delete bids[_id];\n        msg.sender.transfer(_eth);\n        emit BidClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) {\n\n        address payable _owner = bids[_id].owner;\n        uint256 _eth = bids[_id].pack.mul(divider).div(bids[_id].percent);\n\n        require(msg.value == _eth, \"Incorrect ETH value\");\n\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(bids[_id].pack)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete bids[_id];\n        _owner.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), _owner, _box);\n        IToken(settings.tmvAddress()).transfer(msg.sender, _tmv.sub(_sysTmv));\n        emit BidMatched(_id, _box, msg.sender, _owner);\n    }\n}",
        "function": "reclaimERC20(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/LeverageService.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Ask[] public asks;\n\n    \n    \n    struct Ask {\n        address owner;\n        uint256 pack;\n    }\n\n    \n    event AskCreated(uint256 id, address owner, uint256 pack);\n\n    \n    event AskClosed(uint256 id, address who);\n\n    \n    event AskMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event ExchangeFeeUpdated(uint256 _value);\n    event ExchangeMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(asks[_id].owner == msg.sender, \"Ask isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(asks[_id].owner != address(0), \"Ask doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit ExchangeFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit ExchangeMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit ExchangeFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit ExchangeMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create() public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        // SWC-115-Authorization through tx.origin: L129\n        Ask memory _ask = Ask(\n            tx.origin,\n            msg.value\n        );\n        uint256 _id = asks.push(_ask).sub(1);\n        emit AskCreated(_id, tx.origin, msg.value);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n\n        uint256 _eth = asks[_id].pack;\n        delete asks[_id];\n        msg.sender.transfer(_eth);\n        emit AskClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) returns(uint256) {\n\n        address _owner = asks[_id].owner;\n        uint256 _eth = asks[_id].pack;\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(msg.value)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete asks[_id];\n        msg.sender.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), msg.sender, _box);\n        IToken(settings.tmvAddress()).transfer(_owner, _tmv.sub(_sysTmv));\n        emit AskMatched(_id, _box, msg.sender, _owner);\n        return _tmv.sub(_sysTmv);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/ExchangeService.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Ask[] public asks;\n\n    \n    \n    struct Ask {\n        address owner;\n        uint256 pack;\n    }\n\n    \n    event AskCreated(uint256 id, address owner, uint256 pack);\n\n    \n    event AskClosed(uint256 id, address who);\n\n    \n    event AskMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event ExchangeFeeUpdated(uint256 _value);\n    event ExchangeMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(asks[_id].owner == msg.sender, \"Ask isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(asks[_id].owner != address(0), \"Ask doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit ExchangeFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit ExchangeMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit ExchangeFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit ExchangeMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create() public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        // SWC-115-Authorization through tx.origin: L129\n        Ask memory _ask = Ask(\n            tx.origin,\n            msg.value\n        );\n        uint256 _id = asks.push(_ask).sub(1);\n        emit AskCreated(_id, tx.origin, msg.value);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n\n        uint256 _eth = asks[_id].pack;\n        delete asks[_id];\n        msg.sender.transfer(_eth);\n        emit AskClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) returns(uint256) {\n\n        address _owner = asks[_id].owner;\n        uint256 _eth = asks[_id].pack;\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(msg.value)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete asks[_id];\n        msg.sender.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), msg.sender, _box);\n        IToken(settings.tmvAddress()).transfer(_owner, _tmv.sub(_sysTmv));\n        emit AskMatched(_id, _box, msg.sender, _owner);\n        return _tmv.sub(_sysTmv);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/ExchangeService.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Ask[] public asks;\n\n    \n    \n    struct Ask {\n        address owner;\n        uint256 pack;\n    }\n\n    \n    event AskCreated(uint256 id, address owner, uint256 pack);\n\n    \n    event AskClosed(uint256 id, address who);\n\n    \n    event AskMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event ExchangeFeeUpdated(uint256 _value);\n    event ExchangeMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(asks[_id].owner == msg.sender, \"Ask isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(asks[_id].owner != address(0), \"Ask doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit ExchangeFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit ExchangeMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit ExchangeFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit ExchangeMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create() public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        // SWC-115-Authorization through tx.origin: L129\n        Ask memory _ask = Ask(\n            tx.origin,\n            msg.value\n        );\n        uint256 _id = asks.push(_ask).sub(1);\n        emit AskCreated(_id, tx.origin, msg.value);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n\n        uint256 _eth = asks[_id].pack;\n        delete asks[_id];\n        msg.sender.transfer(_eth);\n        emit AskClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) returns(uint256) {\n\n        address _owner = asks[_id].owner;\n        uint256 _eth = asks[_id].pack;\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(msg.value)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete asks[_id];\n        msg.sender.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), msg.sender, _box);\n        IToken(settings.tmvAddress()).transfer(_owner, _tmv.sub(_sysTmv));\n        emit AskMatched(_id, _box, msg.sender, _owner);\n        return _tmv.sub(_sysTmv);\n    }\n}",
        "function": "0xb0c1493",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/ExchangeService.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Ask[] public asks;\n\n    \n    \n    struct Ask {\n        address owner;\n        uint256 pack;\n    }\n\n    \n    event AskCreated(uint256 id, address owner, uint256 pack);\n\n    \n    event AskClosed(uint256 id, address who);\n\n    \n    event AskMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event ExchangeFeeUpdated(uint256 _value);\n    event ExchangeMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(asks[_id].owner == msg.sender, \"Ask isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(asks[_id].owner != address(0), \"Ask doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit ExchangeFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit ExchangeMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit ExchangeFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit ExchangeMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create() public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        // SWC-115-Authorization through tx.origin: L129\n        Ask memory _ask = Ask(\n            tx.origin,\n            msg.value\n        );\n        uint256 _id = asks.push(_ask).sub(1);\n        emit AskCreated(_id, tx.origin, msg.value);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n\n        uint256 _eth = asks[_id].pack;\n        delete asks[_id];\n        msg.sender.transfer(_eth);\n        emit AskClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) returns(uint256) {\n\n        address _owner = asks[_id].owner;\n        uint256 _eth = asks[_id].pack;\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(msg.value)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete asks[_id];\n        msg.sender.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), msg.sender, _box);\n        IToken(settings.tmvAddress()).transfer(_owner, _tmv.sub(_sysTmv));\n        emit AskMatched(_id, _box, msg.sender, _owner);\n        return _tmv.sub(_sysTmv);\n    }\n}",
        "function": "close(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/ExchangeService.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Ask[] public asks;\n\n    \n    \n    struct Ask {\n        address owner;\n        uint256 pack;\n    }\n\n    \n    event AskCreated(uint256 id, address owner, uint256 pack);\n\n    \n    event AskClosed(uint256 id, address who);\n\n    \n    event AskMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event ExchangeFeeUpdated(uint256 _value);\n    event ExchangeMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(asks[_id].owner == msg.sender, \"Ask isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(asks[_id].owner != address(0), \"Ask doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit ExchangeFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit ExchangeMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit ExchangeFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit ExchangeMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create() public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        // SWC-115-Authorization through tx.origin: L129\n        Ask memory _ask = Ask(\n            tx.origin,\n            msg.value\n        );\n        uint256 _id = asks.push(_ask).sub(1);\n        emit AskCreated(_id, tx.origin, msg.value);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n\n        uint256 _eth = asks[_id].pack;\n        delete asks[_id];\n        msg.sender.transfer(_eth);\n        emit AskClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) returns(uint256) {\n\n        address _owner = asks[_id].owner;\n        uint256 _eth = asks[_id].pack;\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(msg.value)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete asks[_id];\n        msg.sender.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), msg.sender, _box);\n        IToken(settings.tmvAddress()).transfer(_owner, _tmv.sub(_sysTmv));\n        emit AskMatched(_id, _box, msg.sender, _owner);\n        return _tmv.sub(_sysTmv);\n    }\n}",
        "function": "withdrawSystemETH(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/ExchangeService.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeService {\n    using SafeMath for uint256;\n\n    \n    address public admin;\n\n    // The amount of Ether received from the commissions of the system.\n    uint256 public systemETH;\n\n    // Commission percentage\n    uint256 public commission;\n\n    // The percentage divider\n    uint256 public divider = 100000;\n\n    // The minimum deposit amount\n    uint256 public minEther;\n\n    ISettings public settings;\n\n    \n    \n    Ask[] public asks;\n\n    \n    \n    struct Ask {\n        address owner;\n        uint256 pack;\n    }\n\n    \n    event AskCreated(uint256 id, address owner, uint256 pack);\n\n    \n    event AskClosed(uint256 id, address who);\n\n    \n    event AskMatched(uint256 id, uint256 tBox, address who, address owner);\n\n    event ExchangeFeeUpdated(uint256 _value);\n    event ExchangeMinEtherUpdated(uint256 _value);\n\n    \n    modifier onlyAdmin() {\n        require(admin == msg.sender, \"You have no access\");\n        _;\n    }\n\n    \n    modifier onlyOwner(uint256 _id) {\n        require(asks[_id].owner == msg.sender, \"Ask isn't your\");\n        _;\n    }\n\n    modifier onlyExists(uint256 _id) {\n        require(asks[_id].owner != address(0), \"Ask doesn't exist\");\n        _;\n    }\n\n    \n    \n    //   account and sets the settings contract with provided address.\n    \n    constructor(ISettings _settings) public {\n        admin = msg.sender;\n        settings = ISettings(_settings);\n\n        commission = 500; // 0.5%\n        emit ExchangeFeeUpdated(commission);\n\n        minEther = 1 ether;\n        emit ExchangeMinEtherUpdated(minEther);\n    }\n\n    \n    function withdrawSystemETH(address payable _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n        require(systemETH > 0, \"There is no available ETH\");\n\n        uint256 _systemETH = systemETH;\n        systemETH = 0;\n        _beneficiary.transfer(_systemETH);\n    }\n\n    \n    function reclaimERC20(address _token, address _beneficiary) external onlyAdmin {\n        require(_beneficiary != address(0), \"Zero address, be careful\");\n\n        uint256 _amount = IToken(_token).balanceOf(address(this));\n        require(_amount > 0, \"There are no tokens\");\n        IToken(_token).transfer(_beneficiary, _amount);\n    }\n\n    \n    function setCommission(uint256 _value) external onlyAdmin {\n        require(_value <= 10000, \"Too much\");\n        commission = _value;\n        emit ExchangeFeeUpdated(_value);\n    }\n\n    \n    function setMinEther(uint256 _value) external onlyAdmin {\n        require(_value <= 100 ether, \"Too much\");\n        minEther = _value;\n        emit ExchangeMinEtherUpdated(_value);\n    }\n\n    \n    function changeAdmin(address _newAdmin) external onlyAdmin {\n        require(_newAdmin != address(0), \"Zero address, be careful\");\n        admin = _newAdmin;\n    }\n\n    \n    function create() public payable returns (uint256) {\n        require(msg.value >= minEther, \"Too small funds\");\n        // SWC-115-Authorization through tx.origin: L129\n        Ask memory _ask = Ask(\n            tx.origin,\n            msg.value\n        );\n        uint256 _id = asks.push(_ask).sub(1);\n        emit AskCreated(_id, tx.origin, msg.value);\n        return _id;\n    }\n\n    \n    function close(uint256 _id) external onlyOwner(_id) {\n\n        uint256 _eth = asks[_id].pack;\n        delete asks[_id];\n        msg.sender.transfer(_eth);\n        emit AskClosed(_id, msg.sender);\n    }\n\n    \n    function take(uint256 _id) external payable onlyExists(_id) returns(uint256) {\n\n        address _owner = asks[_id].owner;\n        uint256 _eth = asks[_id].pack;\n        uint256 _sysEth = _eth.mul(commission).div(divider);\n        systemETH = systemETH.add(_sysEth);\n        uint256 _tmv = _eth.mul(ILogic(settings.logicManager()).rate()).div(ILogic(settings.logicManager()).precision());\n        uint256 _box = ILogic(settings.logicManager()).create.value(msg.value)(_tmv);\n        uint256 _sysTmv = _tmv.mul(commission).div(divider);\n        delete asks[_id];\n        msg.sender.transfer(_eth.sub(_sysEth));\n        ILogic(settings.logicManager()).transferFrom(address(this), msg.sender, _box);\n        IToken(settings.tmvAddress()).transfer(_owner, _tmv.sub(_sysTmv));\n        emit AskMatched(_id, _box, msg.sender, _owner);\n        return _tmv.sub(_sysTmv);\n    }\n}",
        "function": "reclaimERC20(address,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Timvi Smart Contract Audit/Timvi-9324706d1160996f7847e1989c8567168261382e/contracts/services/leverage-exchange/ExchangeService.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            // SWC-123-Requirement Violation: L130\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "burn(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-ZortCoin Smart Contract/ZortCoin/ZortCoin.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            // SWC-123-Requirement Violation: L130\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "burnFrom(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-ZortCoin Smart Contract/ZortCoin/ZortCoin.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    constructor(\n        uint256 initialSupply,\n        string memory tokenName,\n        string memory tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != address(0x0));\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value >= balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            // SWC-123-Requirement Violation: L130\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        emit Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        emit Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "approveAndCall(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-ZortCoin Smart Contract/ZortCoin/ZortCoin.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ZortCoin is TokenERC20 {\n\n    constructor () public TokenERC20(1000000000,\"Zort Coin\", \"ZORT\") {\n      \n    }\n}",
        "function": "burn(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-ZortCoin Smart Contract/ZortCoin/ZortCoin.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ZortCoin is TokenERC20 {\n\n    constructor () public TokenERC20(1000000000,\"Zort Coin\", \"ZORT\") {\n      \n    }\n}",
        "function": "burnFrom(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-ZortCoin Smart Contract/ZortCoin/ZortCoin.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ZortCoin is TokenERC20 {\n\n    constructor () public TokenERC20(1000000000,\"Zort Coin\", \"ZORT\") {\n      \n    }\n}",
        "function": "approveAndCall(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-ZortCoin Smart Contract/ZortCoin/ZortCoin.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library SafeMathLib {\n\n  function times(uint a, uint b) returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function minus(uint a, uint b) returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) returns (uint) {\n    uint c = a + b;\n    assert(c>=a);\n    return c;\n  }\n\n}",
        "function": "plus(uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Security Audit for Patientory (PTOY) Token ICO/smart-contracts-master/contracts/SafeMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "getKudosLeft(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "0x3cbac15f",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "getKudosPerProject(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "getKudosPerProject(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "getKudosPerProject(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "0x3cbac15f",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "function": "0x353b8310",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}",
        "function": "0x766f7815",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-SPICE/synthetix-develop/contracts/AddressResolver.sol",
        "vulnerability": "Unchecked Low Level Call",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}",
        "function": "0x766f7815",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-SPICE/synthetix-develop/contracts/AddressResolver.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "getReward()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CDEXStakingPool is ReentrancyGuard, Pausable {\n    using SafeMath for uint256;\n\n    // STATE VARIABLES\n    CDEXTokenContract public CDEXToken;\n    CDEXRankingContract public CDEXRanking;\n    uint256 public periodFinish = 0;\n    uint256 public rewardRate = 0;\n    uint256 public rewardsDuration = 0;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    \n    \n    uint256 public loyaltyTier1 = 100000000 * 1e8;\n    uint256 public loyaltyTier2 = 10000000 * 1e8;\n    uint256 public loyaltyTier3 = 1000000 * 1e8;\n    \n    \n    uint256 public loyaltyTier1Bonus = 125;\n    uint256 public loyaltyTier2Bonus = 100;\n    uint256 public loyaltyTier3Bonus = 50;\n    uint256 public loyaltyBonusTotal = 275;\n    uint256 public depositedLoyaltyBonus;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n    uint256 public depositedRewardTokens;\n\n    uint256 private _totalSupply;\n    mapping(address => uint256) private _balances;\n\n    uint256 public totalMembers;\n\n    \n    \n    \n    \n    \n    function CDEXStakingPool(\n        address _owner,\n        address _CDEXTokenContractAddress,\n        address _rankingContractAddress\n    ) public Owned(_owner) {\n        CDEXToken = CDEXTokenContract(_CDEXTokenContractAddress);\n        CDEXRanking = CDEXRankingContract(_rankingContractAddress);\n    }\n\n    \n    \n    \n    \n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    \n    \n    \n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    \n    \n    \n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return min(block.timestamp, periodFinish);\n    }\n\n    \n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e8)\n                    .div(_totalSupply)\n            );\n    }\n\n    \n    \n    function earned(address account) public view returns (uint256) {\n        return\n            _balances[account]\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e8)\n                .add(rewards[account]);\n    }\n\n    \n    function getRewardForDuration() external view returns (uint256) {\n        return rewardRate.mul(rewardsDuration);\n    }\n\n    \n    \n    \n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a < b ? a : b;\n    }\n    \n    \n    function getLoyaltyTiers() external view returns(uint256 tier1, uint256 tier2, uint256 tier3)\n    {\n        return(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    function getLoyaltyTiersBonus() external view returns(uint256 tier1Bonus, uint256 tier2Bonus, uint256 tier3Bonus)\n    {\n        return(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L362 - L391\n    function stake(uint256 amount)\n        external\n        nonReentrant\n        notPaused\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.add(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            \n            totalMembers += 1;\n            \n            CDEXRanking.insert(amount, msg.sender);\n        } else {\n            \n            CDEXRanking.remove(_balances[msg.sender], msg.sender);\n            \n            CDEXRanking.insert(_balances[msg.sender].add(amount), msg.sender);\n        }\n        \n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        \n        \n        CDEXToken.transferFrom(msg.sender, address(this), amount);\n        \n        emit Staked(msg.sender, amount);\n    }\n\n    \n    \n    // SWC-104-Unchecked Call Return Value: L395 - L420\n    function withdraw(uint256 amount)\n        public\n        nonReentrant\n        updateReward(msg.sender)\n    {\n        require(amount > 0);\n        \n        _totalSupply = _totalSupply.sub(amount);\n        \n        CDEXRanking.remove(_balances[msg.sender], msg.sender);\n        \n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        \n        if(_balances[msg.sender] == 0) {\n            totalMembers -= 1;\n        } else {\n            \n            CDEXRanking.insert(_balances[msg.sender], msg.sender);\n        }\n        \n        // SWC-104-Unchecked Call Return Value: L415\n        CDEXToken.transfer(msg.sender, amount);\n        \n        emit Withdrawn(msg.sender, amount);\n    }\n    \n    \n    // SWC-104-Unchecked Call Return Value: L424 - L456\n    function getReward() \n        public \n        nonReentrant \n        updateReward(msg.sender) \n    {\n        uint256 reward = rewards[msg.sender];\n        uint256 loyaltyBonus;\n        \n        if (reward > 0 && depositedRewardTokens >= reward) {\n            \n            rewards[msg.sender] = 0;\n            \n            depositedRewardTokens = depositedRewardTokens.sub(reward);\n            \n            if (_balances[msg.sender] >= loyaltyTier1) {\n                loyaltyBonus = reward.mul(loyaltyTier1Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier2) {\n                loyaltyBonus = reward.mul(loyaltyTier2Bonus).div(10000);\n            } else if (_balances[msg.sender] >= loyaltyTier3) {\n                loyaltyBonus = reward.mul(loyaltyTier3Bonus).div(10000);\n            }\n            \n            depositedLoyaltyBonus = depositedLoyaltyBonus.sub(loyaltyBonus);\n            \n            CDEXToken.transfer(msg.sender, reward.add(loyaltyBonus));\n            \n            emit RewardPaid(msg.sender, reward);\n            \n            if(loyaltyBonus > 0) {\n                emit LoyaltyBonusPaid(msg.sender, loyaltyBonus);\n            }\n        }\n    }\n\n    \n    function exit() external {\n        withdraw(_balances[msg.sender]);\n        getReward();\n    }\n    \n    // RESTRICTED FUNCTIONS\n    \n    \n    \n    \n    function setTokenContract(address _contractAddress) public onlyOwner {\n        CDEXToken = CDEXTokenContract(_contractAddress);\n    }\n    \n    \n    \n    \n    function setRankingContract(address _contractAddress) public onlyOwner {\n        CDEXRanking = CDEXRankingContract(_contractAddress);\n    }\n    \n    \n    \n    \n    \n    \n    \n    // SWC-104-Unchecked Call Return Value: L486 - L498\n    function depositTokens(uint256 amount) public onlyOwner {\n        \n        amount = amount.mul(1e8);\n        \n        depositedLoyaltyBonus = depositedLoyaltyBonus.add(amount.mul(loyaltyBonusTotal).div(10000));\n        \n        depositedRewardTokens = depositedRewardTokens.add(amount);\n        \n        CDEXToken.transferFrom(owner, address(this), amount);\n        \n        emit RewardsDeposited(owner, address(this), amount);\n    }\n\n    \n    \n    \n    \n    function notifyRewardAmount(uint256 reward)\n        public\n        onlyOwner\n        updateReward(address(0))\n    {\n        \n        reward = reward.mul(1e8);\n        \n        \n        require(reward <= depositedRewardTokens.sub(reward.mul(loyaltyBonusTotal).div(10000)));\n        \n        \n        if (block.timestamp >= periodFinish) {\n            rewardRate = reward.div(rewardsDuration);\n        } else {\n            uint256 remaining = periodFinish.sub(block.timestamp);\n            uint256 leftover = remaining.mul(rewardRate);\n            rewardRate = reward.add(leftover).div(rewardsDuration);\n        }\n        \n        \n        \n        \n        require(rewardRate <= depositedRewardTokens.div(rewardsDuration));\n        \n        lastUpdateTime = block.timestamp;\n        \n        periodFinish = block.timestamp.add(rewardsDuration);\n        \n        emit RewardAdded(reward);\n    }\n\n    \n    \n    \n    function setRewardsDuration(uint256 _rewardsDuration) external onlyOwner {\n        \n        require(block.timestamp > periodFinish);\n        \n        rewardsDuration = _rewardsDuration;\n        \n        emit RewardsDurationUpdated(rewardsDuration);\n    }\n\n    \n    \n    \n    \n    function setLoyaltyTiers(\n        uint256 _loyaltyTier1, \n        uint256 _loyaltyTier2, \n        uint256 _loyaltyTier3\n    ) external onlyOwner \n    {\n        \n        loyaltyTier1 = _loyaltyTier1.mul(1e8);\n        loyaltyTier2 = _loyaltyTier2.mul(1e8);\n        loyaltyTier3 = _loyaltyTier3.mul(1e8);\n        \n        emit LoyaltyTiersUpdated(loyaltyTier1, loyaltyTier2, loyaltyTier3);\n    }\n\n    \n    \n    \n    \n    \n    \n    function setLoyaltyTiersBonus(\n        uint256 _loyaltyTier1Bonus, \n        uint256 _loyaltyTier2Bonus, \n        uint256 _loyaltyTier3Bonus\n    ) external onlyOwner \n    {\n        \n        \n        require(_loyaltyTier1Bonus.add(_loyaltyTier2Bonus).add(_loyaltyTier3Bonus) < 10000);\n        \n        loyaltyTier1Bonus = _loyaltyTier1Bonus;\n        loyaltyTier2Bonus = _loyaltyTier2Bonus;\n        loyaltyTier3Bonus = _loyaltyTier3Bonus;\n        \n        loyaltyBonusTotal = loyaltyTier1Bonus.add(loyaltyTier2Bonus).add(loyaltyTier3Bonus);\n        \n        emit LoyaltyTiersBonussUpdated(loyaltyTier1Bonus, loyaltyTier2Bonus, loyaltyTier3Bonus);\n    }\n\n    // MODIFIERS\n    \n    \n    \n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    // EVENTS\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n    event LoyaltyBonusPaid(address indexed user, uint256 loyaltyBonus);\n    event RewardsDurationUpdated(uint256 newDuration);\n    // SWC-135-Code With No Effects: L615\n    event Recovered(address token, uint256 amount);\n    event RewardsDeposited(address sender, address receiver, uint256 reward);\n    event LoyaltyTiersUpdated(uint256 loyaltyTier1, uint256 loyaltyTier2, uint256 loyaltyTier3);\n    event LoyaltyTiersBonussUpdated(uint256 loyaltyTier1Bonus, uint256 loyaltyTier2Bonus, uint256 loyaltyTier3Bonus);\n}",
        "function": "depositTokens(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Codex on Althash/Codex-Rewards-Platform-d364d0ef9258dd468f8202a352c58724d6b65638/contracts/CDEX_rewards.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "approveAndCallViaSignature(address,address,uint256,bytes,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "approveViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "approveAndCallViaSignature(address,address,uint256,bytes,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "multiMint(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "transferViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "rescueTokens(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "approveViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "transferViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "transferViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "transferViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "approveAndCallViaSignature(address,address,uint256,bytes,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "transferViaSignature(address,address,uint256,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "approveAndCallViaSignature(address,address,uint256,bytes,uint256,uint256,uint256,bytes,uint8)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "lastMint()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "function": "multiMint(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "function": "removeOwner(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vеrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vеrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "function": "addOwnerWithThreshold(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vеrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract OwnerManager is SelfAuthorized {\n\n    event AddedOwner(address owner);\n    event RemovedOwner(address owner);\n    event ChangedThreshold(uint256 threshold);\n\n    address public constant SENTINEL_OWNERS = address(0x1);\n\n    mapping(address => address) internal owners;\n    uint256 ownerCount;\n    uint256 internal threshold;\n\n    \n    \n    \n    function setupOwners(address[] memory _owners, uint256 _threshold)\n        internal\n    {\n        // Threshold can only be 0 at initialization.\n        // Check ensures that setup function can only be called once.\n        require(threshold == 0, \"Owners have already been setup\");\n        // Validate that threshold is smaller than number of added owners.\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        // Initializing Safe owners.\n        address currentOwner = SENTINEL_OWNERS;\n        for (uint256 i = 0; i < _owners.length; i++) {\n            // Owner address cannot be null.\n            address owner = _owners[i];\n            require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n            // No duplicate owners allowed.\n            require(owners[owner] == address(0), \"Duplicate owner address provided\");\n            owners[currentOwner] = owner;\n            currentOwner = owner;\n        }\n        owners[currentOwner] = SENTINEL_OWNERS;\n        ownerCount = _owners.length;\n        threshold = _threshold;\n    }\n\n    \n    \n    \n    \n    // SWC-114-Transaction Order Dependence: L53 - L68\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[owner] == address(0), \"Address is already an owner\");\n        owners[owner] = owners[SENTINEL_OWNERS];\n        owners[SENTINEL_OWNERS] = owner;\n        // SWC-101-Integer Overflow and Underflow: L64\n        ownerCount++;\n        emit AddedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\n        public\n        authorized\n    {\n        // Only allow to remove an owner, if threshold can still be reached.\n        // SWC-101-Integer Overflow and Underflow: L82\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\n        // Validate owner address and check that it corresponds to owner index.\n        require(owner != address(0) && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\n        owners[prevOwner] = owners[owner];\n        owners[owner] = address(0);\n        // SWC-101-Integer Overflow and Underflow: L89\n        ownerCount--;\n        emit RemovedOwner(owner);\n        // Change threshold if threshold was changed.\n        if (threshold != _threshold)\n            changeThreshold(_threshold);\n    }\n\n    \n    \n    \n    \n    \n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\n        public\n        authorized\n    {\n        // Owner address cannot be null.\n        require(newOwner != address(0) && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        // No duplicate owners allowed.\n        require(owners[newOwner] == address(0), \"Address is already an owner\");\n        // Validate oldOwner address and check that it corresponds to owner index.\n        require(oldOwner != address(0) && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\n        owners[newOwner] = owners[oldOwner];\n        owners[prevOwner] = newOwner;\n        owners[oldOwner] = address(0);\n        emit RemovedOwner(oldOwner);\n        emit AddedOwner(newOwner);\n    }\n\n    \n    \n    \n    function changeThreshold(uint256 _threshold)\n        public\n        authorized\n    {\n        // Validate that threshold is smaller than number of owners.\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\n        // There has to be at least one Safe owner.\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\n        threshold = _threshold;\n        emit ChangedThreshold(threshold);\n    }\n\n    function getThreshold()\n        public\n        view\n        returns (uint256)\n    {\n        return threshold;\n    }\n\n    function isOwner(address owner)\n        public\n        view\n        returns (bool)\n    {\n        return owners[owner] != address(0);\n    }\n\n    \n    \n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        address[] memory array = new address[](ownerCount);\n\n        // populate return array\n        uint256 index = 0;\n        address currentOwner = owners[SENTINEL_OWNERS];\n        while(currentOwner != SENTINEL_OWNERS) {\n            array[index] = currentOwner;\n            currentOwner = owners[currentOwner];\n            index ++;\n        }\n        return array;\n    }\n}",
        "function": "removeOwner(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Runtime_Vеrification-GnosisSafe/safe-contracts-427d6f7e779431333c54bcb4d4cde31e4d57ce96/contracts/base/OwnerManager.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}",
        "function": "withdrawFees()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "function": "getCurrentPrice(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "function": "withdrawFees()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}",
        "function": "withdrawFees()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}",
        "function": "addAddressesToWhitelist(address[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "function": "addAddressesToWhitelist(address[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}",
        "function": "addAddressToWhitelist(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV1Storage is UnitrollerAdminStorage {\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV2Storage is ComptrollerV1Storage {\n    enum Version {\n        VANILLA,\n        COLLATERALCAP\n    }\n\n    struct Market {\n        \n        bool isListed;\n\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint collateralFactorMantissa;\n\n        \n        mapping(address => bool) accountMembership;\n\n        \n        bool isComped;\n\n        \n        Version version;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        \n        uint224 index;\n\n        \n        uint32 block;\n    }\n\n    \n    CToken[] public allMarkets;\n\n    \n    uint public compRate;\n\n    \n    mapping(address => uint) public compSpeeds;\n\n    \n    mapping(address => CompMarketState) public compSupplyState;\n\n    \n    mapping(address => CompMarketState) public compBorrowState;\n\n    \n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    \n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    \n    mapping(address => uint) public compAccrued;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        \n        uint224 index;\n\n        \n        uint32 block;\n    }\n\n    \n    CToken[] public allMarkets;\n\n    \n    uint public compRate;\n\n    \n    mapping(address => uint) public compSpeeds;\n\n    \n    mapping(address => CompMarketState) public compSupplyState;\n\n    \n    mapping(address => CompMarketState) public compBorrowState;\n\n    \n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    \n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    \n    mapping(address => uint) public compAccrued;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV5Storage is ComptrollerV4Storage {\n    // @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n    address public supplyCapGuardian;\n\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV5Storage is ComptrollerV4Storage {\n    // @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n    address public supplyCapGuardian;\n\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20Delegate.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV1Storage is UnitrollerAdminStorage {\n\n    /**\n     * @notice Oracle which gives the price of any given asset\n     */\n    PriceOracle public oracle;\n\n    /**\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n    uint public closeFactorMantissa;\n\n    /**\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n    uint public liquidationIncentiveMantissa;\n\n    /**\n     * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n    uint public maxAssets;\n\n    /**\n     * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n    mapping(address => CToken[]) public accountAssets;\n\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV2Storage is ComptrollerV1Storage {\n    enum Version {\n        VANILLA,\n        COLLATERALCAP\n    }\n\n    struct Market {\n        \n        bool isListed;\n\n        /**\n         * @notice Multiplier representing the most one can borrow against their collateral in this market.\n         *  For instance, 0.9 to allow borrowing 90% of collateral value.\n         *  Must be between 0 and 1, and stored as a mantissa.\n         */\n        uint collateralFactorMantissa;\n\n        \n        mapping(address => bool) accountMembership;\n\n        \n        bool isComped;\n\n        \n        Version version;\n    }\n\n    /**\n     * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n    mapping(address => Market) public markets;\n\n\n    /**\n     * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n    address public pauseGuardian;\n    bool public _mintGuardianPaused;\n    bool public _borrowGuardianPaused;\n    bool public transferGuardianPaused;\n    bool public seizeGuardianPaused;\n    mapping(address => bool) public mintGuardianPaused;\n    mapping(address => bool) public borrowGuardianPaused;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        \n        uint224 index;\n\n        \n        uint32 block;\n    }\n\n    \n    CToken[] public allMarkets;\n\n    \n    uint public compRate;\n\n    \n    mapping(address => uint) public compSpeeds;\n\n    \n    mapping(address => CompMarketState) public compSupplyState;\n\n    \n    mapping(address => CompMarketState) public compBorrowState;\n\n    \n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    \n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    \n    mapping(address => uint) public compAccrued;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV3Storage is ComptrollerV2Storage {\n    struct CompMarketState {\n        \n        uint224 index;\n\n        \n        uint32 block;\n    }\n\n    \n    CToken[] public allMarkets;\n\n    \n    uint public compRate;\n\n    \n    mapping(address => uint) public compSpeeds;\n\n    \n    mapping(address => CompMarketState) public compSupplyState;\n\n    \n    mapping(address => CompMarketState) public compBorrowState;\n\n    \n    mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n    \n    mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n    \n    mapping(address => uint) public compAccrued;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV4Storage is ComptrollerV3Storage {\n    // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n    address public borrowCapGuardian;\n\n    // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n    mapping(address => uint) public borrowCaps;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV5Storage is ComptrollerV4Storage {\n    // @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n    address public supplyCapGuardian;\n\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n}",
        "function": "allMarkets(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ComptrollerV5Storage is ComptrollerV4Storage {\n    // @notice The supplyCapGuardian can set supplyCaps to any number for any market. Lowering the supply cap could disable supplying to the given market.\n    address public supplyCapGuardian;\n\n    // @notice Supply caps enforced by mintAllowed for each cToken address. Defaults to zero which corresponds to unlimited supplying.\n    mapping(address => uint) public supplyCaps;\n}",
        "function": "0xdce15449",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/contracts/CCollateralCapErc20.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "removeAllowedSender(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "allowedSenders()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "removeAllowedSender(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "0x7877a797",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "removeAllowedSender(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TxPermission is UpgradeableOwned, ITxPermission {\n\n    // =============================================== Storage ========================================================\n\n    // WARNING: since this contract is upgradeable, do not remove\n    // existing storage variables, do not change their order,\n    // and do not change their types!\n\n    address[] internal _allowedSenders;\n\n    \n    ICertifier public certifierContract;\n\n    \n    \n    \n    mapping(address => bool) public isSenderAllowed;\n\n    \n    IValidatorSetAuRa public validatorSetContract;\n\n    mapping(address => uint256) internal _deployerInputLengthLimit;\n\n    \n    \n    mapping(address => uint256) public senderMinGasPrice;\n\n    // ============================================== Constants =======================================================\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT = 12500000;\n\n    \n    \n    uint256 public constant BLOCK_GAS_LIMIT_REDUCED = 4000000;\n\n    // ================================================ Events ========================================================\n\n    \n    \n    \n    event DeployerInputLengthLimitSet(address indexed deployer, uint256 limit);\n\n    \n    \n    \n    event SenderMinGasPriceSet(address indexed sender, uint256 minGasPrice);\n\n    // ============================================== Modifiers =======================================================\n\n    \n    modifier onlyInitialized {\n        require(isInitialized());\n        _;\n    }\n\n    // =============================================== Setters ========================================================\n\n    \n    \n    \n    \n    \n    \n    \n    function initialize(\n        address[] calldata _allowed,\n        address _certifier,\n        address _validatorSet\n    ) external {\n        require(block.number == 0 || msg.sender == _admin());\n        require(!isInitialized());\n        require(_certifier != address(0));\n        require(_validatorSet != address(0));\n        for (uint256 i = 0; i < _allowed.length; i++) {\n            _addAllowedSender(_allowed[i]);\n        }\n        certifierContract = ICertifier(_certifier);\n        validatorSetContract = IValidatorSetAuRa(_validatorSet);\n    }\n\n    \n    \n    \n    function addAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        _addAllowedSender(_sender);\n    }\n\n    \n    \n    \n    \n    function removeAllowedSender(address _sender) public onlyOwner onlyInitialized {\n        require(isSenderAllowed[_sender]);\n\n        uint256 allowedSendersLength = _allowedSenders.length;\n\n        for (uint256 i = 0; i < allowedSendersLength; i++) {\n            if (_sender == _allowedSenders[i]) {\n                _allowedSenders[i] = _allowedSenders[allowedSendersLength - 1];\n                _allowedSenders.length--;\n                break;\n            }\n        }\n\n        isSenderAllowed[_sender] = false;\n    }\n\n    \n    \n    \n    \n    \n    function setDeployerInputLengthLimit(address _deployer, uint256 _limit) public onlyOwner onlyInitialized {\n        _deployerInputLengthLimit[_deployer] = _limit;\n        emit DeployerInputLengthLimitSet(_deployer, _limit);\n    }\n\n    \n    \n    \n    function setSenderMinGasPrice(address _sender, uint256 _minGasPrice) public onlyOwner onlyInitialized {\n        senderMinGasPrice[_sender] = _minGasPrice;\n        emit SenderMinGasPriceSet(_sender, _minGasPrice);\n    }\n\n    // =============================================== Getters ========================================================\n\n    \n    function contractName() public pure returns(string memory) {\n        return \"TX_PERMISSION_CONTRACT\";\n    }\n\n    \n    function contractNameHash() public pure returns(bytes32) {\n        return keccak256(abi.encodePacked(contractName()));\n    }\n\n    \n    function contractVersion() public pure returns(uint256) {\n        return 3;\n    }\n\n    \n    \n    \n    function allowedSenders() public view returns(address[] memory) {\n        return _allowedSenders;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    function allowedTxTypes(\n        address _sender,\n        address _to,\n        uint256 _value, // SWC-131-Presence of unused variables: L184\n        uint256 _gasPrice,\n        bytes memory _data\n    )\n        public\n        view\n        returns(uint32 typesMask, bool cache)\n    {\n        if (isSenderAllowed[_sender]) {\n            // Let the `_sender` initiate any transaction if the `_sender` is in the `allowedSenders` list\n            return (ALL, false);\n        }\n\n        if (_to == address(0) && _data.length > deployerInputLengthLimit(_sender)) {\n            // Don't let to deploy too big contracts\n            return (NONE, false);\n        }\n\n        // Get the called function's signature\n        bytes4 signature = bytes4(0);\n        assembly {\n            signature := shl(224, mload(add(_data, 4)))\n        }\n\n        if (_to == validatorSetContract.randomContract()) {\n            if (signature == COMMIT_HASH_SIGNATURE && _data.length > 4+32) {\n                bytes32 numberHash;\n                assembly { numberHash := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).commitHashCallable(_sender, numberHash) ? CALL : NONE, false);\n            } else if (\n                (signature == REVEAL_NUMBER_SIGNATURE || signature == REVEAL_SECRET_SIGNATURE) &&\n                _data.length == 4+32\n            ) {\n                uint256 num;\n                assembly { num := mload(add(_data, 36)) }\n                return (IRandomAuRa(_to).revealNumberCallable(_sender, num) ? CALL : NONE, false);\n            } else {\n                return (NONE, false);\n            }\n        }\n\n        if (_to == address(validatorSetContract)) {\n            // The rules for the ValidatorSetAuRa contract\n            if (signature == EMIT_INITIATE_CHANGE_SIGNATURE) {\n                // The `emitInitiateChange()` can be called by anyone\n                // if `emitInitiateChangeCallable()` returns `true`\n                return (validatorSetContract.emitInitiateChangeCallable() ? CALL : NONE, false);\n            } else if (signature == REPORT_MALICIOUS_SIGNATURE && _data.length >= 4+64) {\n                address maliciousMiningAddress;\n                uint256 blockNumber;\n                assembly {\n                    maliciousMiningAddress := mload(add(_data, 36))\n                    blockNumber := mload(add(_data, 68))\n                }\n                // The `reportMalicious()` can only be called by the validator's mining address\n                // when the calling is allowed\n                (bool callable,) = validatorSetContract.reportMaliciousCallable(\n                    _sender, maliciousMiningAddress, blockNumber\n                );\n\n                return (callable ? CALL : NONE, false);\n            } else if (_gasPrice > 0) {\n                // The other functions of ValidatorSetAuRa contract can be called\n                // by anyone except validators' mining addresses if gasPrice is not zero\n                return (validatorSetContract.isValidator(_sender) ? NONE : CALL, false);\n            }\n        }\n\n        if (validatorSetContract.isValidator(_sender) && _gasPrice > 0) {\n            // Let the validator's mining address send their accumulated tx fees to some wallet\n            return (_sender.balance > 0 ? BASIC : NONE, false);\n        }\n\n        if (validatorSetContract.isValidator(_to)) {\n            // Validator's mining address can't receive any coins\n            return (NONE, false);\n        }\n\n        // Don't let the `_sender` use a zero gas price, if it is not explicitly allowed by the `Certifier` contract\n        if (_gasPrice == 0) {\n            return (certifierContract.certifiedExplicitly(_sender) ? ALL : NONE, false);\n        }\n\n        // Disallow invalid gas price for the specified sender\n        if (_gasPrice < senderMinGasPrice[_sender]) {\n            return (NONE, false);\n        }\n\n        // In other cases let the `_sender` create any transaction with non-zero gas price\n        return (ALL, false);\n    }\n\n    \n    \n    function blockGasLimit() public view returns(uint256) {\n        address stakingContract = validatorSetContract.stakingContract();\n        uint256 stakingEpochEndBlock = IStakingAuRa(stakingContract).stakingEpochEndBlock();\n        if (block.number == stakingEpochEndBlock - 1 || block.number == stakingEpochEndBlock) {\n            return BLOCK_GAS_LIMIT_REDUCED;\n        }\n        return BLOCK_GAS_LIMIT;\n    }\n\n    \n    \n    \n    function deployerInputLengthLimit(address _deployer) public view returns(uint256) {\n        uint256 limit = _deployerInputLengthLimit[_deployer];\n\n        if (limit != 0) {\n            return limit;\n        } else {\n            return 30720; // default EIP 170 limit (24 Kb + overhead)\n        }\n    }\n\n    \n    function isInitialized() public view returns(bool) {\n        return validatorSetContract != IValidatorSetAuRa(0);\n    }\n\n    // ============================================== Internal ========================================================\n\n    // Allowed transaction types mask\n    uint32 internal constant NONE = 0;\n    uint32 internal constant ALL = 0xffffffff;\n    uint32 internal constant BASIC = 0x01;\n    uint32 internal constant CALL = 0x02;\n    // SWC-131-Presence of unused variables: L313-314s\n    uint32 internal constant CREATE = 0x04;\n    uint32 internal constant PRIVATE = 0x08;\n\n    // Function signatures\n\n    // bytes4(keccak256(\"commitHash(bytes32,bytes)\"))\n    bytes4 internal constant COMMIT_HASH_SIGNATURE = 0x0b61ba85; \n\n    // bytes4(keccak256(\"emitInitiateChange()\"))\n    bytes4 internal constant EMIT_INITIATE_CHANGE_SIGNATURE = 0x93b4e25e;\n\n    // bytes4(keccak256(\"reportMalicious(address,uint256,bytes)\"))\n    bytes4 internal constant REPORT_MALICIOUS_SIGNATURE = 0xc476dd40;\n\n    // bytes4(keccak256(\"revealSecret(uint256)\"))\n    bytes4 internal constant REVEAL_SECRET_SIGNATURE = 0x98df67c6;\n\n    // bytes4(keccak256(\"revealNumber(uint256)\"))\n    bytes4 internal constant REVEAL_NUMBER_SIGNATURE = 0xfe7d567d;\n\n    \n    \n    function _addAllowedSender(address _sender) internal {\n        require(!isSenderAllowed[_sender]);\n        require(_sender != address(0));\n        _allowedSenders.push(_sender);\n        isSenderAllowed[_sender] = true;\n    }\n}",
        "function": "allowedSenders()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Etherlite/pos-contracts-e56317bd80a0368a1d9106361c188b589a419b94/contracts/TxPermission.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GuildBank {\n    address public owner;\n\n    constructor () public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event Withdrawal(address indexed receiver, address indexed tokenAddress, uint256 amount);\n\n    function withdraw(address receiver, uint256 shares, uint256 totalShares, IERC20[] memory approvedTokens) public onlyOwner returns (bool) {\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\n            uint256 amount = fairShare(approvedTokens[i].balanceOf(address(this)), shares, totalShares);\n            emit Withdrawal(receiver, address(approvedTokens[i]), amount);\n            require(approvedTokens[i].transfer(receiver, amount));\n        }\n        return true;\n    }\n\n    function withdrawToken(IERC20 token, address receiver, uint256 amount) public onlyOwner returns (bool) {\n        emit Withdrawal(receiver, address(token), amount);\n        return token.transfer(receiver, amount);\n    }\n\n    function fairShare(uint256 balance, uint256 shares, uint256 totalShares) internal pure returns (uint256) {\n        require(totalShares != 0);\n\n        if (balance == 0) { return 0; }\n\n        uint256 prod = balance * shares;\n\n        if (prod / balance == shares) { // no overflow in multiplication above?\n            return prod / totalShares;\n        }\n\n        return (balance / totalShares) * shares;\n    }\n\n}",
        "function": "0x732c8f57",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-The_LAO/moloch-4bc443f4dad60279b47978fc6987bb978d3dfc58/contracts/Moloch.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GuildBank {\n    address public owner;\n\n    constructor () public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    event Withdrawal(address indexed receiver, address indexed tokenAddress, uint256 amount);\n\n    function withdraw(address receiver, uint256 shares, uint256 totalShares, IERC20[] memory approvedTokens) public onlyOwner returns (bool) {\n        for (uint256 i = 0; i < approvedTokens.length; i++) {\n            uint256 amount = fairShare(approvedTokens[i].balanceOf(address(this)), shares, totalShares);\n            emit Withdrawal(receiver, address(approvedTokens[i]), amount);\n            require(approvedTokens[i].transfer(receiver, amount));\n        }\n        return true;\n    }\n\n    function withdrawToken(IERC20 token, address receiver, uint256 amount) public onlyOwner returns (bool) {\n        emit Withdrawal(receiver, address(token), amount);\n        return token.transfer(receiver, amount);\n    }\n\n    function fairShare(uint256 balance, uint256 shares, uint256 totalShares) internal pure returns (uint256) {\n        require(totalShares != 0);\n\n        if (balance == 0) { return 0; }\n\n        uint256 prod = balance * shares;\n\n        if (prod / balance == shares) { // no overflow in multiplication above?\n            return prod / totalShares;\n        }\n\n        return (balance / totalShares) * shares;\n    }\n\n}",
        "function": "withdrawToken(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-The_LAO/moloch-4bc443f4dad60279b47978fc6987bb978d3dfc58/contracts/Moloch.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ChainlinkAdapter {\n    using LibMathSigned for int256;\n\n    IChainlinkFeeder public feeder;\n    int256 public constant chainlinkDecimalsAdapter = 10**10;\n\n    constructor(address _feeder) public {\n        feeder = IChainlinkFeeder(_feeder);\n    }\n\n    function price() public view returns (uint256 newPrice, uint256 timestamp) {\n        // SWC-101-Integer Overflow and Underflow: L18\n        newPrice = (feeder.latestAnswer() * chainlinkDecimalsAdapter).toUint256();\n        timestamp = feeder.latestTimestamp();\n    }\n}",
        "function": "price()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-MCDEX_Mai_Protocol_V2/mai-protocol-v2-4b198083ec4ae2d6851e101fc44ea333eaa3cd92/contracts/oracle/ChainlinkAdapter.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ProjectWalletAuthoriser is Ownable {\n\n    address private authoriser;\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n    function setAuthoriser(address _authoriser) public onlyOwner returns (bool)\n    {\n        authoriser = _authoriser;\n    }\n\n  /**\n   * @dev Transfer the amount of tokens from the spender to the receiver.\n   * @param _sender The address which will spend the funds.\n   * @param _receiver The address which will receiver the funds.\n   * @param _amt The amount of tokens to send.\n   */\n    function transfer(\n        address _sender, \n        address _receiver, \n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        // SWC-104-Unchecked Call Return Value: L38\n        ProjectWallet(_sender).transfer(_receiver, _amt);\n    }\n\n}",
        "function": "transfer(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/ProjectWalletAuthoriser.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "function": "addTokens(address,uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "function": "walletTokens(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "function": "addTokens(address,uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "function": "releaseTokens()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}",
        "function": "owners(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "function": "getOwners()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "function": "approve(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "function": "owners(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /*\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation. \n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n\n  }\n\n  /*\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /*\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /*\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}",
        "function": "setTokenInformation(string,string)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /*\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation. \n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n\n  }\n\n  /*\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /*\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /*\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}",
        "function": "setTokenInformation(string,string)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TapcoinToken is CrowdsaleToken {\n  function TapcoinToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n   CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {\n  }\n}",
        "function": "setTokenInformation(string,string)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TapcoinToken is CrowdsaleToken {\n  function TapcoinToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n   CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {\n  }\n}",
        "function": "setTokenInformation(string,string)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "0x27a59fb8",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "withdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Liquidity_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n    }\n\n    /**\n     * @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => bool) private hasStaked;\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n\n    string public name;\n    address public tokenAddress;\n    address public rewardTokenAddress;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint256 public rewardBalance;\n    uint256 public stakedBalance;\n    uint64 public rate;\n    uint64 public index;\n    uint256 public lockDuration;\n\n    IERC20 public ERC20Interface;\n\n    /**\n     * @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     * @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed rewardToken,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rewardTokenAddress_, contract address of the reward token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        address rewardTokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Token address: 0 address\");\n        tokenAddress = tokenAddress_;\n        require(\n            rewardTokenAddress_ != address(0),\n            \"Reward token address: 0 address\"\n        );\n        rewardTokenAddress = rewardTokenAddress_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        lockDuration = lockDuration_;\n        rates[index] = Rates(rate, block.timestamp);\n    }\n\n    /**\n     * @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n        rate = rate_;\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_' lock days\n     *  @dev to set lock duration days\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     * @dev to add rewards to the staking contract\n     * once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount, rewardTokenAddress)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n        if (!_payMe(from, rewardAmount, rewardTokenAddress)) {\n            return false;\n        }\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     * @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     * Requirements:\n     * - `amount` Amount to be staked\n     /**\n     * @dev to stake 'amount' value of tokens \n     * once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount, tokenAddress)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already staked\");\n        return _stake(from, amount);\n    }\n\n    function _stake(address staker, uint256 amount) private returns (bool) {\n        if (!_payMe(staker, amount, tokenAddress)) {\n            return false;\n        }\n        hasStaked[staker] = true;\n        deposits[staker] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false\n        );\n        emit Staked(tokenAddress, staker, amount);\n\n        // Transfer is completed\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 getPeggedBNF = getPeggedValue();\n        uint256 reward = _calculate(from).mul(getPeggedBNF).div(10**18);\n        uint256 amount = deposits[from].depositAmount;\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        bool rewardPaid = _payDirect(from, reward, rewardTokenAddress);\n        require(principalPaid && rewardPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, rewardTokenAddress, from, amount, reward);\n\n        return true;\n    }\n\n    /**\n     * @dev to calculate the price of BNF per UNIv2 in the LP\n     */\n    function getPeggedValue() private returns (uint256) {\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 getReserves;\n        if (ERC20Interface.token0() == rewardTokenAddress) {\n            (getReserves, , ) = ERC20Interface.getReserves();\n        } else {\n            (, getReserves, ) = ERC20Interface.getReserves();\n        }\n\n        uint256 totalSupply = ERC20Interface.totalSupply();\n        return (getReserves.mul(10**18).div(totalSupply));\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n\n        bool principalPaid = _payDirect(from, amount, tokenAddress);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, address(0), from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     * @param\n     * 'from' user wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     */\n    function calculate(address from) external view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (interest);\n    }\n\n    function _payMe(\n        address payer,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        return _payTo(payer, address(this), amount, token);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount,\n        address token\n    ) private _hasAllowance(allower, amount, token) returns (bool) {\n        // Request to transfer amount from the contract to receiver.\n        // contract does not own the funds, so the allower must have added allowance to the contract\n        // Allower is the original owner.\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(\n        address to,\n        uint256 amount,\n        address token\n    ) private returns (bool) {\n        ERC20Interface = IERC20(token);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(\n        address allower,\n        uint256 amount,\n        address token\n    ) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(token);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n}",
        "function": "emergencyWithdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Liquidity)-Audit Report/code/Liquidity_v9(1).sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "withdrawTo(uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "withdrawTo(uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}",
        "function": "transferToProxy(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "withdrawTo(uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "batchTransfer(bytes32[],uint64)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "withdrawTo(uint256,address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "migrate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "refund()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "migrate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "finalize()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "refund()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "migrate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "onTokenReceived(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "unlock()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "isUnlocked(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "isTimeLocked(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "unlock()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "onTokenReceived(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "isUnlocked(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "onTokenReceived(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "function": "burn(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0x3dadc1e1",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0xe46bbc9e",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "onTokenReceived(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0x3dadc1e1",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0x3dadc1e1",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0xf6577a6",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "onTokenReceived(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0x5cc76fc",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0xe46bbc9e",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0xec9b5b3a",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "createChannel(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0x5cc76fc",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0x3dadc1e1",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "onTokenReceived(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "function": "0xec9b5b3a",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Gate {\n    ERC20Basic private TOKEN;\n    address private PROXY;\n\n    \n    function Gate(ERC20Basic _token, address _proxy) public {\n        TOKEN = _token;\n        PROXY = _proxy;\n    }\n\n    \n    \n    \n    function transferToProxy(uint256 _value) public {\n        require(msg.sender == PROXY);\n\n        require(TOKEN.transfer(PROXY, _value));\n    }\n}",
        "function": "transferToProxy(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "batchTransfer(bytes32[],uint64)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "batchTransfer(bytes32[],uint64)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "function": "transferFromGate()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}",
        "function": "create()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "refund()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "migrate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "migrate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "finalize()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "refund()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}",
        "function": "migrate(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "emergencyWithdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)-Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "withdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)-Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "0x27a59fb8",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)-Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)-Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BiffysLoveFarm is LPTokenWrapper, Ownable {\n    ERC20Mintable public biffysLove;\n    uint256 public duration;\n\n    uint256 public initreward;\n    uint256 public starttime;\n    uint256 public periodFinish;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    event RewardAdded(uint256 reward);\n    event Staked(address indexed user, uint256 amount);\n    event RewardPaid(address indexed user, uint256 reward);\n\n    function initialize(\n        IERC20 _loveLP,\n        ERC20Mintable _biffysLove,\n        uint _duration,\n        uint _initreward,\n        uint _starttime,\n        address _owner\n    ) public initializer {\n        Ownable.initialize(_owner);\n        LPTokenWrapper.init(_loveLP);\n        biffysLove = _biffysLove;\n        duration = _duration;\n        initreward = _initreward;\n        starttime = _starttime;\n    }\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, periodFinish);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply() == 0) {\n            return rewardPerTokenStored;\n        }\n        return\n            rewardPerTokenStored.add(\n                lastTimeRewardApplicable()\n                    .sub(lastUpdateTime)\n                    .mul(rewardRate)\n                    .mul(1e18)\n                    .div(totalSupply())\n            );\n    }\n\n    function earned(address account) public view returns (uint256) {\n        return\n            balanceOf(account)\n                .mul(rewardPerToken().sub(userRewardPerTokenPaid[account]))\n                .div(1e18)\n                .add(rewards[account]);\n    }\n\n    // stake visibility is public as overriding LPTokenWrapper's stake() function\n    function stake(uint256 amount) public updateReward(msg.sender) checkhalve checkStart {\n        require(amount > 0, \"Cannot stake 0\");\n        super.stake(amount);\n        // can happen with first staker in rare occurances\n        if (userRewardPerTokenPaid[msg.sender] == 0) {\n            userRewardPerTokenPaid[msg.sender] = rewardPerToken();\n        }\n        emit Staked(msg.sender, amount);\n    }\n\n    function getReward() public updateReward(msg.sender) checkhalve checkStart {\n        uint256 reward = earned(msg.sender);\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            biffysLove.transfer(msg.sender, reward);\n            emit RewardPaid(msg.sender, reward);\n        }\n    }\n\n    //admin for setting initreward before launch. Only when checkhalve not yet run\n    function setInitReward(uint amtLoveWeiPerPeriod) external onlyOwner {\n        require(rewardRate == 0, \"Must not have yet set the reward rate.\");\n        initreward = amtLoveWeiPerPeriod;\n    }\n\n    //Fix bug due to bad userRewardPerTokenPaid\n    function fixRewardPerTokenStored(address account, uint _rewardPerToken) external onlyOwner {\n        require(earned(account) > 0, \"Must be a staker\");\n        require(userRewardPerTokenPaid[account] == 0, \"Must have incorrect reward\");\n        userRewardPerTokenPaid[account] = _rewardPerToken;\n    }\n\n    //Fix incorrect emission rate, from wrong initreward\n    function fixEmissionRate(uint _initReward) external onlyOwner {\n        initreward = _initReward;\n        biffysLove.mint(address(this), initreward.sub(biffysLove.balanceOf(address(this))));\n        rewardRate = initreward.div(periodFinish.sub(now));\n    }\n\n    modifier checkhalve() {\n        if (block.timestamp >= periodFinish) {\n            initreward = initreward.mul(50).div(100);\n            biffysLove.mint(address(this), initreward);\n\n            rewardRate = initreward.div(duration);\n            periodFinish = block.timestamp.add(duration);\n            emit RewardAdded(initreward);\n        }\n        _;\n    }\n\n    modifier checkStart(){\n        require(block.timestamp > starttime, \"not start\");\n        _;\n    }\n}",
        "function": "0xd957a918",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-biffy_love_audit.pdf/code/Etherscan-0x98a56c7b03eedb7acc46308611561622e51ec13a.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract wHakka is Ownable, ERC20Mintable {\n    using SafeMath for *;\n    using SafeERC20 for IERC20;\n\n    struct vault {\n        uint256 hakkaAmount;\n        uint256 wAmount;\n        uint256 unlockTime;\n    }\n\n    event Stake(address indexed holder, address indexed depositor, uint256 amount, uint256 wAmount, uint256 time);\n    event Unstake(address indexed holder, address indexed receiver, uint256 amount, uint256 wAmount);\n\n    IERC20 public constant Hakka = IERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\n    stakingRateModel public currentModel;\n\n    mapping(address => mapping(uint256 => vault)) public vaults;\n    mapping(address => uint256) public vaultCount;\n    mapping(address => uint256) public stakedHakka;\n    mapping(address => uint256) public votingPower;\n\n    constructor() public {\n        symbol = \"wHAKKA\";\n        name = \"Wrapped Hakka\";\n        decimals = 18;\n        _balances[address(this)] = uint256(-1);\n        _balances[address(0)] = uint256(-1);\n    }\n\n    function getStakingRate(uint256 time) public returns (uint256 rate) {\n        return currentModel.stakingRate(time);\n    }\n\n    function setStakingRateModel(address newModel) external onlyOwner {\n        currentModel = stakingRateModel(newModel);\n    }\n\n// SWC-107-Reentrancy: L556 - L573\n    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n        vault storage v = vaults[to][vaultCount[to]];\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n        require(wAmount > 0, \"invalid lockup\");\n\n        v.hakkaAmount = amount;\n        v.wAmount = wAmount;\n        v.unlockTime = block.timestamp.add(time);\n        \n        stakedHakka[to] = stakedHakka[to].add(amount);\n        votingPower[to] = votingPower[to].add(wAmount);\n        vaultCount[to]++;\n\n        _mint(to, wAmount);\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n    }\n\n    // SWC-107-Reentrancy: L576 - L592\n    function unstake(address to, uint256 index, uint256 wAmount) public returns (uint256 amount) {\n        vault storage v = vaults[msg.sender][index];\n        // SWC-116-Block values as a proxy for time: L580\n        require(block.timestamp >= v.unlockTime, \"locked\");\n        require(wAmount <= v.wAmount, \"exceed locked amount\");\n        amount = wAmount.mul(v.hakkaAmount).div(v.wAmount);\n\n        v.hakkaAmount = v.hakkaAmount.sub(amount);\n        v.wAmount = v.wAmount.sub(wAmount);\n\n        stakedHakka[msg.sender] = stakedHakka[msg.sender].sub(amount);\n        votingPower[msg.sender] = votingPower[msg.sender].sub(wAmount);\n\n        _burn(msg.sender, wAmount);\n        Hakka.safeTransfer(to, amount);\n        \n        emit Unstake(msg.sender, to, amount, wAmount);\n    }\n\n    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n        require(_TokenAddress != Hakka);\n        _TokenAddress.safeTransfer(msg.sender, _amount);\n    }\n\n}",
        "function": "0xa2bc66be",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-Hakka_Finance_wHakka/code/wHakka.sol",
        "vulnerability": "Time Manipulation",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract wHakka is Ownable, ERC20Mintable {\n    using SafeMath for *;\n    using SafeERC20 for IERC20;\n\n    struct vault {\n        uint256 hakkaAmount;\n        uint256 wAmount;\n        uint256 unlockTime;\n    }\n\n    event Stake(address indexed holder, address indexed depositor, uint256 amount, uint256 wAmount, uint256 time);\n    event Unstake(address indexed holder, address indexed receiver, uint256 amount, uint256 wAmount);\n\n    IERC20 public constant Hakka = IERC20(0x0E29e5AbbB5FD88e28b2d355774e73BD47dE3bcd);\n    stakingRateModel public currentModel;\n\n    mapping(address => mapping(uint256 => vault)) public vaults;\n    mapping(address => uint256) public vaultCount;\n    mapping(address => uint256) public stakedHakka;\n    mapping(address => uint256) public votingPower;\n\n    constructor() public {\n        symbol = \"wHAKKA\";\n        name = \"Wrapped Hakka\";\n        decimals = 18;\n        _balances[address(this)] = uint256(-1);\n        _balances[address(0)] = uint256(-1);\n    }\n\n    function getStakingRate(uint256 time) public returns (uint256 rate) {\n        return currentModel.stakingRate(time);\n    }\n\n    function setStakingRateModel(address newModel) external onlyOwner {\n        currentModel = stakingRateModel(newModel);\n    }\n\n// SWC-107-Reentrancy: L556 - L573\n    function stake(address to, uint256 amount, uint256 time) public returns (uint256 wAmount) {\n        vault storage v = vaults[to][vaultCount[to]];\n        wAmount = getStakingRate(time).mul(amount).div(1e18);\n        require(wAmount > 0, \"invalid lockup\");\n\n        v.hakkaAmount = amount;\n        v.wAmount = wAmount;\n        v.unlockTime = block.timestamp.add(time);\n        \n        stakedHakka[to] = stakedHakka[to].add(amount);\n        votingPower[to] = votingPower[to].add(wAmount);\n        vaultCount[to]++;\n\n        _mint(to, wAmount);\n        Hakka.safeTransferFrom(msg.sender, address(this), amount);\n\n        emit Stake(to, msg.sender, amount, wAmount, time);\n    }\n\n    // SWC-107-Reentrancy: L576 - L592\n    function unstake(address to, uint256 index, uint256 wAmount) public returns (uint256 amount) {\n        vault storage v = vaults[msg.sender][index];\n        // SWC-116-Block values as a proxy for time: L580\n        require(block.timestamp >= v.unlockTime, \"locked\");\n        require(wAmount <= v.wAmount, \"exceed locked amount\");\n        amount = wAmount.mul(v.hakkaAmount).div(v.wAmount);\n\n        v.hakkaAmount = v.hakkaAmount.sub(amount);\n        v.wAmount = v.wAmount.sub(wAmount);\n\n        stakedHakka[msg.sender] = stakedHakka[msg.sender].sub(amount);\n        votingPower[msg.sender] = votingPower[msg.sender].sub(wAmount);\n\n        _burn(msg.sender, wAmount);\n        Hakka.safeTransfer(to, amount);\n        \n        emit Unstake(msg.sender, to, amount, wAmount);\n    }\n\n    function inCaseTokenGetsStuckPartial(IERC20 _TokenAddress, uint256 _amount) onlyOwner public {\n        require(_TokenAddress != Hakka);\n        _TokenAddress.safeTransfer(msg.sender, _amount);\n    }\n\n}",
        "function": "stake(address,uint256,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-Hakka_Finance_wHakka/code/wHakka.sol",
        "vulnerability": "Reentrancy",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"GTT_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        \n        emit Transfer(_from, _to, _amount);\n        onTransferDone(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        onTransferDone(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        onTransferDone(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "0x6aaa6a86",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-PlutosNetworkv3/plutos-virtual-trade-e7acfbe/contracts/core/VirtualTrade.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"GTT_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        \n        emit Transfer(_from, _to, _amount);\n        onTransferDone(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        onTransferDone(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        onTransferDone(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "approve(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-PlutosNetworkv3/plutos-virtual-trade-e7acfbe/contracts/core/VirtualTrade.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"GTT_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        \n        emit Transfer(_from, _to, _amount);\n        onTransferDone(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        onTransferDone(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        onTransferDone(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "balanceOf(address)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PeckShield-PlutosNetworkv3/plutos-virtual-trade-e7acfbe/contracts/core/VirtualTrade.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": "approveAndCall(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": "burn(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": "approveAndCall(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": "burnFrom(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "function": "approveAndCall(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "airdrop(address[],uint256[])",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "burn(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "approveAndCall(address,uint256,bytes)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "burnFrom(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "function": "approve(address,uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract HoldefiPauser is Ownable {    \n    address public pauser;\n\n     // '0' -> supply\n     // '1' -> withdrawSupply\n     // '2' -> collatralize\n     // '3' -> withdrawCollateral\n     // '4' -> borrow\n     // '5' -> repayBorrrow\n     // '6' -> liquidateBorrowerCollateral\n     // '7' -> buyLiquidatedCollateral\n    \n    uint constant functionsNum = 8;\n    uint[8] public paused;\n\n    uint public pauseDuration = 2592000;\n\n     \n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\n    }\n\n    // Modifier to make a function callable only by owner or pauser   \n    modifier onlyPausers() {\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\n        _;\n    }\n    \n    // Modifier to make a function callable only when a functions is not paused.\n    modifier whenNotPaused(uint index) {\n        require(!isPause(index), \"Pausable: paused\");\n        _;\n    }\n\n    // Modifier to make a function callable only when a functions is paused.\n    modifier whenPaused(uint index) {\n        require(isPause(index), \"Pausable: not paused\");\n        _;\n    }\n\n    function isPause(uint index) public view returns(bool res) {\n        if (block.timestamp - paused[index] >= pauseDuration) {\n            res = false;\n        }\n        else {\n            res = true;\n        }\n    }\n    \n    // Called by pausers to pause, triggers stopped state.\n    function pause(uint index) public onlyPausers {\n        paused[index] = block.timestamp;\n    }\n\n    // Called by owner to unpause, returns to normal state.\n    function unpause(uint index) public onlyOwner {\n        paused[index] = 0;\n    }\n//SWC-100-Function Default Visibility:L65-71\n    // Called by pausers to pause, triggers stopped state for selected functions\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\n        for (uint i=0; i<functionsNum; i++) {\n            if (newPaused[i] == true){\n                pause(i);\n            }\n        }\n    }\n//SWC-100-Function Default Visibility:L74-80\n    // Called by pausers to pause, returns to normal state for selected functions\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\n        for (uint i=0; i<functionsNum; i++) {\n            if (newUnpaused[i] == true){\n                unpause(i);\n            }\n        }\n    }\n    // Called by owner to set a new pauser\n    function setPauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n    }\n\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\n        pauseDuration = newPauseDuration;\n    }\n}",
        "function": "0xa65ddb60",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Holdefi/Holdefi-f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/HoldefiPauser.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract HoldefiPauser is Ownable {    \n    address public pauser;\n\n     // '0' -> supply\n     // '1' -> withdrawSupply\n     // '2' -> collatralize\n     // '3' -> withdrawCollateral\n     // '4' -> borrow\n     // '5' -> repayBorrrow\n     // '6' -> liquidateBorrowerCollateral\n     // '7' -> buyLiquidatedCollateral\n    \n    uint constant functionsNum = 8;\n    uint[8] public paused;\n\n    uint public pauseDuration = 2592000;\n\n     \n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\n    }\n\n    // Modifier to make a function callable only by owner or pauser   \n    modifier onlyPausers() {\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\n        _;\n    }\n    \n    // Modifier to make a function callable only when a functions is not paused.\n    modifier whenNotPaused(uint index) {\n        require(!isPause(index), \"Pausable: paused\");\n        _;\n    }\n\n    // Modifier to make a function callable only when a functions is paused.\n    modifier whenPaused(uint index) {\n        require(isPause(index), \"Pausable: not paused\");\n        _;\n    }\n\n    function isPause(uint index) public view returns(bool res) {\n        if (block.timestamp - paused[index] >= pauseDuration) {\n            res = false;\n        }\n        else {\n            res = true;\n        }\n    }\n    \n    // Called by pausers to pause, triggers stopped state.\n    function pause(uint index) public onlyPausers {\n        paused[index] = block.timestamp;\n    }\n\n    // Called by owner to unpause, returns to normal state.\n    function unpause(uint index) public onlyOwner {\n        paused[index] = 0;\n    }\n//SWC-100-Function Default Visibility:L65-71\n    // Called by pausers to pause, triggers stopped state for selected functions\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\n        for (uint i=0; i<functionsNum; i++) {\n            if (newPaused[i] == true){\n                pause(i);\n            }\n        }\n    }\n//SWC-100-Function Default Visibility:L74-80\n    // Called by pausers to pause, returns to normal state for selected functions\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\n        for (uint i=0; i<functionsNum; i++) {\n            if (newUnpaused[i] == true){\n                unpause(i);\n            }\n        }\n    }\n    // Called by owner to set a new pauser\n    function setPauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n    }\n\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\n        pauseDuration = newPauseDuration;\n    }\n}",
        "function": "0x61dd3f8",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Holdefi/Holdefi-f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/HoldefiPauser.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract HoldefiPauser is Ownable {    \n    address public pauser;\n\n     // '0' -> supply\n     // '1' -> withdrawSupply\n     // '2' -> collatralize\n     // '3' -> withdrawCollateral\n     // '4' -> borrow\n     // '5' -> repayBorrrow\n     // '6' -> liquidateBorrowerCollateral\n     // '7' -> buyLiquidatedCollateral\n    \n    uint constant functionsNum = 8;\n    uint[8] public paused;\n\n    uint public pauseDuration = 2592000;\n\n     \n    constructor (address newOwnerChanger) Ownable(newOwnerChanger) public {\n    }\n\n    // Modifier to make a function callable only by owner or pauser   \n    modifier onlyPausers() {\n        require(msg.sender == owner || msg.sender == pauser , 'Sender should be Owner or Pauser');\n        _;\n    }\n    \n    // Modifier to make a function callable only when a functions is not paused.\n    modifier whenNotPaused(uint index) {\n        require(!isPause(index), \"Pausable: paused\");\n        _;\n    }\n\n    // Modifier to make a function callable only when a functions is paused.\n    modifier whenPaused(uint index) {\n        require(isPause(index), \"Pausable: not paused\");\n        _;\n    }\n\n    function isPause(uint index) public view returns(bool res) {\n        if (block.timestamp - paused[index] >= pauseDuration) {\n            res = false;\n        }\n        else {\n            res = true;\n        }\n    }\n    \n    // Called by pausers to pause, triggers stopped state.\n    function pause(uint index) public onlyPausers {\n        paused[index] = block.timestamp;\n    }\n\n    // Called by owner to unpause, returns to normal state.\n    function unpause(uint index) public onlyOwner {\n        paused[index] = 0;\n    }\n//SWC-100-Function Default Visibility:L65-71\n    // Called by pausers to pause, triggers stopped state for selected functions\n    function batchPause(bool[8] memory newPaused) public onlyPausers {\n        for (uint i=0; i<functionsNum; i++) {\n            if (newPaused[i] == true){\n                pause(i);\n            }\n        }\n    }\n//SWC-100-Function Default Visibility:L74-80\n    // Called by pausers to pause, returns to normal state for selected functions\n    function batchUnpause(bool[8] memory newUnpaused) public onlyOwner {\n        for (uint i=0; i<functionsNum; i++) {\n            if (newUnpaused[i] == true){\n                unpause(i);\n            }\n        }\n    }\n    // Called by owner to set a new pauser\n    function setPauser(address newPauser) external onlyOwner {\n        pauser = newPauser;\n    }\n\n    function setPauseDuration(uint newPauseDuration) external onlyOwner {\n        pauseDuration = newPauseDuration;\n    }\n}",
        "function": "0xa65ddb60",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Holdefi/Holdefi-f4df394d7cf6df347b1f1e9af8e2676c5933c2c9/HoldefiPauser.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "stake(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)- Final Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "withdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)- Final Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "emergencyWithdraw()",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)- Final Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Legendary_v8 is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     *  @dev Structs to store user staking data.\n     */\n    struct Deposits {\n        uint256 depositAmount;\n        uint256 depositTime;\n        uint256 endTime;\n        uint64 userIndex;\n        bool paid;\n        bool eligible;\n    }\n\n    /**\n     *  @dev Structs to store interest rate change.\n     */\n    struct Rates {\n        uint64 newInterestRate;\n        uint256 timeStamp;\n    }\n\n    mapping(address => Deposits) private deposits;\n    mapping(uint64 => Rates) public rates;\n    mapping(address => bool) private hasStaked;\n\n    address public tokenAddress;\n    uint256 public stakedBalance;\n    uint256 public rewardBalance;\n    uint256 public stakedTotal;\n    uint256 public totalReward;\n    uint64 public index;\n    uint64 public rate;\n    uint256 public lockDuration;\n    uint256 public eligibilityAmount;\n    string public name;\n    address public rookieAddress;\n    address public professionalAddress;\n\n    IERC20 public ERC20Interface;\n    IRookieProfessionalCheck public RookieInstance;\n    IRookieProfessionalCheck public ProfessionalInstance;\n\n    /**\n     *  @dev Emitted when user stakes 'stakedAmount' value of tokens\n     */\n    event Staked(\n        address indexed token,\n        address indexed staker_,\n        uint256 stakedAmount_\n    );\n\n    /**\n     *  @dev Emitted when user withdraws his stakings\n     */\n    event PaidOut(\n        address indexed token,\n        address indexed staker_,\n        uint256 amount_,\n        uint256 reward_\n    );\n\n    /**\n     *   @param\n     *   name_, name of the contract\n     *   tokenAddress_, contract address of the token\n     *   rate_, rate multiplied by 100\n     *   lockduration_, duration in days\n     *   rookieAddress_, address of the rookie staking contract\n     *   professionalAddress_, address of the professional staking contract\n     */\n    constructor(\n        string memory name_,\n        address tokenAddress_,\n        uint64 rate_,\n        uint256 lockDuration_,\n        address rookieAddress_,\n        address professionalAddress_\n    ) public Ownable() {\n        name = name_;\n        require(tokenAddress_ != address(0), \"Zero token address\");\n        tokenAddress = tokenAddress_;\n        lockDuration = lockDuration_;\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        rates[index] = Rates(rate, block.timestamp);\n        require(rookieAddress_ != address(0), \"Zero Rookie Address\");\n        rookieAddress = rookieAddress_;\n        require(\n            professionalAddress_ != address(0),\n            \"Zero Professional Address\"\n        );\n        professionalAddress = professionalAddress_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rate_` New effective interest rate multiplied by 100\n     *  @dev to set interest rates\n     */\n    function setRate(uint64 rate_) external onlyOwner {\n        require(rate_ != 0, \"Zero interest rate\");\n        rate = rate_;\n        index++;\n        rates[index] = Rates(rate_, block.timestamp);\n    }\n\n    /**\n     *  Requirements:\n     *  `lockduration_` lock days\n     *  @dev to set lockDuration\n     */\n    function changeLockDuration(uint256 lockduration_) external onlyOwner {\n        lockDuration = lockduration_;\n    }\n\n    /**\n     *  Requirements:\n     *  `user_` User wallet address\n     *  @dev to view eligibility status of user\n     */\n    function eligibility(address user_) external view returns (bool) {\n        return deposits[user_].eligible;\n    }\n\n    function setEligibilityAmount(\n        uint256 eligibilityAmount_ //external\n    ) external onlyOwner {\n        eligibilityAmount = eligibilityAmount_;\n    }\n\n    /**\n     *  Requirements:\n     *  `rewardAmount` rewards to be added to the staking contract\n     *  @dev to add rewards to the staking contract\n     *  once the allowance is given to this contract for 'rewardAmount' by the user\n     */\n    function addReward(uint256 rewardAmount)\n        external\n        _hasAllowance(msg.sender, rewardAmount)\n        returns (bool)\n    {\n        require(rewardAmount > 0, \"Reward must be positive\");\n        address from = msg.sender;\n\n        if (!_payMe(from, rewardAmount)) {\n            return false;\n        }\n\n        totalReward = totalReward.add(rewardAmount);\n        rewardBalance = rewardBalance.add(rewardAmount);\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `user` User wallet address\n     *  @dev returns user staking data\n     */\n    function userDeposits(address user)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            bool\n        )\n    {\n        if (hasStaked[user]) {\n            return (\n                deposits[user].depositAmount,\n                deposits[user].depositTime,\n                deposits[user].endTime,\n                deposits[user].userIndex,\n                deposits[user].paid\n            );\n        }\n    }\n\n    /**\n     *  Requirements:\n     *  `amount` Amount to be staked\n     /**\n     *  @dev to stake 'amount' value of tokens \n     *  once the user has given allowance to the staking contract\n     */\n    function stake(uint256 amount)\n        external\n        _hasAllowance(msg.sender, amount)\n        _isEligible(msg.sender)\n        returns (bool)\n    {\n        require(amount > 0, \"Can't stake 0 amount\");\n        address from = msg.sender;\n        require(hasStaked[from] == false, \"Already Staked\");\n        return (_stake(from, amount));\n    }\n\n    function _stake(address from, uint256 amount) private returns (bool) {\n        if (!_payMe(from, amount)) {\n            return false;\n        }\n\n        hasStaked[from] = true;\n        bool stakerEligibility;\n        if (amount >= eligibilityAmount) {\n            stakerEligibility = true;\n        }\n\n        deposits[from] = Deposits(\n            amount,\n            block.timestamp,\n            block.timestamp.add((lockDuration.mul(86400))), //(lockDuration * 24 * 3600)\n            index,\n            false,\n            stakerEligibility\n        );\n\n        emit Staked(tokenAddress, from, amount);\n\n        stakedBalance = stakedBalance.add(amount);\n        stakedTotal = stakedTotal.add(amount);\n        return true;\n    }\n\n    /**\n     * @dev to withdraw user stakings after the lock period ends.\n     */\n    function withdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n        return (_withdraw(from));\n    }\n\n    function _withdraw(address from) private returns (bool) {\n        uint256 payOut = _calculate(from);\n        uint256 amount = deposits[from].depositAmount;\n        uint256 reward = payOut.sub(amount);\n        require(reward <= rewardBalance, \"Not enough rewards\");\n\n        stakedBalance = stakedBalance.sub(amount);\n        rewardBalance = rewardBalance.sub(reward);\n        deposits[from].paid = true;\n        hasStaked[from] = false;\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        if (_payDirect(from, payOut)) {\n            emit PaidOut(tokenAddress, from, amount, reward);\n            return true;\n        }\n        return false;\n    }\n\n    function emergencyWithdraw() external returns (bool) {\n        address from = msg.sender;\n        require(hasStaked[from] == true, \"No stakes found for user\");\n        require(\n            block.timestamp >= deposits[from].endTime,\n            \"Requesting before lock time\"\n        );\n        require(deposits[from].paid == false, \"Already paid out\");\n\n        return (_emergencyWithdraw(from));\n    }\n\n    function _emergencyWithdraw(address from) private returns (bool) {\n        uint256 amount = deposits[from].depositAmount;\n        stakedBalance = stakedBalance.sub(amount);\n        deposits[from].paid = true;\n        hasStaked[from] = false; //Check-Effects-Interactions pattern\n        if (deposits[from].eligible) {\n            deposits[from].eligible = false;\n        }\n\n        bool principalPaid = _payDirect(from, amount);\n        require(principalPaid, \"Error paying\");\n        emit PaidOut(tokenAddress, from, amount, 0);\n\n        return true;\n    }\n\n    /**\n     *  Requirements:\n     *  `from` User wallet address\n     * @dev to calculate the rewards based on user staked 'amount'\n     * 'userIndex' - the index of the interest rate at the time of user stake.\n     * 'depositTime' - time of staking\n     */\n    function calculate(address from) public view returns (uint256) {\n        return _calculate(from);\n    }\n\n    function _calculate(address from) private view returns (uint256) {\n        if (!hasStaked[from]) return 0;\n        (\n            uint256 amount,\n            uint256 depositTime,\n            uint256 endTime,\n            uint64 userIndex\n        ) =\n            (\n                deposits[from].depositAmount,\n                deposits[from].depositTime,\n                deposits[from].endTime,\n                deposits[from].userIndex\n            );\n\n        uint256 time;\n        uint256 interest;\n        uint256 _lockduration = endTime.sub(depositTime);\n        for (uint64 i = userIndex; i < index; i++) {\n            //loop runs till the latest index/interest rate change\n            if (endTime < rates[i + 1].timeStamp) {\n                //if the change occurs after the endTime loop breaks\n                break;\n            } else {\n                time = rates[i + 1].timeStamp.sub(depositTime);\n                interest = amount.mul(rates[i].newInterestRate).mul(time).div(\n                    _lockduration.mul(10000)\n                ); //replace with (_lockduration * 10000)\n                amount += interest;\n                depositTime = rates[i + 1].timeStamp;\n                userIndex++;\n            }\n        }\n\n        if (depositTime < endTime) {\n            //final calculation for the remaining time period\n            time = endTime.sub(depositTime);\n\n            interest = time\n                .mul(amount)\n                .mul(rates[userIndex].newInterestRate)\n                .div(_lockduration.mul(10000)); //replace with (lockduration * 10000)\n\n            amount += interest;\n        }\n\n        return (amount);\n    }\n\n    function _payMe(address payer, uint256 amount) private returns (bool) {\n        return _payTo(payer, address(this), amount);\n    }\n\n    function _payTo(\n        address allower,\n        address receiver,\n        uint256 amount\n    ) private _hasAllowance(allower, amount) returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transferFrom(allower, receiver, amount);\n    }\n\n    function _payDirect(address to, uint256 amount) private returns (bool) {\n        ERC20Interface = IERC20(tokenAddress);\n        return ERC20Interface.transfer(to, amount);\n    }\n\n    modifier _hasAllowance(address allower, uint256 amount) {\n        // Make sure the allower has provided the right allowance.\n        ERC20Interface = IERC20(tokenAddress);\n        uint256 ourAllowance = ERC20Interface.allowance(allower, address(this));\n        require(amount <= ourAllowance, \"Make sure to add enough allowance\");\n        _;\n    }\n\n    /**\n     *  modifier to check the status of the user from the rookie\n     *  and professional pools before staking here\n     */\n    modifier _isEligible(address from) {\n        RookieInstance = IRookieProfessionalCheck(rookieAddress);\n        ProfessionalInstance = IRookieProfessionalCheck(professionalAddress);\n        bool RookieEligible = RookieInstance.eligibility(from);\n        bool ProfessionalEligible = ProfessionalInstance.eligibility(from);\n        require(\n            RookieEligible || ProfessionalEligible,\n            \"Need to be eligible in either Rookie or Professional to stake\"\n        );\n        _;\n    }\n}",
        "function": "0x27a59fb8",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/ImmuneBytes-BonFi(Legendary)- Final Audit Report/code/Legendary_v9.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0x591f3428",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0x3e8eb5a4",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xca1748af",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "0xa50973cf",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DIACompanyLockup is OTCRoles {\n    using SafeERC20 for IERC20;\n    IERC20 token;\n    \n    // Timeframe in which it it possible to deposit tokens\n    // SWC-108-State Variable Default Visibility: L532 - L541\n    uint256 beginDepositTime;\n    uint256 endDepositTime;\n    \n    // Originating wallet for yield payments\n    address yieldWallet;\n    \n    // Parameters for early bird kickers\n    address kickerWallet;\n    uint256 kickerDeadline;\n    uint256 kickerPromille;\n    \n    // Yield rates\n    uint256 public threeMonthPromille;\n    uint256 public sixMonthPromille;\n    uint256 public nineMonthPromille;\n\n    // Main struct for lockup\n    struct LockBoxStruct {\n        address beneficiary;\n        uint balance;\n        uint releaseTime;\n    }\n\n    LockBoxStruct[] public lockBoxStructs; // This could be a mapping by address, but these numbered lockBoxes support possibility of multiple tranches per address\n\n    event LogLockupDeposit(address sender, address beneficiary, uint amount, uint releaseTime);   \n    event LogLockupWithdrawal(address receiver, uint amount);\n\n    constructor(address tokenContract, uint256 _beginDepositTime, uint256 _endDepositTime, address _kickerWallet, uint256 _kickerDeadline, uint256 _kickerPromille, address _yieldWallet) public {\n        token = IERC20(tokenContract);\n        beginDepositTime = _beginDepositTime;\n        endDepositTime = _endDepositTime;\n        \n        kickerWallet = _kickerWallet;\n        kickerDeadline = _kickerDeadline;\n        kickerPromille = _kickerPromille;\n        yieldWallet = _yieldWallet;\n    }\n    \n    function getLockBoxBeneficiary(uint256 lockBoxNumber) public view returns(address) {\n        return lockBoxStructs[lockBoxNumber].beneficiary;\n    }\n\n    // Deposit for 3, 6 or 9 months\n    function deposit3m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 12 weeks);\n    }\n    \n    function deposit6m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 24 weeks);\n    }\n    \n    function deposit9m(address beneficiary, uint256 amount) public {\n        deposit(beneficiary, amount, 36 weeks);\n    }\n\n    function deposit(address beneficiary, uint256 amount, uint256 duration) internal {\n        require(now < endDepositTime, \"Deposit time has ended.\");\n        // Define and get amount of yield\n        uint256 yieldAmount;\n        if (duration == 12 weeks) {\n            yieldAmount = (threeMonthPromille * amount) / 1000;\n        } else if (duration == 24 weeks) {\n            yieldAmount = (sixMonthPromille * amount) / 1000;\n        } else if (duration == 36 weeks) {\n            yieldAmount = (nineMonthPromille * amount) / 1000;\n        } else {\n            revert(\"Error: duration not allowed!\");\n        }\n        require(token.transferFrom(yieldWallet, address(this), yieldAmount));\n        \n        // Define and get kicker payment\n        uint256 kickerAmount = (kickerPromille * amount) / 1000;\n        if (now <= kickerDeadline) {\n            require(token.transferFrom(kickerWallet, address(this), kickerAmount));\n        }\n        \n        // Get lockable tokens from user\n        require(token.transferFrom(msg.sender, address(this), amount));\n        \n        // Build lockbox\n        LockBoxStruct memory l;\n        l.beneficiary = beneficiary;\n        l.balance = amount + kickerAmount + yieldAmount;\n        l.releaseTime = beginDepositTime + duration;\n        lockBoxStructs.push(l);\n        emit LogLockupDeposit(msg.sender, l.beneficiary, l.balance, l.releaseTime);\n    }\n    \n    // Beneficiaries can update the receiver wallet\n    function updateBeneficiary(uint256 lockBoxNumber, address newBeneficiary) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(msg.sender == l.beneficiary);\n        l.beneficiary = newBeneficiary;\n    }\n\n    function withdraw(uint lockBoxNumber) public {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        uint amount = l.balance;\n        l.balance = 0;\n        emit LogLockupWithdrawal(l.beneficiary, amount);\n        require(token.transfer(l.beneficiary, amount));\n    }\n\n    // Helper function to release everything    \n    function triggerWithdrawAll() public {\n        // SWC-128-DoS With Block Gas Limit: L640 - L644\n        for (uint256 i = 0; i < lockBoxStructs.length; ++i) {\n            if (lockBoxStructs[i].releaseTime <= now && lockBoxStructs[i].balance > 0) {\n                withdraw(i);\n            }\n        }\n    }\n    \n    // Admin update functions\n    function updateEndDepositTime (uint256 newEndTime) public onlyOwner {\n        endDepositTime = newEndTime;\n    }\n    \n    function updateYieldWallet(address newWallet) public onlyOwner {\n        yieldWallet = newWallet;\n    }\n    \n    function updateKicker(address newWallet, uint256 newPromille, uint256 newDeadline) public onlyOwner {\n        kickerWallet = newWallet;\n        kickerPromille = newPromille;\n        kickerDeadline = newDeadline;\n    }\n    \n    function updateYields(uint256 threeMonths, uint256 sixMonths, uint256 nineMonths) public onlyOwner {\n        threeMonthPromille = threeMonths;\n        sixMonthPromille = sixMonths;\n        nineMonthPromille = nineMonths;\n    }\n    \n    // Pay extra premium for selected investors\n    function allocatePremium(uint256 lockBoxNumber, uint256 premiumAmount) public onlyOwner {\n        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];\n        require(l.releaseTime <= now);\n        require(token.transferFrom(kickerWallet, address(this), premiumAmount));\n        l.balance += premiumAmount;\n    }\n}",
        "function": "lockBoxStructs(uint256)",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-DIA-project1/code/yield.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TestablePausable is Owned, Pausable {\n    uint public someValue;\n\n    constructor(address _owner) public Owned(_owner) Pausable() {}\n\n    function setSomeValue(uint _value) external notPaused {\n        someValue = _value;\n    }\n}",
        "function": "setPaused(bool)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-75e51e722d316eb45713049faf5e430ed124794e/contracts/test-helpers/TestablePausable.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract OneWeekSetup is LimitedSetup(1 weeks) {\n    function testFunc() public view onlyDuringSetup returns (bool) {\n        return true;\n    }\n\n    function publicSetupExpiryTime() public view returns (uint) {\n        return setupExpiryTime;\n    }\n}",
        "function": "testFunc()",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-f141ab9cb6a5bdc66f9334a6479c5dcdd12cde2e/contracts/test-helpers/OneWeekSetup.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x15987eb6",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-00df930622a8ea462d15d4eccf6bc6b3d704bd21/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x6e13fe76",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-00df930622a8ea462d15d4eccf6bc6b3d704bd21/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x15987eb6",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-00df930622a8ea462d15d4eccf6bc6b3d704bd21/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0xd0d3d62a",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-00df930622a8ea462d15d4eccf6bc6b3d704bd21/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x3ca9d85c",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alnitak Release Smart Contract Audit/synthetix-00df930622a8ea462d15d4eccf6bc6b3d704bd21/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC721Pausable is ERC721, Pausable {\n  function approve(\n    address to,\n    uint256 tokenId\n  )\n    public\n    whenNotPaused\n  {\n    super.approve(to, tokenId);\n  }\n\n  function setApprovalForAll(\n    address to,\n    bool approved\n  )\n    public\n    whenNotPaused\n  {\n    super.setApprovalForAll(to, approved);\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n    whenNotPaused\n  {\n    super.transferFrom(from, to, tokenId);\n  }\n}",
        "function": "safeTransferFrom(address,address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-GSPI Club-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Pausable.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GFAccessControl {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender], \"not whitelisted\");\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        return _addAddressToWhitelist(addr);\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function _addAddressToWhitelist(address addr)\n        private\n        onlyCEO\n        returns (bool success)\n    {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] calldata addrs)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (_addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        return _removeAddressFromWhitelist(addr);\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function _removeAddressFromWhitelist(address addr)\n        private\n        onlyCEO\n        returns (bool success)\n    {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] calldata addrs)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (_removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    // This facet controls access control for GameAlianas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the AlianaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from AlianaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 alianas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    \n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public ceoAddress;\n    address public candidateCEOAddress;\n\n    address public cfoAddress;\n    address public cooAddress;\n\n    event SetCandidateCEO(address addr);\n    event AcceptCEO(address addr);\n    event SetCFO(address addr);\n    event SetCOO(address addr);\n\n    event Pause(address operator);\n    event Unpause(address operator);\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    /**\n     * @dev The Ownable constructor sets the original `ceoAddress` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        ceoAddress = msg.sender;\n        emit AcceptCEO(ceoAddress);\n    }\n\n    \n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress, \"not ceo\");\n        _;\n    }\n\n    \n    modifier onlyCFO() {\n        require(msg.sender == cfoAddress, \"not cfo\");\n        _;\n    }\n\n    \n    modifier onlyCOO() {\n        require(msg.sender == cooAddress, \"not coo\");\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == cooAddress ||\n                msg.sender == ceoAddress ||\n                msg.sender == cfoAddress,\n            \"not c level\"\n        );\n        _;\n    }\n\n    modifier onlyCLevelOrWhitelisted() {\n        require(\n            msg.sender == cooAddress ||\n                msg.sender == ceoAddress ||\n                msg.sender == cfoAddress ||\n                whitelist[msg.sender],\n            \"not c level or whitelisted\"\n        );\n        _;\n    }\n\n    \n    \n    function setCandidateCEO(address _candidateCEO) external onlyCEO {\n        require(_candidateCEO != address(0), \"addr can't be 0\");\n\n        candidateCEOAddress = _candidateCEO;\n        emit SetCandidateCEO(candidateCEOAddress);\n    }\n\n    \n    function acceptCEO() external {\n        require(msg.sender == candidateCEOAddress, \"you are not the candidate\");\n\n        ceoAddress = candidateCEOAddress;\n        emit AcceptCEO(ceoAddress);\n    }\n\n    \n    \n    function setCFO(address _newCFO) external onlyCEO {\n        require(_newCFO != address(0), \"addr can't be 0\");\n\n        cfoAddress = _newCFO;\n        emit SetCFO(cfoAddress);\n    }\n\n    \n    \n    function setCOO(address _newCOO) external onlyCEO {\n        require(_newCOO != address(0), \"addr can't be 0\");\n\n        cooAddress = _newCOO;\n        emit SetCOO(cooAddress);\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    \n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    \n    modifier whenPaused() {\n        require(paused, \"not paused\");\n        _;\n    }\n\n    \n    \n    function pause() external onlyCEO whenNotPaused {\n        paused = true;\n        emit Pause(msg.sender);\n    }\n\n    \n    \n    \n    \n    \n    function unpause() public onlyCEO whenPaused {\n        // can't unpause if contract was upgraded\n        paused = false;\n        emit Unpause(msg.sender);\n    }\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n    \n    \n    \n    \n    \n    \n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n        // See README.md for updgrade plan\n        newContractAddress = _v2Address;\n        emit ContractUpgrade(_v2Address);\n    }\n\n    \n    // Safety Methods\n    \n\n    \n    \n    \n    \n    function claimTokens(address token_) external onlyCEO {\n        if (token_ == address(0)) {\n            address(msg.sender).transfer(address(this).balance);\n            return;\n        }\n\n        IERC20 token = IERC20(token_);\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(address(msg.sender), balance);\n\n        emit ClaimedTokens(token_, address(msg.sender), balance);\n    }\n\n    function withdrawTokens(\n        IERC20 token_,\n        address to_,\n        uint256 amount_\n    ) external onlyCEO {\n        assert(token_.transfer(to_, amount_));\n        emit WithdrawTokens(address(token_), address(msg.sender), to_, amount_);\n    }\n\n    \n    // Events\n    \n\n    event ClaimedTokens(\n        address indexed token_,\n        address indexed controller_,\n        uint256 amount_\n    );\n\n    event WithdrawTokens(\n        address indexed token_,\n        address indexed controller_,\n        address indexed to_,\n        uint256 amount_\n    );\n}",
        "function": "claimTokens(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-Starcrazy Smart Contract Security Audit Report/starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/GFAccessControl.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract GFAccessControl {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender], \"not whitelisted\");\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        return _addAddressToWhitelist(addr);\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function _addAddressToWhitelist(address addr)\n        private\n        onlyCEO\n        returns (bool success)\n    {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] calldata addrs)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (_addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        return _removeAddressFromWhitelist(addr);\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function _removeAddressFromWhitelist(address addr)\n        private\n        onlyCEO\n        returns (bool success)\n    {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] calldata addrs)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (_removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    // This facet controls access control for GameAlianas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the AlianaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from AlianaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 alianas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    \n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public ceoAddress;\n    address public candidateCEOAddress;\n\n    address public cfoAddress;\n    address public cooAddress;\n\n    event SetCandidateCEO(address addr);\n    event AcceptCEO(address addr);\n    event SetCFO(address addr);\n    event SetCOO(address addr);\n\n    event Pause(address operator);\n    event Unpause(address operator);\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    /**\n     * @dev The Ownable constructor sets the original `ceoAddress` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        ceoAddress = msg.sender;\n        emit AcceptCEO(ceoAddress);\n    }\n\n    \n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress, \"not ceo\");\n        _;\n    }\n\n    \n    modifier onlyCFO() {\n        require(msg.sender == cfoAddress, \"not cfo\");\n        _;\n    }\n\n    \n    modifier onlyCOO() {\n        require(msg.sender == cooAddress, \"not coo\");\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == cooAddress ||\n                msg.sender == ceoAddress ||\n                msg.sender == cfoAddress,\n            \"not c level\"\n        );\n        _;\n    }\n\n    modifier onlyCLevelOrWhitelisted() {\n        require(\n            msg.sender == cooAddress ||\n                msg.sender == ceoAddress ||\n                msg.sender == cfoAddress ||\n                whitelist[msg.sender],\n            \"not c level or whitelisted\"\n        );\n        _;\n    }\n\n    \n    \n    function setCandidateCEO(address _candidateCEO) external onlyCEO {\n        require(_candidateCEO != address(0), \"addr can't be 0\");\n\n        candidateCEOAddress = _candidateCEO;\n        emit SetCandidateCEO(candidateCEOAddress);\n    }\n\n    \n    function acceptCEO() external {\n        require(msg.sender == candidateCEOAddress, \"you are not the candidate\");\n\n        ceoAddress = candidateCEOAddress;\n        emit AcceptCEO(ceoAddress);\n    }\n\n    \n    \n    function setCFO(address _newCFO) external onlyCEO {\n        require(_newCFO != address(0), \"addr can't be 0\");\n\n        cfoAddress = _newCFO;\n        emit SetCFO(cfoAddress);\n    }\n\n    \n    \n    function setCOO(address _newCOO) external onlyCEO {\n        require(_newCOO != address(0), \"addr can't be 0\");\n\n        cooAddress = _newCOO;\n        emit SetCOO(cooAddress);\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    \n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    \n    modifier whenPaused() {\n        require(paused, \"not paused\");\n        _;\n    }\n\n    \n    \n    function pause() external onlyCEO whenNotPaused {\n        paused = true;\n        emit Pause(msg.sender);\n    }\n\n    \n    \n    \n    \n    \n    function unpause() public onlyCEO whenPaused {\n        // can't unpause if contract was upgraded\n        paused = false;\n        emit Unpause(msg.sender);\n    }\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n    \n    \n    \n    \n    \n    \n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n        // See README.md for updgrade plan\n        newContractAddress = _v2Address;\n        emit ContractUpgrade(_v2Address);\n    }\n\n    \n    // Safety Methods\n    \n\n    \n    \n    \n    \n    function claimTokens(address token_) external onlyCEO {\n        if (token_ == address(0)) {\n            address(msg.sender).transfer(address(this).balance);\n            return;\n        }\n\n        IERC20 token = IERC20(token_);\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(address(msg.sender), balance);\n\n        emit ClaimedTokens(token_, address(msg.sender), balance);\n    }\n\n    function withdrawTokens(\n        IERC20 token_,\n        address to_,\n        uint256 amount_\n    ) external onlyCEO {\n        assert(token_.transfer(to_, amount_));\n        emit WithdrawTokens(address(token_), address(msg.sender), to_, amount_);\n    }\n\n    \n    // Events\n    \n\n    event ClaimedTokens(\n        address indexed token_,\n        address indexed controller_,\n        uint256 amount_\n    );\n\n    event WithdrawTokens(\n        address indexed token_,\n        address indexed controller_,\n        address indexed to_,\n        uint256 amount_\n    );\n}",
        "function": "withdrawTokens(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-Starcrazy Smart Contract Security Audit Report/starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/GFAccessControl.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract GFAccessControl {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender], \"not whitelisted\");\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        return _addAddressToWhitelist(addr);\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function _addAddressToWhitelist(address addr)\n        private\n        onlyCEO\n        returns (bool success)\n    {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] calldata addrs)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (_addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        return _removeAddressFromWhitelist(addr);\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function _removeAddressFromWhitelist(address addr)\n        private\n        onlyCEO\n        returns (bool success)\n    {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] calldata addrs)\n        external\n        onlyCEO\n        returns (bool success)\n    {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (_removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    // This facet controls access control for GameAlianas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the AlianaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from AlianaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 alianas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    \n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public ceoAddress;\n    address public candidateCEOAddress;\n\n    address public cfoAddress;\n    address public cooAddress;\n\n    event SetCandidateCEO(address addr);\n    event AcceptCEO(address addr);\n    event SetCFO(address addr);\n    event SetCOO(address addr);\n\n    event Pause(address operator);\n    event Unpause(address operator);\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    /**\n     * @dev The Ownable constructor sets the original `ceoAddress` of the contract to the sender\n     * account.\n     */\n    constructor() public {\n        ceoAddress = msg.sender;\n        emit AcceptCEO(ceoAddress);\n    }\n\n    \n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress, \"not ceo\");\n        _;\n    }\n\n    \n    modifier onlyCFO() {\n        require(msg.sender == cfoAddress, \"not cfo\");\n        _;\n    }\n\n    \n    modifier onlyCOO() {\n        require(msg.sender == cooAddress, \"not coo\");\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == cooAddress ||\n                msg.sender == ceoAddress ||\n                msg.sender == cfoAddress,\n            \"not c level\"\n        );\n        _;\n    }\n\n    modifier onlyCLevelOrWhitelisted() {\n        require(\n            msg.sender == cooAddress ||\n                msg.sender == ceoAddress ||\n                msg.sender == cfoAddress ||\n                whitelist[msg.sender],\n            \"not c level or whitelisted\"\n        );\n        _;\n    }\n\n    \n    \n    function setCandidateCEO(address _candidateCEO) external onlyCEO {\n        require(_candidateCEO != address(0), \"addr can't be 0\");\n\n        candidateCEOAddress = _candidateCEO;\n        emit SetCandidateCEO(candidateCEOAddress);\n    }\n\n    \n    function acceptCEO() external {\n        require(msg.sender == candidateCEOAddress, \"you are not the candidate\");\n\n        ceoAddress = candidateCEOAddress;\n        emit AcceptCEO(ceoAddress);\n    }\n\n    \n    \n    function setCFO(address _newCFO) external onlyCEO {\n        require(_newCFO != address(0), \"addr can't be 0\");\n\n        cfoAddress = _newCFO;\n        emit SetCFO(cfoAddress);\n    }\n\n    \n    \n    function setCOO(address _newCOO) external onlyCEO {\n        require(_newCOO != address(0), \"addr can't be 0\");\n\n        cooAddress = _newCOO;\n        emit SetCOO(cooAddress);\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    \n    modifier whenNotPaused() {\n        require(!paused, \"paused\");\n        _;\n    }\n\n    \n    modifier whenPaused() {\n        require(paused, \"not paused\");\n        _;\n    }\n\n    \n    \n    function pause() external onlyCEO whenNotPaused {\n        paused = true;\n        emit Pause(msg.sender);\n    }\n\n    \n    \n    \n    \n    \n    function unpause() public onlyCEO whenPaused {\n        // can't unpause if contract was upgraded\n        paused = false;\n        emit Unpause(msg.sender);\n    }\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n    \n    \n    \n    \n    \n    \n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n        // See README.md for updgrade plan\n        newContractAddress = _v2Address;\n        emit ContractUpgrade(_v2Address);\n    }\n\n    \n    // Safety Methods\n    \n\n    \n    \n    \n    \n    function claimTokens(address token_) external onlyCEO {\n        if (token_ == address(0)) {\n            address(msg.sender).transfer(address(this).balance);\n            return;\n        }\n\n        IERC20 token = IERC20(token_);\n        uint256 balance = token.balanceOf(address(this));\n        token.transfer(address(msg.sender), balance);\n\n        emit ClaimedTokens(token_, address(msg.sender), balance);\n    }\n\n    function withdrawTokens(\n        IERC20 token_,\n        address to_,\n        uint256 amount_\n    ) external onlyCEO {\n        assert(token_.transfer(to_, amount_));\n        emit WithdrawTokens(address(token_), address(msg.sender), to_, amount_);\n    }\n\n    \n    // Events\n    \n\n    event ClaimedTokens(\n        address indexed token_,\n        address indexed controller_,\n        uint256 amount_\n    );\n\n    event WithdrawTokens(\n        address indexed token_,\n        address indexed controller_,\n        address indexed to_,\n        uint256 amount_\n    );\n}",
        "function": "claimTokens(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-Starcrazy Smart Contract Security Audit Report/starcrazy-contracts-e9e11d234ac065726e108a73dfcd5efbad26f2c5/contract/aliana/GFAccessControl.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ERC20Token is Token {\n\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint) balances;\n    mapping (address => mapping (address => uint)) allowed;\n    uint public totalSupply;\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Exchange_v4/protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/ZRXToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Token is Token {\n\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint) balances;\n    mapping (address => mapping (address => uint)) allowed;\n    uint public totalSupply;\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Exchange_v4/protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/ZRXToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}",
        "function": "enableLostAndFound(address,uint256,address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DelegateApprovals is Owned, IDelegateApprovals {\n    bytes32 public constant BURN_FOR_ADDRESS = \"BurnForAddress\";\n    bytes32 public constant ISSUE_FOR_ADDRESS = \"IssueForAddress\";\n    bytes32 public constant CLAIM_FOR_ADDRESS = \"ClaimForAddress\";\n    bytes32 public constant EXCHANGE_FOR_ADDRESS = \"ExchangeForAddress\";\n    bytes32 public constant APPROVE_ALL = \"ApproveAll\";\n\n    bytes32[5] private _delegatableFunctions = [\n        APPROVE_ALL,\n        BURN_FOR_ADDRESS,\n        ISSUE_FOR_ADDRESS,\n        CLAIM_FOR_ADDRESS,\n        EXCHANGE_FOR_ADDRESS\n    ];\n\n    /* ========== STATE VARIABLES ========== */\n    EternalStorage public eternalStorage;\n\n    constructor(address _owner, EternalStorage _eternalStorage) public Owned(_owner) {\n        eternalStorage = _eternalStorage;\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Move it to setter and associatedState\n\n    // util to get key based on action name + address of authoriser + address for delegate\n    function _getKey(\n        bytes32 _action,\n        address _authoriser,\n        address _delegate\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_action, _authoriser, _delegate));\n    }\n\n    // hash of actionName + address of authoriser + address for the delegate\n    function canBurnFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(BURN_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(ISSUE_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(CLAIM_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(EXCHANGE_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function approvedAll(address authoriser, address delegate) public view returns (bool) {\n        return eternalStorage.getBooleanValue(_getKey(APPROVE_ALL, authoriser, delegate));\n    }\n\n    // internal function to check approval based on action\n    // if approved for all actions then will return true\n    // before checking specific approvals\n    function _checkApproval(\n        bytes32 action,\n        address authoriser,\n        address delegate\n    ) internal view returns (bool) {\n        if (approvedAll(authoriser, delegate)) return true;\n\n        return eternalStorage.getBooleanValue(_getKey(action, authoriser, delegate));\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Approve All\n    function approveAllDelegatePowers(address delegate) external {\n        _setApproval(APPROVE_ALL, msg.sender, delegate);\n    }\n\n    // Removes all delegate approvals\n    function removeAllDelegatePowers(address delegate) external {\n        for (uint i = 0; i < _delegatableFunctions.length; i++) {\n            _withdrawApproval(_delegatableFunctions[i], msg.sender, delegate);\n        }\n    }\n\n    // Burn on behalf\n    function approveBurnOnBehalf(address delegate) external {\n        _setApproval(BURN_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeBurnOnBehalf(address delegate) external {\n        _withdrawApproval(BURN_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    // Issue on behalf\n    function approveIssueOnBehalf(address delegate) external {\n        _setApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeIssueOnBehalf(address delegate) external {\n        _withdrawApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    // Claim on behalf\n    function approveClaimOnBehalf(address delegate) external {\n        _setApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeClaimOnBehalf(address delegate) external {\n        _withdrawApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    // Exchange on behalf\n    function approveExchangeOnBehalf(address delegate) external {\n        _setApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeExchangeOnBehalf(address delegate) external {\n        _withdrawApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function _setApproval(\n        bytes32 action,\n        address authoriser,\n        address delegate\n    ) internal {\n        require(delegate != address(0), \"Can't delegate to address(0)\");\n        eternalStorage.setBooleanValue(_getKey(action, authoriser, delegate), true);\n        emit Approval(authoriser, delegate, action);\n    }\n\n    function _withdrawApproval(\n        bytes32 action,\n        address authoriser,\n        address delegate\n    ) internal {\n        // Check approval is set otherwise skip deleting approval\n        if (eternalStorage.getBooleanValue(_getKey(action, authoriser, delegate))) {\n            eternalStorage.deleteBooleanValue(_getKey(action, authoriser, delegate));\n            emit WithdrawApproval(authoriser, delegate, action);\n        }\n    }\n\n    function setEternalStorage(EternalStorage _eternalStorage) external onlyOwner {\n        require(address(_eternalStorage) != address(0), \"Can't set eternalStorage to address(0)\");\n        eternalStorage = _eternalStorage;\n        emit EternalStorageUpdated(address(eternalStorage));\n    }\n\n    /* ========== EVENTS ========== */\n    event Approval(address indexed authoriser, address delegate, bytes32 action);\n    event WithdrawApproval(address indexed authoriser, address delegate, bytes32 action);\n    event EternalStorageUpdated(address newEternalStorage);\n}",
        "function": "0x7d3f0ba2",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Aloith Release Smart Contract Audit/synthetix-b16096e70ab88eff7d0e423974a2958edff42b2a/contracts/DelegateApprovals.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract DelegateApprovals is Owned, IDelegateApprovals {\n    bytes32 public constant BURN_FOR_ADDRESS = \"BurnForAddress\";\n    bytes32 public constant ISSUE_FOR_ADDRESS = \"IssueForAddress\";\n    bytes32 public constant CLAIM_FOR_ADDRESS = \"ClaimForAddress\";\n    bytes32 public constant EXCHANGE_FOR_ADDRESS = \"ExchangeForAddress\";\n    bytes32 public constant APPROVE_ALL = \"ApproveAll\";\n\n    bytes32[5] private _delegatableFunctions = [\n        APPROVE_ALL,\n        BURN_FOR_ADDRESS,\n        ISSUE_FOR_ADDRESS,\n        CLAIM_FOR_ADDRESS,\n        EXCHANGE_FOR_ADDRESS\n    ];\n\n    /* ========== STATE VARIABLES ========== */\n    EternalStorage public eternalStorage;\n\n    constructor(address _owner, EternalStorage _eternalStorage) public Owned(_owner) {\n        eternalStorage = _eternalStorage;\n    }\n\n    /* ========== VIEWS ========== */\n\n    // Move it to setter and associatedState\n\n    // util to get key based on action name + address of authoriser + address for delegate\n    function _getKey(\n        bytes32 _action,\n        address _authoriser,\n        address _delegate\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_action, _authoriser, _delegate));\n    }\n\n    // hash of actionName + address of authoriser + address for the delegate\n    function canBurnFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(BURN_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function canIssueFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(ISSUE_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function canClaimFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(CLAIM_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function canExchangeFor(address authoriser, address delegate) external view returns (bool) {\n        return _checkApproval(EXCHANGE_FOR_ADDRESS, authoriser, delegate);\n    }\n\n    function approvedAll(address authoriser, address delegate) public view returns (bool) {\n        return eternalStorage.getBooleanValue(_getKey(APPROVE_ALL, authoriser, delegate));\n    }\n\n    // internal function to check approval based on action\n    // if approved for all actions then will return true\n    // before checking specific approvals\n    function _checkApproval(\n        bytes32 action,\n        address authoriser,\n        address delegate\n    ) internal view returns (bool) {\n        if (approvedAll(authoriser, delegate)) return true;\n\n        return eternalStorage.getBooleanValue(_getKey(action, authoriser, delegate));\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Approve All\n    function approveAllDelegatePowers(address delegate) external {\n        _setApproval(APPROVE_ALL, msg.sender, delegate);\n    }\n\n    // Removes all delegate approvals\n    function removeAllDelegatePowers(address delegate) external {\n        for (uint i = 0; i < _delegatableFunctions.length; i++) {\n            _withdrawApproval(_delegatableFunctions[i], msg.sender, delegate);\n        }\n    }\n\n    // Burn on behalf\n    function approveBurnOnBehalf(address delegate) external {\n        _setApproval(BURN_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeBurnOnBehalf(address delegate) external {\n        _withdrawApproval(BURN_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    // Issue on behalf\n    function approveIssueOnBehalf(address delegate) external {\n        _setApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeIssueOnBehalf(address delegate) external {\n        _withdrawApproval(ISSUE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    // Claim on behalf\n    function approveClaimOnBehalf(address delegate) external {\n        _setApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeClaimOnBehalf(address delegate) external {\n        _withdrawApproval(CLAIM_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    // Exchange on behalf\n    function approveExchangeOnBehalf(address delegate) external {\n        _setApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function removeExchangeOnBehalf(address delegate) external {\n        _withdrawApproval(EXCHANGE_FOR_ADDRESS, msg.sender, delegate);\n    }\n\n    function _setApproval(\n        bytes32 action,\n        address authoriser,\n        address delegate\n    ) internal {\n        require(delegate != address(0), \"Can't delegate to address(0)\");\n        eternalStorage.setBooleanValue(_getKey(action, authoriser, delegate), true);\n        emit Approval(authoriser, delegate, action);\n    }\n\n    function _withdrawApproval(\n        bytes32 action,\n        address authoriser,\n        address delegate\n    ) internal {\n        // Check approval is set otherwise skip deleting approval\n        if (eternalStorage.getBooleanValue(_getKey(action, authoriser, delegate))) {\n            eternalStorage.deleteBooleanValue(_getKey(action, authoriser, delegate));\n            emit WithdrawApproval(authoriser, delegate, action);\n        }\n    }\n\n    function setEternalStorage(EternalStorage _eternalStorage) external onlyOwner {\n        require(address(_eternalStorage) != address(0), \"Can't set eternalStorage to address(0)\");\n        eternalStorage = _eternalStorage;\n        emit EternalStorageUpdated(address(eternalStorage));\n    }\n\n    /* ========== EVENTS ========== */\n    event Approval(address indexed authoriser, address delegate, bytes32 action);\n    event WithdrawApproval(address indexed authoriser, address delegate, bytes32 action);\n    event EternalStorageUpdated(address newEternalStorage);\n}",
        "function": "0x7d3f0ba2",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Aloith Release Smart Contract Audit/synthetix-b16096e70ab88eff7d0e423974a2958edff42b2a/contracts/DelegateApprovals.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xbe766f1b",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xa4b19654",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x78bbae9b",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x3f2a25ec",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xf06f300d",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x84f87758",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xa4b19654",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xb79650a4",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x76eec08",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xe3a85ce4",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x301d5e1",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0xcc12cb28",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x4b368768",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "function": "0x82e2fa24",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}",
        "function": "0xc4493813",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "approve(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "0x6aaa6a86",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "function": "transferFrom(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "deposit(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "deposit(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "0x1de0af6b",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "withdraw(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BbtcPool is IWbtcPoolBase {\n  using SafeERC20 for IERC20;\n\n  CurveInterfaceBbtc public pool_deposit;\n\n  constructor() public{\n    name = \"Bbtc\";\n    lp_token_addr = address(0x410e3E86ef427e30B9235497143881f717d93c2A);\n    pool_deposit = CurveInterfaceBbtc(0xC45b2EEe6e09cA176Ca3bB5f7eEe7C47bF93c756);\n  }\n\n  //@_amount: wbtc amount\n  function deposit_wbtc(uint256 _amount) internal {\n    IERC20(wbtc).approve(address(pool_deposit), 0);\n    IERC20(wbtc).approve(address(pool_deposit), _amount);\n    uint256[4] memory uamounts = [uint256(0), 0, _amount, 0];\n    pool_deposit.add_liquidity(uamounts, 0);\n  }\n\n\n  function withdraw_from_curve(uint256 _amount) internal{\n    require(_amount <= get_lp_token_balance(), \"withdraw_from_curve: too large amount\");\n    IERC20(lp_token_addr).approve(address(pool_deposit), 0);\n    IERC20(lp_token_addr).approve(address(pool_deposit), _amount);\n    pool_deposit.remove_liquidity_one_coin(_amount, 2, 0);\n  }\n\n  function get_virtual_price() public view returns(uint256){\n    return PriceInterfaceWbtc(pool_deposit.pool()).get_virtual_price();\n  }\n}",
        "function": "deposit(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/core/btcpool/BbtcPool.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "0xd64ad924",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "cost(address,uint256,bytes,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "0xefb02bca",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "withdrawal(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "requestCosign(address,uint256,bytes,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "requestCosign(address,uint256,bytes,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "claim(address,uint256,bytes)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "function": "setUrl(string)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Escrow is Secondary {\n    using SafeMath for uint256;\n\n    event Deposited(address indexed payee, uint256 weiAmount);\n    event Withdrawn(address indexed payee, uint256 weiAmount);\n\n    mapping(address => uint256) private _deposits;\n\n    function depositsOf(address payee) public view returns (uint256) {\n        return _deposits[payee];\n    }\n\n    /**\n     * @dev Stores the sent amount as credit to be withdrawn.\n     * @param payee The destination address of the funds.\n     */\n    function deposit(address payee) public onlyPrimary payable {\n        uint256 amount = msg.value;\n        _deposits[payee] = _deposits[payee].add(amount);\n\n        emit Deposited(payee, amount);\n    }\n\n    /**\n     * @dev Withdraw accumulated balance for a payee.\n     * @param payee The address whose funds will be withdrawn and transferred to.\n     */\n    function withdraw(address payable payee) public onlyPrimary {\n        uint256 payment = _deposits[payee];\n\n        _deposits[payee] = 0;\n\n        payee.transfer(payment);\n\n        emit Withdrawn(payee, payment);\n    }\n}",
        "function": "withdraw(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-UNILAYERX/openzeppelin-contracts-2.3.0/contracts/mocks/PullPaymentMock.sol",
        "vulnerability": "Transaction Ordering Dependence",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PullPaymentMock is PullPayment {\n    constructor () public payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // test helper function to call asyncTransfer\n    function callTransfer(address dest, uint256 amount) public {\n        _asyncTransfer(dest, amount);\n    }\n}",
        "function": "withdrawPayments(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-UNILAYERX/openzeppelin-contracts-2.3.0/contracts/mocks/PullPaymentMock.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PullPaymentMock is PullPayment {\n    constructor () public payable {\n        // solhint-disable-previous-line no-empty-blocks\n    }\n\n    // test helper function to call asyncTransfer\n    function callTransfer(address dest, uint256 amount) public {\n        _asyncTransfer(dest, amount);\n    }\n}",
        "function": "callTransfer(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-UNILAYERX/openzeppelin-contracts-2.3.0/contracts/mocks/PullPaymentMock.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}",
        "function": "getRealTokenAmount(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}",
        "function": "getRealTokenAmount(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}",
        "function": "getRealTokenAmount(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xb01a9fb3",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xf982bac",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0x5d601c3a",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0x746199f9",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xf982bac",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xb01a9fb3",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0x746199f9",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "function": "0xe9356c6f",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MockMutator {\n    uint256 public count;\n\n    function read() external view returns (uint) {\n        return count;\n    }\n\n    function update() external {\n        count = count + 1;\n    }\n}",
        "function": "update()",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-SPICE/synthetix-develop/contracts/test-helpers/MockMutator.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}",
        "function": "setPaused(bool)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/legacy/common/Pausable.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0xd0d3d62a",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x15987eb6",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x15987eb6",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x3ca9d85c",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x6e13fe76",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}",
        "function": "setPaused(bool)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-b1bbcf88cc3f49e5d67954003313ede4520ba00a/legacy/common/Pausable.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TestablePausable is Owned, Pausable {\n    uint public someValue;\n\n    constructor(address _owner) public Owned(_owner) Pausable() {}\n\n    function setSomeValue(uint _value) external notPaused {\n        someValue = _value;\n    }\n}",
        "function": "nominateNewOwner(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-bb4c0f3a52db71d03e4630dd9a603247e45dd01d/contracts/test-helpers/TestablePausable.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenExchanger is Owned {\n    address public integrationProxy;\n    address public synthetix;\n\n    constructor(address _owner, address _integrationProxy) public Owned(_owner) {\n        integrationProxy = _integrationProxy;\n    }\n\n    function setSynthetixProxy(address _integrationProxy) external onlyOwner {\n        integrationProxy = _integrationProxy;\n    }\n\n    function setSynthetix(address _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n    }\n\n    function checkBalance(address account) public view synthetixProxyIsSet returns (uint) {\n        return IERC20(integrationProxy).balanceOf(account);\n    }\n\n    function checkAllowance(address tokenOwner, address spender) public view synthetixProxyIsSet returns (uint) {\n        return IERC20(integrationProxy).allowance(tokenOwner, spender);\n    }\n\n    function checkBalanceSNXDirect(address account) public view synthetixProxyIsSet returns (uint) {\n        return IERC20(synthetix).balanceOf(account);\n    }\n\n    function getDecimals(address tokenAddress) public view returns (uint) {\n        return IERC20(tokenAddress).decimals();\n    }\n\n    function doTokenSpend(\n        address fromAccount,\n        address toAccount,\n        uint amount\n    ) public synthetixProxyIsSet returns (bool) {\n        // Call Immutable static call #1\n        require(checkBalance(fromAccount) >= amount, \"fromAccount does not have the required balance to spend\");\n\n        // Call Immutable static call #2\n        require(\n            checkAllowance(fromAccount, address(this)) >= amount,\n            \"I TokenExchanger, do not have approval to spend this guys tokens\"\n        );\n\n        // Call Mutable call\n        return IERC20(integrationProxy).transferFrom(fromAccount, toAccount, amount);\n    }\n\n    modifier synthetixProxyIsSet {\n        require(integrationProxy != address(0), \"Synthetix Integration proxy address not set\");\n        _;\n    }\n\n    event LogString(string name, string value);\n    event LogInt(string name, uint value);\n    event LogAddress(string name, address value);\n    event LogBytes(string name, bytes4 value);\n}",
        "function": "checkAllowance(address,address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-09a0e0122c4e4439d96a1e761c6e2c0c4c81233b/contracts/test-helpers/TokenExchanger.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EvilToken is FaucetToken {\n    bool public fail;\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n        FaucetToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n        fail = true;\n    }\n\n    function setFail(bool _fail) external {\n        fail = _fail;\n    }\n\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        if (fail) {\n            return false;\n        }\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n        balanceOf[dst] = balanceOf[dst].add(amount);\n        emit Transfer(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        if (fail) {\n            return false;\n        }\n        balanceOf[src] = balanceOf[src].sub(amount);\n        balanceOf[dst] = balanceOf[dst].add(amount);\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount);\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EvilToken is FaucetToken {\n    bool public fail;\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n        FaucetToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n        fail = true;\n    }\n\n    function setFail(bool _fail) external {\n        fail = _fail;\n    }\n\n    function transfer(address dst, uint256 amount) external returns (bool) {\n        if (fail) {\n            return false;\n        }\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(amount);\n        balanceOf[dst] = balanceOf[dst].add(amount);\n        emit Transfer(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 amount) external returns (bool) {\n        if (fail) {\n            return false;\n        }\n        balanceOf[src] = balanceOf[src].sub(amount);\n        balanceOf[dst] = balanceOf[dst].add(amount);\n        allowance[src][msg.sender] = allowance[src][msg.sender].sub(amount);\n        emit Transfer(src, dst, amount);\n        return true;\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FaucetNonStandardToken is NonStandardToken {\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n        NonStandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf[_owner] += value;\n        totalSupply += value;\n        emit Transfer(address(this), _owner, value);\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FaucetNonStandardToken is NonStandardToken {\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n        NonStandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf[_owner] += value;\n        totalSupply += value;\n        emit Transfer(address(this), _owner, value);\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FaucetToken is StandardToken {\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n        StandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf[_owner] += value;\n        totalSupply += value;\n        emit Transfer(address(this), _owner, value);\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FaucetToken is StandardToken {\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol) public\n        StandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) {\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf[_owner] += value;\n        totalSupply += value;\n        emit Transfer(address(this), _owner, value);\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FaucetTokenReEntrantHarness {\n    using SafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 totalSupply_;\n    mapping (address => mapping (address => uint256)) allowance_;\n    mapping (address => uint256) balanceOf_;\n\n    bytes public reEntryCallData;\n    string public reEntryFun;\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n        totalSupply_ = _initialAmount;\n        balanceOf_[msg.sender] = _initialAmount;\n        name = _tokenName;\n        symbol = _tokenSymbol;\n        decimals = _decimalUnits;\n        reEntryCallData = _reEntryCallData;\n        reEntryFun = _reEntryFun;\n    }\n\n    modifier reEnter(string memory funName) {\n        string memory _reEntryFun = reEntryFun;\n        if (compareStrings(_reEntryFun, funName)) {\n            reEntryFun = \"\"; // Clear re-entry fun\n            (bool success, bytes memory returndata) = msg.sender.call(reEntryCallData);\n            assembly {\n                if eq(success, 0) {\n                    revert(add(returndata, 0x20), returndatasize())\n                }\n            }\n        }\n\n        _;\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf_[_owner] += value;\n        totalSupply_ += value;\n        emit Transfer(address(this), _owner, value);\n    }\n\n    function totalSupply() public reEnter(\"totalSupply\") returns (uint256) {\n        return totalSupply_;\n    }\n\n    function allowance(address owner, address spender) public reEnter(\"allowance\") returns (uint256 remaining) {\n        return allowance_[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public reEnter(\"approve\") returns (bool success) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public reEnter(\"balanceOf\") returns (uint256 balance) {\n        return balanceOf_[owner];\n    }\n\n    function transfer(address dst, uint256 amount) public reEnter(\"transfer\") returns (bool success) {\n        _transfer(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 amount) public reEnter(\"transferFrom\") returns (bool success) {\n        _transfer(src, dst, amount);\n        _approve(src, msg.sender, allowance_[src][msg.sender].sub(amount));\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n        allowance_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address src, address dst, uint256 amount) internal {\n        require(dst != address(0));\n        balanceOf_[src] = balanceOf_[src].sub(amount);\n        balanceOf_[dst] = balanceOf_[dst].add(amount);\n        emit Transfer(src, dst, amount);\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FaucetTokenReEntrantHarness {\n    using SafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 totalSupply_;\n    mapping (address => mapping (address => uint256)) allowance_;\n    mapping (address => uint256) balanceOf_;\n\n    bytes public reEntryCallData;\n    string public reEntryFun;\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n        totalSupply_ = _initialAmount;\n        balanceOf_[msg.sender] = _initialAmount;\n        name = _tokenName;\n        symbol = _tokenSymbol;\n        decimals = _decimalUnits;\n        reEntryCallData = _reEntryCallData;\n        reEntryFun = _reEntryFun;\n    }\n\n    modifier reEnter(string memory funName) {\n        string memory _reEntryFun = reEntryFun;\n        if (compareStrings(_reEntryFun, funName)) {\n            reEntryFun = \"\"; // Clear re-entry fun\n            (bool success, bytes memory returndata) = msg.sender.call(reEntryCallData);\n            assembly {\n                if eq(success, 0) {\n                    revert(add(returndata, 0x20), returndatasize())\n                }\n            }\n        }\n\n        _;\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf_[_owner] += value;\n        totalSupply_ += value;\n        emit Transfer(address(this), _owner, value);\n    }\n\n    function totalSupply() public reEnter(\"totalSupply\") returns (uint256) {\n        return totalSupply_;\n    }\n\n    function allowance(address owner, address spender) public reEnter(\"allowance\") returns (uint256 remaining) {\n        return allowance_[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public reEnter(\"approve\") returns (bool success) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public reEnter(\"balanceOf\") returns (uint256 balance) {\n        return balanceOf_[owner];\n    }\n\n    function transfer(address dst, uint256 amount) public reEnter(\"transfer\") returns (bool success) {\n        _transfer(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 amount) public reEnter(\"transferFrom\") returns (bool success) {\n        _transfer(src, dst, amount);\n        _approve(src, msg.sender, allowance_[src][msg.sender].sub(amount));\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n        allowance_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address src, address dst, uint256 amount) internal {\n        require(dst != address(0));\n        balanceOf_[src] = balanceOf_[src].sub(amount);\n        balanceOf_[dst] = balanceOf_[dst].add(amount);\n        emit Transfer(src, dst, amount);\n    }\n}",
        "function": "totalSupply()",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FaucetTokenReEntrantHarness {\n    using SafeMath for uint256;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 totalSupply_;\n    mapping (address => mapping (address => uint256)) allowance_;\n    mapping (address => uint256) balanceOf_;\n\n    bytes public reEntryCallData;\n    string public reEntryFun;\n\n    constructor(uint256 _initialAmount, string memory _tokenName, uint8 _decimalUnits, string memory _tokenSymbol, bytes memory _reEntryCallData, string memory _reEntryFun) public {\n        totalSupply_ = _initialAmount;\n        balanceOf_[msg.sender] = _initialAmount;\n        name = _tokenName;\n        symbol = _tokenSymbol;\n        decimals = _decimalUnits;\n        reEntryCallData = _reEntryCallData;\n        reEntryFun = _reEntryFun;\n    }\n\n    modifier reEnter(string memory funName) {\n        string memory _reEntryFun = reEntryFun;\n        if (compareStrings(_reEntryFun, funName)) {\n            reEntryFun = \"\"; // Clear re-entry fun\n            (bool success, bytes memory returndata) = msg.sender.call(reEntryCallData);\n            assembly {\n                if eq(success, 0) {\n                    revert(add(returndata, 0x20), returndatasize())\n                }\n            }\n        }\n\n        _;\n    }\n\n    function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b)));\n    }\n\n    function allocateTo(address _owner, uint256 value) public {\n        balanceOf_[_owner] += value;\n        totalSupply_ += value;\n        emit Transfer(address(this), _owner, value);\n    }\n\n    function totalSupply() public reEnter(\"totalSupply\") returns (uint256) {\n        return totalSupply_;\n    }\n\n    function allowance(address owner, address spender) public reEnter(\"allowance\") returns (uint256 remaining) {\n        return allowance_[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public reEnter(\"approve\") returns (bool success) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public reEnter(\"balanceOf\") returns (uint256 balance) {\n        return balanceOf_[owner];\n    }\n\n    function transfer(address dst, uint256 amount) public reEnter(\"transfer\") returns (bool success) {\n        _transfer(msg.sender, dst, amount);\n        return true;\n    }\n\n    function transferFrom(address src, address dst, uint256 amount) public reEnter(\"transferFrom\") returns (bool success) {\n        _transfer(src, dst, amount);\n        _approve(src, msg.sender, allowance_[src][msg.sender].sub(amount));\n        return true;\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n        allowance_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _transfer(address src, address dst, uint256 amount) internal {\n        require(dst != address(0));\n        balanceOf_[src] = balanceOf_[src].sub(amount);\n        balanceOf_[dst] = balanceOf_[dst].add(amount);\n        emit Transfer(src, dst, amount);\n    }\n}",
        "function": "allocateTo(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-C.R.E.A.M. Finance-Compound Protocol/compound-protocol-23a4ae93adc70334553f5a83429a4e967c1eefaa/tests/Contracts/EvilToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "function": "release(address,address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "function": "transferToken(address,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "function": "release(address,address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "function": "release(address,address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "function": "release(address,address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "function": "release(address,address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract BasicProjectWallet is ProjectWallet {\n\n    address private token;\n    address private authoriser;\n    bytes32 public name;\n\n  /**\n   * @dev Constructor\n   * @param _token address The ixo token address\n   * @param _authoriser address The address of the contract that\n   * @param _name bytes32 The project name\n   */\n    constructor(address _token, address _authoriser, bytes32 _name) public {\n        token = _token;\n        authoriser = _authoriser;\n        name = _name;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the authoriser.\n    */\n    modifier onlyAuthoriser() {\n        require(msg.sender == authoriser, \"Permission denied\");\n        _;\n    }\n\n  /**\n   * @dev Transfer tokens to the receiver\n   * @param _receiver The address which will receive the funds.\n   * @param _amt The amount of tokens to transfer.\n   */\n    function transfer(\n        address _receiver,\n        uint256 _amt\n    )\n    public onlyAuthoriser\n    returns (bool)\n    {\n        ERC20(token).transfer(_receiver, _amt);\n    }\n\n}",
        "function": "transfer(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/project/BasicProjectWallet.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EternalStorage {\n    \n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    \n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string memory _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes memory _value) internal {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    // deleteArray functions\n    \n    \n    \n    \n    \n    \n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string memory _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArray(bytes32 _key, address[] memory _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] memory _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\n        return uintArrayStorage[_key];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\n        return bytesStorage[_variable];\n    }\n\n}",
        "function": "getArrayBytes32(bytes32)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Polymath Core Audit/polymath-core-bdb055769dd87a09327c6200aed5d994ab0237e8/contracts/storage/EternalStorage.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EternalStorage {\n    \n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    \n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string memory _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes memory _value) internal {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    // deleteArray functions\n    \n    \n    \n    \n    \n    \n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string memory _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArray(bytes32 _key, address[] memory _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] memory _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\n        return uintArrayStorage[_key];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\n        return bytesStorage[_variable];\n    }\n\n}",
        "function": "getArrayAddress(bytes32)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Polymath Core Audit/polymath-core-bdb055769dd87a09327c6200aed5d994ab0237e8/contracts/storage/EternalStorage.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EternalStorage {\n    \n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    \n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string memory _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes memory _value) internal {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    // deleteArray functions\n    \n    \n    \n    \n    \n    \n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string memory _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArray(bytes32 _key, address[] memory _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] memory _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\n        return uintArrayStorage[_key];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\n        return bytesStorage[_variable];\n    }\n\n}",
        "function": "getArrayBytes32(bytes32)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Polymath Core Audit/polymath-core-bdb055769dd87a09327c6200aed5d994ab0237e8/contracts/storage/EternalStorage.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EternalStorage {\n    \n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    \n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string memory _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes memory _value) internal {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    // deleteArray functions\n    \n    \n    \n    \n    \n    \n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string memory _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArray(bytes32 _key, address[] memory _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] memory _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\n        return uintArrayStorage[_key];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\n        return bytesStorage[_variable];\n    }\n\n}",
        "function": "getArrayUint(bytes32)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Polymath Core Audit/polymath-core-bdb055769dd87a09327c6200aed5d994ab0237e8/contracts/storage/EternalStorage.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EternalStorage {\n    \n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    \n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string memory _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes memory _value) internal {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    // deleteArray functions\n    \n    \n    \n    \n    \n    \n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string memory _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArray(bytes32 _key, address[] memory _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] memory _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\n        return uintArrayStorage[_key];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\n        return bytesStorage[_variable];\n    }\n\n}",
        "function": "getArrayAddress(bytes32)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Polymath Core Audit/polymath-core-bdb055769dd87a09327c6200aed5d994ab0237e8/contracts/storage/EternalStorage.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract EternalStorage {\n    \n    mapping(bytes32 => uint256) internal uintStorage;\n    mapping(bytes32 => string) internal stringStorage;\n    mapping(bytes32 => address) internal addressStorage;\n    mapping(bytes32 => bytes) internal bytesStorage;\n    mapping(bytes32 => bool) internal boolStorage;\n    mapping(bytes32 => int256) internal intStorage;\n    mapping(bytes32 => bytes32) internal bytes32Storage;\n\n    \n    mapping(bytes32 => bytes32[]) internal bytes32ArrayStorage;\n    mapping(bytes32 => uint256[]) internal uintArrayStorage;\n    mapping(bytes32 => address[]) internal addressArrayStorage;\n    mapping(bytes32 => string[]) internal stringArrayStorage;\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function set(bytes32 _key, uint256 _value) internal {\n        uintStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, address _value) internal {\n        addressStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bool _value) internal {\n        boolStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes32 _value) internal {\n        bytes32Storage[_key] = _value;\n    }\n\n    function set(bytes32 _key, string memory _value) internal {\n        stringStorage[_key] = _value;\n    }\n\n    function set(bytes32 _key, bytes memory _value) internal {\n        bytesStorage[_key] = _value;\n    }\n\n    \n    // deleteArray functions\n    \n    \n    \n    \n    \n    \n\n    //Deletes from mapping (bytes32 => array[]) at index _index\n    function deleteArrayAddress(bytes32 _key, uint256 _index) internal {\n        address[] storage array = addressArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => bytes32[]) at index _index\n    function deleteArrayBytes32(bytes32 _key, uint256 _index) internal {\n        bytes32[] storage array = bytes32ArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => uint[]) at index _index\n    function deleteArrayUint(bytes32 _key, uint256 _index) internal {\n        uint256[] storage array = uintArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    //Deletes from mapping (bytes32 => string[]) at index _index\n    function deleteArrayString(bytes32 _key, uint256 _index) internal {\n        string[] storage array = stringArrayStorage[_key];\n        require(_index < array.length, \"Index should less than length of the array\");\n        array[_index] = array[array.length - 1];\n        array.length = array.length - 1;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    \n    \n    \n    function pushArray(bytes32 _key, address _value) internal {\n        addressArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, bytes32 _value) internal {\n        bytes32ArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, string memory _value) internal {\n        stringArrayStorage[_key].push(_value);\n    }\n\n    function pushArray(bytes32 _key, uint256 _value) internal {\n        uintArrayStorage[_key].push(_value);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArray(bytes32 _key, address[] memory _value) internal {\n        addressArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, uint256[] memory _value) internal {\n        uintArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, bytes32[] memory _value) internal {\n        bytes32ArrayStorage[_key] = _value;\n    }\n\n    function setArray(bytes32 _key, string[] memory _value) internal {\n        stringArrayStorage[_key] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getArrayAddress(bytes32 _key) public view returns(address[] memory) {\n        return addressArrayStorage[_key];\n    }\n\n    function getArrayBytes32(bytes32 _key) public view returns(bytes32[] memory) {\n        return bytes32ArrayStorage[_key];\n    }\n\n    function getArrayUint(bytes32 _key) public view returns(uint[] memory) {\n        return uintArrayStorage[_key];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, address _value) internal {\n        addressArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, uint256 _value) internal {\n        uintArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, bytes32 _value) internal {\n        bytes32ArrayStorage[_key][_index] = _value;\n    }\n\n    function setArrayIndexValue(bytes32 _key, uint256 _index, string memory _value) internal {\n        stringArrayStorage[_key][_index] = _value;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    function getUintValue(bytes32 _variable) public view returns(uint256) {\n        return uintStorage[_variable];\n    }\n\n    function getBoolValue(bytes32 _variable) public view returns(bool) {\n        return boolStorage[_variable];\n    }\n\n    function getStringValue(bytes32 _variable) public view returns(string memory) {\n        return stringStorage[_variable];\n    }\n\n    function getAddressValue(bytes32 _variable) public view returns(address) {\n        return addressStorage[_variable];\n    }\n\n    function getBytes32Value(bytes32 _variable) public view returns(bytes32) {\n        return bytes32Storage[_variable];\n    }\n\n    function getBytesValue(bytes32 _variable) public view returns(bytes memory) {\n        return bytesStorage[_variable];\n    }\n\n}",
        "function": "getArrayUint(bytes32)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Polymath Core Audit/polymath-core-bdb055769dd87a09327c6200aed5d994ab0237e8/contracts/storage/EternalStorage.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n    bytes32 internal constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\n\n    function importFeeWithdrawalData(address[] calldata accounts, uint[] calldata feePeriodIDs)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}",
        "function": "importFeeWithdrawalData(address[],uint256[])",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Alkaid Release Smart Contract Audit/synthetix-e06e164121715646706a4db5b9705f3c18ef410c/contracts/FeePoolEternalStorage.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x3ca9d85c",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x15987eb6",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0xd0d3d62a",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x15987eb6",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "function": "0x6e13fe76",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardEscrow is Owned {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint constant TIME_INDEX = 0;\n    uint constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(_feePool);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2]) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2]) {\n        uint index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520]) {\n        uint[520] memory _result;\n        uint schedules = numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) public onlyFeePool {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= synthetix.balanceOf(this),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            synthetix.transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}",
        "function": "vestingSchedules(address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/RewardEscrow.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MockRewardsRecipient is RewardsDistributionRecipient {\n    uint256 public rewardsAvailable;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    function notifyRewardAmount(uint256 reward) external onlyRewardsDistribution {\n        rewardsAvailable = rewardsAvailable + reward;\n        emit RewardAdded(reward);\n    }\n\n    event RewardAdded(uint256 amount);\n}",
        "function": "0x3c6b16ab",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/contracts/test-helpers/MockRewardsRecipient.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n    bytes32 internal constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\n\n    function importFeeWithdrawalData(address[] calldata accounts, uint[] calldata feePeriodIDs)\n        external\n        onlyOwner\n        onlyDuringSetup\n    {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}",
        "function": "importFeeWithdrawalData(address[],uint256[])",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-119164e1624309606db3edd806c520cdd8937743/contracts/FeePoolEternalStorage.sol",
        "vulnerability": "Time Manipulation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MockExchanger {\n    uint256 private _mockReclaimAmount;\n    uint256 private _mockRefundAmount;\n    uint256 private _mockNumEntries;\n    uint256 private _mockMaxSecsLeft;\n\n    ISynthetix public synthetix;\n\n    constructor(ISynthetix _synthetix) public {\n        synthetix = _synthetix;\n    }\n\n    // Mock settle function\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint256 reclaimed,\n            uint256 refunded,\n            uint numEntriesSettled\n        )\n    {\n        if (_mockReclaimAmount > 0) {\n            synthetix.synths(currencyKey).burn(from, _mockReclaimAmount);\n        }\n\n        if (_mockRefundAmount > 0) {\n            synthetix.synths(currencyKey).issue(from, _mockRefundAmount);\n        }\n\n        _mockMaxSecsLeft = 0;\n\n        return (_mockReclaimAmount, _mockRefundAmount, _mockNumEntries);\n    }\n\n    // silence compiler warnings for args\n    function maxSecsLeftInWaitingPeriod(\n        address, /* account */\n        bytes32 /* currencyKey */\n    ) public view returns (uint) {\n        return _mockMaxSecsLeft;\n    }\n\n    // silence compiler warnings for args\n    function settlementOwing(\n        address, /* account */\n        bytes32 /* currencyKey */\n    )\n        public\n        view\n        returns (\n            uint,\n            uint,\n            uint\n        )\n    {\n        return (_mockReclaimAmount, _mockRefundAmount, _mockNumEntries);\n    }\n\n    // silence compiler warnings for args\n    function hasWaitingPeriodOrSettlementOwing(\n        address, /* account */\n        bytes32 /* currencyKey */\n    ) external view returns (bool) {\n        if (_mockMaxSecsLeft > 0) {\n            return true;\n        }\n\n        if (_mockReclaimAmount > 0 || _mockRefundAmount > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function setReclaim(uint256 _reclaimAmount) external {\n        _mockReclaimAmount = _reclaimAmount;\n    }\n\n    function setRefund(uint256 _refundAmount) external {\n        _mockRefundAmount = _refundAmount;\n    }\n\n    function setNumEntries(uint256 _numEntries) external {\n        _mockNumEntries = _numEntries;\n    }\n\n    function setMaxSecsLeft(uint _maxSecsLeft) external {\n        _mockMaxSecsLeft = _maxSecsLeft;\n    }\n}",
        "function": "0x1b16802c",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-119164e1624309606db3edd806c520cdd8937743/contracts/test-helpers/MockExchanger.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract MockExchanger {\n    uint256 private _mockReclaimAmount;\n    uint256 private _mockRefundAmount;\n    uint256 private _mockNumEntries;\n    uint256 private _mockMaxSecsLeft;\n\n    ISynthetix public synthetix;\n\n    constructor(ISynthetix _synthetix) public {\n        synthetix = _synthetix;\n    }\n\n    // Mock settle function\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint256 reclaimed,\n            uint256 refunded,\n            uint numEntriesSettled\n        )\n    {\n        if (_mockReclaimAmount > 0) {\n            synthetix.synths(currencyKey).burn(from, _mockReclaimAmount);\n        }\n\n        if (_mockRefundAmount > 0) {\n            synthetix.synths(currencyKey).issue(from, _mockRefundAmount);\n        }\n\n        _mockMaxSecsLeft = 0;\n\n        return (_mockReclaimAmount, _mockRefundAmount, _mockNumEntries);\n    }\n\n    // silence compiler warnings for args\n    function maxSecsLeftInWaitingPeriod(\n        address, /* account */\n        bytes32 /* currencyKey */\n    ) public view returns (uint) {\n        return _mockMaxSecsLeft;\n    }\n\n    // silence compiler warnings for args\n    function settlementOwing(\n        address, /* account */\n        bytes32 /* currencyKey */\n    )\n        public\n        view\n        returns (\n            uint,\n            uint,\n            uint\n        )\n    {\n        return (_mockReclaimAmount, _mockRefundAmount, _mockNumEntries);\n    }\n\n    // silence compiler warnings for args\n    function hasWaitingPeriodOrSettlementOwing(\n        address, /* account */\n        bytes32 /* currencyKey */\n    ) external view returns (bool) {\n        if (_mockMaxSecsLeft > 0) {\n            return true;\n        }\n\n        if (_mockReclaimAmount > 0 || _mockRefundAmount > 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    function setReclaim(uint256 _reclaimAmount) external {\n        _mockReclaimAmount = _reclaimAmount;\n    }\n\n    function setRefund(uint256 _refundAmount) external {\n        _mockRefundAmount = _refundAmount;\n    }\n\n    function setNumEntries(uint256 _numEntries) external {\n        _mockNumEntries = _numEntries;\n    }\n\n    function setMaxSecsLeft(uint _maxSecsLeft) external {\n        _mockMaxSecsLeft = _maxSecsLeft;\n    }\n}",
        "function": "0x1b16802c",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-119164e1624309606db3edd806c520cdd8937743/contracts/test-helpers/MockExchanger.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "addRewardDistribution(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "distributions(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "removeRewardDistribution(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "removeRewardDistribution(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "distributeRewards(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "distributeRewards(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "addRewardDistribution(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "addRewardDistribution(address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "removeRewardDistribution(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "distributeRewards(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "editRewardDistribution(uint256,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "removeRewardDistribution(uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "function": "editRewardDistribution(uint256,address,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract RewardEscrow is Owned {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint constant TIME_INDEX = 0;\n    uint constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(_feePool);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2]) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2]) {\n        uint index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520]) {\n        uint[520] memory _result;\n        uint schedules = numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) public onlyFeePool {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= synthetix.balanceOf(this),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            synthetix.transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}",
        "function": "vestingSchedules(address,uint256,uint256)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardEscrow.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract TokenExchanger is Owned {\n    address public integrationProxy;\n    address public synthetix;\n\n    constructor(address _owner, address _integrationProxy) public Owned(_owner) {\n        integrationProxy = _integrationProxy;\n    }\n\n    function setSynthetixProxy(address _integrationProxy) external onlyOwner {\n        integrationProxy = _integrationProxy;\n    }\n\n    function setSynthetix(address _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n    }\n\n    function checkBalance(address account) public view synthetixProxyIsSet returns (uint) {\n        return IERC20(integrationProxy).balanceOf(account);\n    }\n\n    function checkAllowance(address tokenOwner, address spender) public view synthetixProxyIsSet returns (uint) {\n        return IERC20(integrationProxy).allowance(tokenOwner, spender);\n    }\n\n    function checkBalanceSNXDirect(address account) public view synthetixProxyIsSet returns (uint) {\n        return IERC20(synthetix).balanceOf(account);\n    }\n\n    function getDecimals(address tokenAddress) public view returns (uint) {\n        return IERC20(tokenAddress).decimals();\n    }\n\n    function doTokenSpend(\n        address fromAccount,\n        address toAccount,\n        uint amount\n    ) public synthetixProxyIsSet returns (bool) {\n        // Call Immutable static call #1\n        require(checkBalance(fromAccount) >= amount, \"fromAccount does not have the required balance to spend\");\n\n        // Call Immutable static call #2\n        require(\n            checkAllowance(fromAccount, address(this)) >= amount,\n            \"I TokenExchanger, do not have approval to spend this guys tokens\"\n        );\n\n        // Call Mutable call\n        return IERC20(integrationProxy).transferFrom(fromAccount, toAccount, amount);\n    }\n\n    modifier synthetixProxyIsSet {\n        require(integrationProxy != address(0), \"Synthetix Integration proxy address not set\");\n        _;\n    }\n\n    event LogString(string name, string value);\n    event LogInt(string name, uint value);\n    event LogAddress(string name, address value);\n    event LogBytes(string name, bytes4 value);\n}",
        "function": "checkAllowance(address,address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/contracts/test-helpers/TokenExchanger.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "library LinkedLibrary3 {\n  struct Struct {\n    uint256 field;\n  }\n\n  function get(Struct storage s) public view returns (uint256) {\n    return s.field;\n  }\n\n  function increase(Struct storage s) public {\n    if (s.field == 0) {\n      s.field = 1;\n    }\n    s.field *= 3;\n  }\n}",
        "function": "0xdff1d97d",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/openzeppelin-Celo_Contracts_Audit_Release_4/celo-monorepo-f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/test/resources/compatibility/contracts_linked_libraries_upgraded_lib/LinkedLibrary3.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n  address public owner;\n  uint256 public last_completed_migration; // solhint-disable var-name-mixedcase\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint256 completed) external restricted {\n    last_completed_migration = completed; // solhint-disable var-name-mixedcase\n  }\n\n  // solhint-disable-next-line func-param-name-mixedcase\n  function upgrade(address new_address) external restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/openzeppelin-Celo_Contracts_Audit_Release_4/celo-monorepo-f64b4c5b5228ecbf41e3e7cfdbb8c0e9a983eea2/packages/protocol/test/resources/compatibility/contracts_removed_from_library_struct/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ReentrancyAttack {\n\n  function callSender(bytes4 data) public {\n    // solium-disable-next-line security/no-low-level-calls\n    require(msg.sender.call(abi.encodeWithSelector(data)));\n  }\n\n}",
        "function": "callSender(bytes4)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "contract ERC165CheckerMock {\n  using ERC165Checker for address;\n\n  function supportsERC165(address account)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsERC165();\n  }\n\n  function supportsInterface(address account, bytes4 interfaceId)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsInterface(interfaceId);\n  }\n\n  function supportsAllInterfaces(address account, bytes4[] interfaceIds)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsAllInterfaces(interfaceIds);\n  }\n}",
        "function": "0x4b9dd904",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ERC165CheckerMock.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract ERC165CheckerMock {\n  using ERC165Checker for address;\n\n  function supportsERC165(address account)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsERC165();\n  }\n\n  function supportsInterface(address account, bytes4 interfaceId)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsInterface(interfaceId);\n  }\n\n  function supportsAllInterfaces(address account, bytes4[] interfaceIds)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsAllInterfaces(interfaceIds);\n  }\n}",
        "function": "supportsERC165(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ERC165CheckerMock.sol",
        "vulnerability": "Unchecked Low Level Call",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract LidoMockForOracle {\n    uint256 private totalPooledEther;\n\n    function totalSupply() external view returns (uint256) {\n        return totalPooledEther;\n    }\n\n    function pushBeacon(uint256 /*_beaconValidators*/, uint256 _beaconBalance) external {\n        totalPooledEther = _beaconBalance;\n    }\n\n    function getTotalShares() public view returns (uint256) {\n        return 42;\n    }\n\n    function pretendTotalPooledEtherGweiForTest(uint256 _val) public {\n        totalPooledEther = _val * 1e9; // gwei to wei\n    }\n}",
        "function": "0x5b59a789",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Lido-WstETH/lido-dao-ea6fa222004b88e6a24b566a51e5b56b0079272d/contracts/0.4.24/test_helpers/LidoMockForOracle.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "contract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}",
        "function": "upgrade(address)",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/blockchain/source/contracts/Migrations.sol",
        "vulnerability": "Reentrancy",
        "check": "FP",
        "response": "Answer: No"
    }
]