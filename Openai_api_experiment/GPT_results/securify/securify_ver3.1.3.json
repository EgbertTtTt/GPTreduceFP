[
    {
        "code_segment": "pragma solidity >=0.4.24;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity >=0.4.21 <0.6.0;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/akropolis-vesting-7f4f4543b08d3749b92839c85e1d77a33d917a37/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit/EasyPool-master/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}\n\ncontract Validating {\n\n  modifier validAddress(address _address) {\n    require(_address != address(0x0));\n    _;\n  }\n\n  modifier notZero(uint _number) {\n    require(_number != 0);\n    _;\n  }\n\n  modifier notEmpty(string _string) {\n    require(bytes(_string).length != 0);\n    _;\n  }\n\n}\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\ncontract Token {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    \n    uint256 public totalSupply;\n\n    \n    \n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    \n    \n    \n    \n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    \n    \n    \n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n/*\nYou should inherit from StandardToken or, for a token like you would want to\ndeploy in something like Mist, see HumanStandardToken.sol.\n(This implements ONLY the standard functions and NOTHING else.\nIf you deploy this, you won't have anything useful.)\n\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n.*/\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\n// SWC-102-Outdated Compiler Version: L2\n/**\n  * @title FEE is an ERC20 token used to pay for trading on the exchange.\n  * For deeper rational read https://leverj.io/whitepaper.pdf.\n  * FEE tokens do not have limit. A new token can be generated by owner.\n  */\ncontract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n// smart contract for KOK coin\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n// SWC-100-Function Default Visibility: L2-24\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function Migrations() {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-SynchroLife/synchrocoin-contracts-master/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "TODAmount",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "TODReceiver",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "DAOConstantGas",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\n//SWC-114-Transaction Order Dependence:L1-492\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n//SWC-114-Transaction Order Dependence:L1-482\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n//SWC-135-Code With No Effects:L245\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/AuctionComponents/Whitelistable.sol\ncontract Whitelistable is Ownable {\n  mapping(address => bool) public whitelist;\n\n  event AddToWhitelist(address _address);\n  event RemoveFromWhitelist(address _address);\n\n  modifier isWhitelisted(address _addr) {\n    require(inWhitelist(_addr));\n    _;\n  }\n\n  /**\n   * @notice Checks the whitelist for a given address.\n   *\n   * @param _address The address to check against the whitelist.\n   * @return The list of whitelisted addresses.\n   */\n  function inWhitelist(address _address) public view returns (bool) {\n    return whitelist[_address];\n  }\n\n  /**\n   * @notice Adds an address to the whitelist.\n   *\n   * @param _address The address to whitelist.\n   * @return True on success, false on failure.\n   */\n  function addToWhitelist(address _address) public onlyOwner returns (bool) {\n    if (whitelist[_address]) {\n      // Already in the mapping\n      return false;\n    }\n\n    whitelist[_address] = true;\n    emit AddToWhitelist(_address);\n    return true;\n  }\n\n  /**\n   * @dev Removes an address from the whitelist.\n   *\n   * @param _address The addres to remove from the whitelist.\n   * @return True on success, false on failure.\n   */\n  function removeFromWhitelist(address _address) public onlyOwner returns (bool) {\n    if (!whitelist[_address]) {\n      // Not currently in the mapping\n      return false;\n    }\n\n    whitelist[_address] = false;\n    emit RemoveFromWhitelist(_address);\n    return true;\n  }\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  function totalSupply() public view returns (uint256);\n  function balanceOf(address who) public view returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public view returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File: contracts/AuctionComponents/ERC20Auction.sol\n/**\n * @title ERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for an auction for a lot of ERC20 tokens - one bidder take all.\n */\ncontract ERC20Auction is AuctionBase, Whitelistable {\n  mapping(uint256 => address) public auctionIdToERC20Address;\n  mapping(uint256 => uint256) public auctionIdToAmount;\n\n  /**\n  * @notice Stores the given information for an auction for the given tokens, then attempts to transfer the tokens from the auction seller to this contract to start the auction.\n  */\n  function setAuctionAsset(address tokenAddress, uint256 tokenAmount, uint256 auctionId) isWhitelisted(tokenAddress) internal {\n    //NOTE: auctionId check requirement might not be necessary.\n    require(tokenAmount > 0 && auctionId != 0);\n    auctionIdToERC20Address[auctionId] = tokenAddress;\n    auctionIdToAmount[auctionId] = tokenAmount;\n    escrowERC20Tokens(msg.sender, tokenAddress, tokenAmount);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasAssets(auctionId));\n    ERC20 erc20Contract = ERC20(auctionIdToERC20Address[auctionId]);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 tokenAmount = auctionIdToAmount[auctionId];\n    auctionIdToAmount[auctionId] = 0;\n    erc20Contract.transfer(recipient, tokenAmount);\n  }\n\n  /**\n   * @dev Transfers tokens from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the ERC20 tokens.\n   */\n  function escrowERC20Tokens(address auctionSeller, address tokenAddress, uint256 tokenAmount) private {\n    ERC20 erc20Contract = ERC20(tokenAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    erc20Contract.transferFrom(auctionSeller, this, tokenAmount);\n  }\n\n  function auctionHasAssets(uint256 auctionId) private view returns (bool) {\n    return (auctionIdToAmount[auctionId] != 0);\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceERC20Auction.sol\n/**\n * @title AscendingPriceERC20Auction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of an ERC20 token.\n */\ncontract DescendingPriceERC20Auction is DescendingPriceAuction, ERC20Auction {\n\n  /*TODO: Account for entry via ERC223 payment fallback function with data (ERC827 should work out of the box)\n\n  We should implement:\n    function tokenFallback(address _from, uint _value, bytes _data) { ... }\n\n  So that our Web3 interface can create an auction with one Web3 step by calling:\n    function transfer(address _to, uint _value, bytes _data) returns (bool)\n  */\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, ERC20Auction and AuctionBase.\n  */\n  function createAuction(\n    uint256 startPrice,\n    uint256 priceFloor,\n    uint256 duration,\n    address tokenAddress,\n    uint256 tokenAmount) whenNotPaused public payable returns (uint256)\n  {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(tokenAddress, tokenAmount, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceERC20Auction.sol",
        "vulnerability": "TODTransfer",
        "check": "TP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\npragma solidity ^0.4.11;\n\n\n// File: contracts/CryptoKitty/CKERC721.sol\n/* solium-disable */\n//NOTE: Intentional, older version of Solidity to keep in line with deployed CK contracts.\n\n\ncontract CKERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\n// File: contracts/AuctionComponents/AuctionBase.sol\n/**\n * @title AuctionBase\n *\n * @author The AUX Team\n * @notice Base contract for single contract auctions. Assumes a single seller per auction.\n *\n */\ncontract AuctionBase is Pausable {\n  using SafeMath for uint256;\n\n  mapping(uint256 => address) public auctionIdToSeller;\n\n  //Start at 1 to avoid use of 0 which should be reserved for a 'null' auction value;\n  uint256 public nextAuctionId = 1;\n\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier onlySeller(uint256 auctionId) {\n    require(msg.sender == auctionIdToSeller[auctionId]);\n    _;\n  }\n\n  event AuctionCreated(address indexed createdBy, uint256 indexed auctionId);\n\n  /**\n   * @notice Creates an auction with an ID equivalent ot the value of nextAuctionId, then puts the caller's address in the auctionIdToSeller mapping.\n   */\n  function createEmptyAuction() internal returns (uint256) {\n    uint256 thisAuctionId = nextAuctionId;\n    nextAuctionId = nextAuctionId.add(1);\n\n    auctionIdToSeller[thisAuctionId] = msg.sender;\n\n    emit AuctionCreated(msg.sender, thisAuctionId);\n    return thisAuctionId;\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal;\n}\n\n// File: contracts/AuctionComponents/CryptoKittyAuction.sol\n/**\n * @title CryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for an auction of a CryptoKitty.\n */\ncontract CryptoKittyAuction is AuctionBase {\n  using SafeMath for uint256;\n\n  //Reverse mapping to find auctions based on cats, also acts as a source of truth for whether the cat is still in auction or not.\n  mapping(uint256 => uint256) public kittyIdToAuctionId;\n\n  mapping(uint256 => uint256) public auctionIdToKittyId;\n\n  address public cryptoKittyAddress;\n\n  constructor(address _cryptoKittyAddress) public {\n    cryptoKittyAddress = _cryptoKittyAddress;\n  }\n\n  function setAuctionAsset(uint256 kittyId, uint256 auctionId) internal {\n    require(auctionId != 0);\n    //Make sure there isn't an existing auction for this asset.\n    require(kittyIdToAuctionId[kittyId] == 0);\n\n    auctionIdToKittyId[auctionId] = kittyId;\n\n    kittyIdToAuctionId[kittyId] = auctionId;\n\n    escrowKitty(msg.sender, kittyId);\n  }\n\n  function transferWinnings(address recipient, uint256 auctionId) internal {\n    require(auctionId != 0);\n    require(auctionHasKitty(auctionId));\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transfer if unapproved, this require is unnecessary gas.\n    require(token.getApproved(kittyId) == address(this));*/\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n    kittyIdToAuctionId[kittyId] = 0;\n    catContract.transfer(recipient, kittyId);\n  }\n\n  /**\n   * @dev Transfers cat from an auction seller to the auction contract. This requires the auction to have been approved for taking control of the cat.\n   */\n  function escrowKitty(address seller, uint256 kittyId) private {\n    CKERC721 catContract = CKERC721(cryptoKittyAddress);\n    /*NOTE: Error should be thrown by transferFrom if unapproved.\n    require(token.getApproved(kittyId) == address(this));*/\n    catContract.transferFrom(seller, this, kittyId);\n  }\n\n  function auctionHasKitty(uint256 auctionId) private view returns (bool) {\n    uint256 kittyId = auctionIdToKittyId[auctionId];\n\n    //An auctionId of 0 represents a non-existent auction, which means the kitty isn't in any auction managed by this contract.\n    uint256 auctionThatCurrentlyOwnsKitty = kittyIdToAuctionId[kittyId];\n\n    return(auctionThatCurrentlyOwnsKitty == auctionId);\n  }\n}\n\n// File: contracts/AuctionComponents/FeeCollector.sol\n/**\n * @title FeeCollector\n *\n * @author The AUX Team\n * @notice Adds modifiers for requiring fees on function calls\n *\n */\ncontract FeeCollector is Ownable {\n  using SafeMath for uint256;\n  uint256 feeBalance = 0;\n  /**\n   * @dev Throws if called by any account other than the seller for a given auction.\n   */\n  modifier requiresFee(uint256 feeAmount) {\n    require(msg.value >= feeAmount);\n    feeBalance = feeBalance.add(feeAmount);\n    msg.sender.transfer(msg.value.sub(feeAmount));\n    _;\n  }\n\n  event FeesWithdrawn(address indexed owner, uint256 indexed withdrawalAmount);\n\n  function withdrawFees() external onlyOwner {\n    uint256 feeAmountWithdrawn = feeBalance;\n    feeBalance = 0;\n    owner.transfer(feeAmountWithdrawn);\n    emit FeesWithdrawn(owner, feeAmountWithdrawn);\n  }\n}\n\n// File: contracts/AuctionComponents/DescendingPriceAuction.sol\n/**\n * @title DescendingPriceAuction\n *\n * @author The AUX Team\n * @notice Contract for a single contract \"Descending Price\" auction.\n */\ncontract DescendingPriceAuction is AuctionBase, FeeCollector {\n  using SafeMath for uint256;\n\n  mapping(uint256 => uint256) public auctionIdToStartPrice;\n  mapping(uint256 => uint256) public auctionIdToPriceFloor;\n  mapping(uint256 => uint256) public auctionIdToStartBlock;\n  mapping(uint256 => uint256) public auctionIdToPriceFloorBlock;\n  mapping(uint256 => bool) public auctionIdToAcceptingBids;\n\n  modifier onlyAcceptingBids(uint256 auctionId) {\n    require(auctionIdToAcceptingBids[auctionId]);\n    _;\n  }\n\n  /**\n   * @notice Should immediately end the auction by transferring the winnings to the bidder, as long as the bid is valid.\n   */\n  function bid(uint256 auctionId) whenNotPaused onlyAcceptingBids(auctionId) whenNotPaused external payable {\n    // Bidder must exist\n    require(msg.sender != 0x0);\n//SWC-135-Code With No Effects:L344\n    uint256 currentPrice = getCurrentPrice(auctionId);\n    // Bidder must bid the correct amount or greater\n    require(msg.value >= currentPrice);\n\n    auctionIdToAcceptingBids[auctionId] = false;\n    transferWinnings(msg.sender, auctionId);\n\n    //Check for overbid.\n    uint256 overbidAmount = msg.value.sub(currentPrice);\n    if (overbidAmount > 0) {\n      //Transfer any overbid amount back to the msg sender\n      msg.sender.transfer(overbidAmount);\n    }\n    auctionIdToSeller[auctionId].transfer(currentPrice);\n  }\n\n  function cancel(uint256 auctionId) whenNotPaused public onlySeller(auctionId) {\n    transferWinnings(auctionIdToSeller[auctionId], auctionId);\n    auctionIdToAcceptingBids[auctionId] = false;\n  }\n\n  function getCurrentPrice(uint256 auctionId) public view returns (uint256) {\n    //Only grab information necessary to check for whether we're in the middle of the price descent, before possibly returning priceFloor.\n    uint256 priceFloorBlock = auctionIdToPriceFloorBlock[auctionId];\n    uint256 priceFloor = auctionIdToPriceFloor[auctionId];\n\n    if (block.number >= priceFloorBlock) {\n      return priceFloor;\n    }\n\n    uint256 startBlock = auctionIdToStartBlock[auctionId];\n    uint256 startPrice = auctionIdToStartPrice[auctionId];\n\n    uint256 priceDifference = startPrice.sub(priceFloor);\n    uint256 blockDifference = priceFloorBlock.sub(startBlock);\n\n    uint256 numberOfBlocksElapsed = block.number.sub(startBlock);\n\n    uint256 priceDecrease = numberOfBlocksElapsed.mul(priceDifference.div(blockDifference));\n\n    return startPrice.sub(priceDecrease);\n  }\n\n  /**\n   * @notice Stores the requisite pricing information for a descending price auction.\n     Takes a 2% cut of the start price\n   */\n  function setAuctionPricing(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 auctionId) requiresFee(startPrice.div(50)) internal {\n    require(startPrice > 0 && priceFloor < startPrice && priceFloor >= 0 && duration > 0);\n\n    /*TODO: These mappings might be a good case for struct packing (auction info), from both a readability/optimization standpoint;\n            i.e. CryptoKitty source uses uint128 to rep money. A uint128 could be used to represent something like 10^33 ETH, which seems like more than enough.*/\n    auctionIdToStartBlock[auctionId] = block.number;\n    auctionIdToStartPrice[auctionId] = startPrice;\n    auctionIdToPriceFloor[auctionId] = priceFloor;\n    auctionIdToPriceFloorBlock[auctionId] = block.number.add(duration);\n    auctionIdToAcceptingBids[auctionId] = true;\n  }\n}\n\n// File: contracts/Auctions/DescendingPriceCryptoKittyAuction.sol\n/**\n * @title DescendingPriceCryptoKittyAuction\n *\n * @author The AUX Team\n * @notice Contract for a descending price (Dutch) auction of a CryptoKitty token.\n */\ncontract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "DAOConstantGas",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public pendingOwner;\n    address public manager;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // SWC-129-Typographical Error: L17\n    event ManagerUpdated(address newManager);\n\n   /**\n   * @dev Throws if called by any account other than the owner.\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Modifier throws if called by any account other than the manager.\n     */\n    modifier onlyManager() {\n        require(msg.sender == manager);\n        _;\n    }\n\n    /**\n    * @dev Modifier throws if called by any account other than the pendingOwner.\n    */\n    modifier onlyPendingOwner() {\n        require(msg.sender == pendingOwner);\n        _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n    * @dev Allows the current owner to set the pendingOwner address.\n    * @param newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        pendingOwner = newOwner;\n    }\n\n    /**\n    * @dev Allows the pendingOwner address to finalize the transfer.\n    */\n    function claimOwnership() public onlyPendingOwner {\n        emit OwnershipTransferred(owner, pendingOwner);\n        owner = pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /**\n    * @dev Sets the manager address.\n    * @param _manager The manager address.\n    */\n    function setManager(address _manager) public onlyOwner {\n        require(_manager != address(0));\n        manager = _manager;\n        // SWC-129-Typographical Error: L72\n        emit ManagerUpdated(manager);\n    }\n\n}\n\n/**\n * @title Whitelist\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\n * @dev This simplifies the implementation of \"user permissions\".\n */\ncontract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * See https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n    function allowance(address owner, address spender)\n        public view returns (uint256);\n\n    function transferFrom(address from, address to, uint256 value)\n        public returns (bool);\n\n    function approve(address spender, uint256 value) public returns (bool);\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, throws on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers, truncating the quotient.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        // uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return a / b;\n    }\n\n    /**\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    /**\n    * @dev Adds two numbers, throws on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n        c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/issues/20\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}\n\n/**\n * @title Pausable token\n * @dev StandardToken modified with pausable transfers.\n **/\ncontract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n\n/**\n * @title Mintable token\n * @dev Simple ERC20 Token example, with mintable token creation\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\n */\ncontract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}\n\n/**\n * @title SimpleToken\n * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator.\n * Note they can later distribute these tokens as they wish using `transfer` and other\n * `StandardToken` functions.\n */\ncontract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "**Answer:** No"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n * @title ICrowdsaleFund\n * @dev Fund methods used by crowdsale contract\n */\ninterface ICrowdsaleFund {\n    /**\n    * @dev Function accepts user`s contributed ether and logs contribution\n    * @param contributor Contributor wallet address.\n    */\n    function processContribution(address contributor) external payable;\n    /**\n    * @dev Function is called on the end of successful crowdsale\n    */\n    function onCrowdsaleEnd() external;\n    /**\n    * @dev Function is called if crowdsale failed to reach soft cap\n    */\n    function enableCrowdsaleRefund() external;\n}\n\n/**\n * @title ICrowdsaleReservationFund\n * @dev ReservationFund methods used by crowdsale contract\n */\ninterface ICrowdsaleReservationFund {\n    /**\n     * @dev Check if contributor has transactions\n     */\n    function canCompleteContribution(address contributor) external returns(bool);\n    /**\n     * @dev Complete contribution\n     * @param contributor Contributor`s address\n     */\n    function completeContribution(address contributor) external;\n    /**\n     * @dev Function accepts user`s contributed ether and amount of tokens to issue\n     * @param contributor Contributor wallet address.\n     * @param _tokensToIssue Token amount to issue\n     * @param _bonusTokensToIssue Bonus token amount to issue\n     */\n    function processContribution(address contributor, uint256 _tokensToIssue, uint256 _bonusTokensToIssue) external payable;\n\n    /**\n     * @dev Function returns current user`s contributed ether amount\n     */\n    function contributionsOf(address contributor) external returns(uint256);\n\n    /**\n     * @dev Function is called on the end of successful crowdsale\n     */\n    function onCrowdsaleEnd() external;\n}\n\n/**\n * @title IERC20Token - ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract IERC20Token {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value)  public returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success);\n    function approve(address _spender, uint256 _value)  public returns (bool success);\n    function allowance(address _owner, address _spender)  public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n/**\n * @title MultiOwnable\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\n * functions, this simplifies the implementation of \"users permissions\".\n */\ncontract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\ncontract SafeMath {\n    /**\n    * @dev constructor\n    */\n    function SafeMath() public {\n    }\n\n    function safeMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a * b;\n        assert(a == 0 || c / a == b);\n        return c;\n    }\n\n    function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(a >= b);\n        return a - b;\n    }\n\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n}\n\n/**\n * @title ERC20Token - ERC20 base implementation\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}\n\n/**\n * @title ITokenEventListener\n * @dev Interface which should be implemented by token listener\n */\ninterface ITokenEventListener {\n    /**\n     * @dev Function is called after token transfer/transferFrom\n     * @param _from Sender address\n     * @param _to Receiver address\n     * @param _value Amount of tokens\n     */\n    function onTokenTransfer(address _from, address _to, uint256 _value) public;\n}\n\n/**\n * @title ManagedToken\n * @dev ERC20 compatible token with issue and destroy facilities\n * @dev All transfers can be monitored by token event listener\n */\ncontract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}\n\n/**\n * @title TransferLimitedToken\n * @dev Token with ability to limit transfers within wallets included in limitedWallets list for certain period of time\n */\ncontract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}\n\n/**\n * @title LockedTokens\n * @dev Lock tokens for certain period of time\n */\ncontract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev The Ownable constructor sets the original `owner` of the contract.\n    */\n    function Ownable(address _owner) public {\n        owner = _owner == address(0) ? msg.sender : _owner;\n    }\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param _newOwner The address to transfer ownership to.\n    */\n    function transferOwnership(address _newOwner) public onlyOwner {\n        require(_newOwner != owner);\n        newOwner = _newOwner;\n    }\n\n    /**\n    * @dev confirm ownership by a new owner\n    */\n    function confirmOwnership() public {\n        require(msg.sender == newOwner);\n        OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n        newOwner = 0x0;\n    }\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() onlyOwner whenNotPaused public {\n        paused = true;\n        Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() onlyOwner whenPaused public {\n        paused = false;\n        Unpause();\n    }\n}\n\ninterface ISimpleCrowdsale {\n    function getSoftCap() external view returns(uint256);\n    function isContributorInLists(address contributorAddress) external view returns(bool);\n    function processReservationFundContribution(\n        address contributor,\n        uint256 tokenAmount,\n        uint256 tokenBonusAmount\n    ) external payable;\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >0.5.0 <0.8.0;\n\n\nlibrary Lib_RLPReader {\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 constant internal MAX_LIST_LENGTH = 32;\n\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    \n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n    \n\n    /**********************\n     * Internal Functions *\n     **********************/\n    \n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem memory\n        )\n    {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({\n            length: _in.length,\n            ptr: ptr\n        });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        (\n            uint256 listOffset,\n            ,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.LIST_ITEM,\n            \"Invalid RLP list value.\"\n        );\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(\n                itemCount < MAX_LIST_LENGTH,\n                \"Provided RLP list exceeds max list length.\"\n            );\n\n            (\n                uint256 itemOffset,\n                uint256 itemLength,\n            ) = _decodeLength(RLPItem({\n                length: _in.length - offset,\n                ptr: _in.ptr + offset\n            }));\n\n            out[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: _in.ptr + offset\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        return readList(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes value.\"\n        );\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return readBytes(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return readString(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _in.length <= 33,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return readBytes32(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return readUint256(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _in.length == 1,\n            \"Invalid RLP boolean value.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        return readBool(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(\n            _in.length == 21,\n            \"Invalid RLP address value.\"\n        );\n\n        return address(readUint256(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return readAddress(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP Uint64 value into a uint64.\n     * @param _in RLP uint64 value.\n     * @return Decoded uint64.\n     */\n    function readUint64(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint64\n        )\n    {\n        require(\n            _in.length <= 9,\n            \"Invalid RLP uint64 value.\"\n        );\n\n        return uint64(readUint256(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(\n            _in.length > 0,\n            \"RLP item cannot be null.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            uint256 strLen = prefix - 0x80;\n            \n            require(\n                _in.length > strLen,\n                \"Invalid RLP short string.\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"Invalid RLP long string length.\"\n            );\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfStrLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"Invalid RLP long string.\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            uint256 listLen = prefix - 0xc0;\n\n            require(\n                _in.length > listLen,\n                \"Invalid RLP short list.\"\n            );\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"Invalid RLP long list length.\"\n            );\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfListLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"Invalid RLP long list.\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\n        assembly {\n            mstore(\n                dest,\n                or(\n                    and(mload(src), not(mask)),\n                    and(mload(dest), mask)\n                )\n            )\n        }\n\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n\nlibrary Lib_BytesUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (_bytes.length - _start == 0) {\n            return bytes('');\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32PadLeft(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 ret;\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\n        assembly {\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\n        }\n        return ret;\n    }\n\n    function toBytes32(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3 , \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, \"toUint8_overflow\");\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(\n        bytes memory _bytes,\n        bytes memory _other\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n\nlibrary Lib_RLPWriter {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return _out The RLP encoded list of items in bytes.\n     */\n    function writeList(\n        bytes[] memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeString(\n        string memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return _out The RLP encoded address in bytes.\n     */\n    function writeAddress(\n        address _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a bytes32 value.\n     * @param _in The bytes32 to encode.\n     * @return _out The RLP encoded bytes32 in bytes.\n     */\n    function writeBytes32(\n        bytes32 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return _out The RLP encoded uint256 in bytes.\n     */\n    function writeUint(\n        uint256 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return _out The RLP encoded bool in bytes.\n     */\n    function writeBool(\n        bool _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return _encoded RLP encoded bytes.\n     */\n    function _writeLength(\n        uint256 _len,\n        uint256 _offset\n    )\n        private\n        pure\n        returns (\n            bytes memory _encoded\n        )\n    {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return _binary RLP encoded bytes.\n     */\n    function _toBinary(\n        uint256 _x\n    )\n        private\n        pure\n        returns (\n            bytes memory _binary\n        )\n    {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    )\n        private\n        pure\n    {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return _flattened The flattened byte string.\n     */\n    function _flatten(\n        bytes[] memory _list\n    )\n        private\n        pure\n        returns (\n            bytes memory _flattened\n        )\n    {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly { listPtr := add(item, 0x20)}\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n\nlibrary Lib_EIP155Tx {\n\n    /***********\n     * Structs *\n     ***********/\n\n    // Struct representing an EIP155 transaction. See EIP link above for more information.\n    struct EIP155Tx {\n        // These fields correspond to the actual RLP-encoded fields specified by EIP155.\n        uint64 nonce;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        address to;\n        uint256 value;\n        bytes data;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n\n        // Chain ID to associate this transaction with. Used all over the place, seemed easier to\n        // set this once when we create the transaction rather than providing it as an input to\n        // each function. I don't see a strong need to have a transaction with a mutable chain ID.\n        uint256 chainId;\n\n        // The ECDSA \"recovery parameter,\" should always be 0 or 1. EIP155 specifies that:\n        // `v = {0,1} + CHAIN_ID * 2 + 35`\n        // Where `{0,1}` is a stand in for our `recovery_parameter`. Now computing our formula for\n        // the recovery parameter:\n        // 1. `v = {0,1} + CHAIN_ID * 2 + 35`\n        // 2. `v = recovery_parameter + CHAIN_ID * 2 + 35`\n        // 3. `v - CHAIN_ID * 2 - 35 = recovery_parameter`\n        // So we're left with the final formula:\n        // `recovery_parameter = v - CHAIN_ID * 2 - 35`\n        // NOTE: This variable is a uint8 because `v` is inherently limited to a uint8. If we\n        // didn't use a uint8, then recovery_parameter would always be a negative number for chain\n        // IDs greater than 110 (`255 - 110 * 2 - 35 = 0`). So we need to wrap around to support\n        // anything larger.\n        uint8 recoveryParam; \n\n        // Whether or not the transaction is a creation. Necessary because we can't make an address\n        // \"nil\". Using the zero address creates a potential conflict if the user did actually\n        // intend to send a transaction to the zero address.\n        bool isCreate;       \n    }\n\n    // Lets us use nicer syntax.\n    using Lib_EIP155Tx for EIP155Tx;\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Decodes an EIP155 transaction and attaches a given Chain ID.\n     * Transaction *must* be RLP-encoded.\n     * @param _encoded RLP-encoded EIP155 transaction.\n     * @param _chainId Chain ID to assocaite with this transaction.\n     * @return Parsed transaction.\n     */\n    function decode(\n        bytes memory _encoded,\n        uint256 _chainId\n    )\n        internal\n        pure\n        returns (\n            EIP155Tx memory\n        )\n    {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_encoded);\n\n        // Note formula above about how recoveryParam is computed.\n        uint8 v = uint8(Lib_RLPReader.readUint256(decoded[6]));\n        uint8 recoveryParam = uint8(v - 2 * _chainId - 35);\n\n        // Creations can be detected by looking at the byte length here.\n        bool isCreate = Lib_RLPReader.readBytes(decoded[3]).length == 0;\n\n        return EIP155Tx({\n            nonce: Lib_RLPReader.readUint64(decoded[0]),\n            gasPrice: Lib_RLPReader.readUint256(decoded[1]),\n            gasLimit: Lib_RLPReader.readUint256(decoded[2]),\n            to: Lib_RLPReader.readAddress(decoded[3]),\n            value: Lib_RLPReader.readUint256(decoded[4]),\n            data: Lib_RLPReader.readBytes(decoded[5]),\n            v: v,\n            r: Lib_RLPReader.readBytes32(decoded[7]),\n            s: Lib_RLPReader.readBytes32(decoded[8]),\n            chainId: _chainId,\n            recoveryParam: recoveryParam,\n            isCreate: isCreate\n        });\n    }\n\n    /**\n     * Encodes an EIP155 transaction into RLP.\n     * @param _transaction EIP155 transaction to encode.\n     * @param _includeSignature Whether or not to encode the signature.\n     * @return RLP-encoded transaction.\n     */\n    function encode(\n        EIP155Tx memory _transaction,\n        bool _includeSignature\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes[] memory raw = new bytes[](9);\n\n        raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\n        raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\n        raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\n\n        // We write the encoding of empty bytes when the transaction is a creation, *not* the zero\n        // address as one might assume.\n        if (_transaction.isCreate) {\n            raw[3] = Lib_RLPWriter.writeBytes('');\n        } else {\n            raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\n        }\n\n        raw[4] = Lib_RLPWriter.writeUint(_transaction.value);\n        raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\n\n        if (_includeSignature) {\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.v);\n            raw[7] = Lib_RLPWriter.writeBytes32(_transaction.r);\n            raw[8] = Lib_RLPWriter.writeBytes32(_transaction.s);\n        } else {\n            // Chain ID *is* included in the unsigned transaction.\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId); \n            raw[7] = Lib_RLPWriter.writeBytes('');\n            raw[8] = Lib_RLPWriter.writeBytes('');\n        }\n\n        return Lib_RLPWriter.writeList(raw);\n    }\n\n    /**\n     * Computes the hash of an EIP155 transaction. Assumes that you don't want to include the\n     * signature in this hash because that's a very uncommon usecase. If you really want to include\n     * the signature, just encode with the signature and take the hash yourself.\n     */\n    function hash(\n        EIP155Tx memory _transaction\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(\n            _transaction.encode(false)\n        );\n    }\n\n    /**\n     * Computes the sender of an EIP155 transaction.\n     * @param _transaction EIP155 transaction to get a sender for.\n     * @return Address corresponding to the private key that signed this transaction.\n     */\n    function sender(\n        EIP155Tx memory _transaction\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return ecrecover(\n            _transaction.hash(),\n            _transaction.recoveryParam + 27,\n            _transaction.r,\n            _transaction.s\n        );\n    }\n}\n\nlibrary Lib_ErrorUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Encodes an error string into raw solidity-style revert data.\n     * (i.e. ascii bytes, prefixed with bytes4(keccak(\"Error(string))\"))\n     * Ref: https://docs.soliditylang.org/en/v0.8.2/control-structures.html?highlight=Error(string)#panic-via-assert-and-error-via-require\n     * @param _reason Reason for the reversion.\n     * @return Standard solidity revert data for the given reason.\n     */\n    function encodeRevertString(\n        string memory _reason\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return abi.encodeWithSignature(\n            \"Error(string)\",\n            _reason\n        );\n    }\n}\n\nlibrary Lib_SafeExecutionManagerWrapper {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Performs a safe ovmCALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeCALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmDELEGATECALL.\n     * @param _gasLimit Gas limit for the call.\n     * @param _target Address to call.\n     * @param _calldata Data to send to the call.\n     * @return _success Whether or not the call reverted.\n     * @return _returndata Data returned by the call.\n     */\n    function safeDELEGATECALL(\n        uint256 _gasLimit,\n        address _target,\n        bytes memory _calldata\n    )\n        internal\n        returns (\n            bool _success,\n            bytes memory _returndata\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmDELEGATECALL(uint256,address,bytes)\",\n                _gasLimit,\n                _target,\n                _calldata\n            )\n        );\n\n        return abi.decode(returndata, (bool, bytes));\n    }\n\n    /**\n     * Performs a safe ovmCREATE call.\n     * @param _gasLimit Gas limit for the creation.\n     * @param _bytecode Code for the new contract.\n     * @return _contract Address of the created contract.\n     */\n    function safeCREATE(\n        uint256 _gasLimit,\n        bytes memory _bytecode\n    )\n        internal\n        returns (\n            address,\n            bytes memory\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            _gasLimit,\n            abi.encodeWithSignature(\n                \"ovmCREATE(bytes)\",\n                _bytecode\n            )\n        );\n\n        return abi.decode(returndata, (address, bytes));\n    }\n\n    /**\n     * Performs a safe ovmEXTCODESIZE call.\n     * @param _contract Address of the contract to query the size of.\n     * @return _EXTCODESIZE Size of the requested contract in bytes.\n     */\n    function safeEXTCODESIZE(\n        address _contract\n    )\n        internal\n        returns (\n            uint256 _EXTCODESIZE\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmEXTCODESIZE(address)\",\n                _contract\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCHAINID call.\n     * @return _CHAINID Result of calling ovmCHAINID.\n     */\n    function safeCHAINID()\n        internal\n        returns (\n            uint256 _CHAINID\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCHAINID()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint256));\n    }\n\n    /**\n     * Performs a safe ovmCALLER call.\n     * @return _CALLER Result of calling ovmCALLER.\n     */\n    function safeCALLER()\n        internal\n        returns (\n            address _CALLER\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCALLER()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmADDRESS call.\n     * @return _ADDRESS Result of calling ovmADDRESS.\n     */\n    function safeADDRESS()\n        internal\n        returns (\n            address _ADDRESS\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmADDRESS()\"\n            )\n        );\n\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * Performs a safe ovmGETNONCE call.\n     * @return _nonce Result of calling ovmGETNONCE.\n     */\n    function safeGETNONCE()\n        internal\n        returns (\n            uint64 _nonce\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmGETNONCE()\"\n            )\n        );\n\n        return abi.decode(returndata, (uint64));\n    }\n\n    /**\n     * Performs a safe ovmSETNONCE call.\n     * @param _nonce New account nonce.\n     */\n    function safeSETNONCE(\n        uint64 _nonce\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSETNONCE(uint64)\",\n                _nonce\n            )\n        );\n    }\n\n    /**\n     * Performs a safe ovmCREATEEOA call.\n     * @param _messageHash Message hash which was signed by EOA\n     * @param _v v value of signature (0 or 1)\n     * @param _r r value of signature\n     * @param _s s value of signature\n     */\n    function safeCREATEEOA(\n        bytes32 _messageHash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmCREATEEOA(bytes32,uint8,bytes32,bytes32)\",\n                _messageHash,\n                _v,\n                _r,\n                _s\n            )\n        );\n    }\n\n    /**\n     * Performs a safe REVERT.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREVERT(\n        string memory _reason\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmREVERT(bytes)\",\n                Lib_ErrorUtils.encodeRevertString(\n                    _reason\n                )\n            )\n        );\n    }\n\n    /**\n     * Performs a safe \"require\".\n     * @param _condition Boolean condition that must be true or will revert.\n     * @param _reason String revert reason to pass along with the REVERT.\n     */\n    function safeREQUIRE(\n        bool _condition,\n        string memory _reason\n    )\n        internal\n    {\n        if (!_condition) {\n            safeREVERT(\n                _reason\n            );\n        }\n    }\n\n    /**\n     * Performs a safe ovmSLOAD call.\n     */\n    function safeSLOAD(\n        bytes32 _key\n    )\n        internal\n        returns (\n            bytes32\n        )\n    {\n        bytes memory returndata = _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSLOAD(bytes32)\",\n                _key\n            )\n        );\n\n        return abi.decode(returndata, (bytes32));\n    }\n\n    /**\n     * Performs a safe ovmSSTORE call.\n     */\n    function safeSSTORE(\n        bytes32 _key,\n        bytes32 _value\n    )\n        internal\n    {\n        _safeExecutionManagerInteraction(\n            abi.encodeWithSignature(\n                \"ovmSSTORE(bytes32,bytes32)\",\n                _key,\n                _value\n            )\n        );\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Performs an ovm interaction and the necessary safety checks.\n     * @param _gasLimit Gas limit for the interaction.\n     * @param _calldata Data to send to the OVM_ExecutionManager (encoded with sighash).\n     * @return _returndata Data sent back by the OVM_ExecutionManager.\n     */\n    function _safeExecutionManagerInteraction(\n        uint256 _gasLimit,\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        address ovmExecutionManager = msg.sender;\n        (\n            bool success,\n            bytes memory returndata\n        ) = ovmExecutionManager.call{gas: _gasLimit}(_calldata);\n\n        if (success == false) {\n            assembly {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else if (returndata.length == 1) {\n            assembly {\n                return(0, 1)\n            }\n        } else {\n            return returndata;\n        }\n    }\n\n    function _safeExecutionManagerInteraction(\n        bytes memory _calldata\n    )\n        private\n        returns (\n            bytes memory _returndata\n        )\n    {\n        return _safeExecutionManagerInteraction(\n            gasleft(),\n            _calldata\n        );\n    }\n}\n\n// SPDX-License-Identifier: MIT\n/* Library Imports */\n/**\n * @title OVM_SequencerEntrypoint\n * @dev The Sequencer Entrypoint is a predeploy which, despite its name, can in fact be called by \n * any account. It accepts a more efficient compressed calldata format, which it decompresses and \n * encodes to the standard EIP155 transaction format.\n * This contract is the implementation referenced by the Proxy Sequencer Entrypoint, thus enabling\n * the Optimism team to upgrade the decompression of calldata from the Sequencer.\n * \n * Compiler used: solc\n * Runtime target: OVM\n */\ncontract OVM_SequencerEntrypoint {\n    using Lib_EIP155Tx for Lib_EIP155Tx.EIP155Tx;\n\n\n    /*********************\n     * Fallback Function *\n     *********************/\n\n    /**\n     * Expects an RLP-encoded EIP155 transaction as input. See the EIP for a more detailed\n     * description of this transaction format:\n     * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\n     */\n    fallback()\n        external\n    {\n        Lib_EIP155Tx.EIP155Tx memory transaction = Lib_EIP155Tx.decode(\n            msg.data,\n            Lib_SafeExecutionManagerWrapper.safeCHAINID()\n        );\n\n        // Recovery parameter being something other than 0 or 1 indicates that this transaction was\n        // signed using the wrong chain ID. We really should have this logic inside of the \n        Lib_SafeExecutionManagerWrapper.safeREQUIRE(\n            transaction.recoveryParam < 2,\n            \"OVM_SequencerEntrypoint: Transaction was signed with the wrong chain ID.\"\n        );\n\n        // Cache this result since we use it twice. Maybe we could move this caching into\n        // Lib_EIP155Tx but I'd rather not make optimizations like that right now.\n        address sender = transaction.sender();\n\n        // Create an EOA contract for this account if it doesn't already exist.\n        if (Lib_SafeExecutionManagerWrapper.safeEXTCODESIZE(sender) == 0) {\n            Lib_SafeExecutionManagerWrapper.safeCREATEEOA(\n                transaction.hash(),\n                transaction.recoveryParam,\n                transaction.r,\n                transaction.s\n            );\n        }\n\n        // Now call into the EOA contract (which should definitely exist).\n        //SWC-104-Unchecked Call Return Value: L63-L70\n        Lib_SafeExecutionManagerWrapper.safeCALL(\n            gasleft(),\n            sender,\n            abi.encodeWithSignature(\n                \"execute(bytes)\",\n                msg.data\n            )\n        );\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Optimism/contracts-18e128343731b9bde23812ce932e24d81440b6b7/contracts/optimistic-ethereum/OVM/precompiles/OVM_SequencerEntrypoint.sol",
        "vulnerability": "UnhandledException",
        "check": "TP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "TODTransfer",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkToken.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n// SWC-102-Outdated Compiler Version: L2\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract GNTAllocation {\n    function GNTAllocation(address _golemFactory) {}\n}\n\n\ncontract GolemNetworkToken {\n    string public constant name = \"Test Golem Network Token\";\n    string public constant symbol = \"tGNT\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETH.\n\n    uint256 public constant tokenCreationRate = 10000000000;\n\n    // The funding cap in weis.\n    uint256 public constant tokenCreationCap = 82 finney * tokenCreationRate;\n    uint256 public constant tokenCreationMin = 15 finney * tokenCreationRate;\n\n    uint256 public fundingStartBlock;\n    uint256 public fundingEndBlock;\n\n    // The flag indicates if the GNT contract is in Funding state.\n    bool public funding = true;\n\n    // Receives ETH and its own GNT endowment.\n    address public golemFactory;\n\n    // Has control over token migration to next version of token.\n    address public migrationMaster;\n\n    GNTAllocation lockedAllocation;\n\n    // The current total token supply.\n    uint256 public totalTokens;\n\n    mapping (address => uint256) balances;\n\n    address public migrationAgent;\n    uint256 public totalMigrated;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n    function GolemNetworkToken(address _golemFactory,\n                               address _migrationMaster,\n                               uint256 _fundingStartBlock,\n                               uint256 _fundingEndBlock) {\n\n        if (_golemFactory == 0) revert();\n        if (_migrationMaster == 0) revert();\n        if (_fundingStartBlock <= block.number) revert();\n        if (_fundingEndBlock   <= _fundingStartBlock) revert();\n\n        lockedAllocation = new GNTAllocation(_golemFactory);\n        migrationMaster = _migrationMaster;\n        golemFactory = _golemFactory;\n        fundingStartBlock = _fundingStartBlock;\n        fundingEndBlock = _fundingEndBlock;\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function transfer(address _to, uint256 _value) returns (bool) {\n        // Abort if not in Operational state.\n        if (funding) revert();\n\n        var senderBalance = balances[msg.sender];\n        if (senderBalance >= _value && _value > 0) {\n            senderBalance -= _value;\n            balances[msg.sender] = senderBalance;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        }\n        return false;\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return totalTokens;\n    }\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    // Token migration support:\n\n    \n    \n    \n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (funding) revert();\n        if (migrationAgent == 0) revert();\n\n        // Validate input value.\n        if (_value == 0) revert();\n        if (_value > balances[msg.sender]) revert();\n\n        balances[msg.sender] -= _value;\n        totalTokens -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\n    \n\t\n    \n    \n    \n    function setMigrationAgent(address _agent) external {\n        // Abort if not in Operational Normal state.\n        if (funding) revert();\n        if (migrationAgent != 0) revert();\n        if (msg.sender != migrationMaster) revert();\n        migrationAgent = _agent;\n    }\n\n    function setMigrationMaster(address _master) external {\n        if (msg.sender != migrationMaster) revert();\n        if (_master == 0) revert();\n        migrationMaster = _master;\n    }\n\n    // Crowdfunding:\n\n    \n    \n    \n    function create() payable external {\n        // Abort if not in Funding Active state.\n        // The checks are split (instead of using or operator) because it is\n        // cheaper this way.\n        if (!funding) revert();\n        if (block.number < fundingStartBlock) revert();\n        if (block.number > fundingEndBlock) revert();\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) revert();\n        if (msg.value > (tokenCreationCap - totalTokens) / tokenCreationRate)\n            revert();\n\n        var numTokens = msg.value * tokenCreationRate;\n        totalTokens += numTokens;\n\n        // Assign new tokens to the sender\n        balances[msg.sender] += numTokens;\n\n        // Log token creation event\n        Transfer(0, msg.sender, numTokens);\n    }\n\n    \n    \n    \n    \n    \n    \n    function finalize() external {\n        // Abort if not in Funding Success state.\n        if (!funding) revert();\n        if ((block.number <= fundingEndBlock ||\n             totalTokens < tokenCreationMin) &&\n            totalTokens < tokenCreationCap) revert();\n\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\n\n        // Create additional GNT for the Golem Factory and developers as\n        // the 18% of total number of tokens.\n        // All additional tokens are transfered to the account controller by\n        // GNTAllocation contract which will not allow using them for 6 months.\n        uint256 percentOfTotal = 18;\n        uint256 additionalTokens =\n            totalTokens * percentOfTotal / (100 - percentOfTotal);\n        totalTokens += additionalTokens;\n        balances[lockedAllocation] += additionalTokens;\n        Transfer(0, lockedAllocation, additionalTokens);\n\n        // Transfer ETH to the Golem Factory address.\n        if (!golemFactory.send(this.balance)) revert();\n    }\n\n    \n    \n    \n    function refund() external {\n        // Abort if not in Funding Failure state.\n        if (!funding) revert();\n        if (block.number <= fundingEndBlock) revert();\n        if (totalTokens >= tokenCreationMin) revert();\n\n        var gntValue = balances[msg.sender];\n        if (gntValue == 0) revert();\n        balances[msg.sender] = 0;\n        totalTokens -= gntValue;\n\n        var ethValue = gntValue / tokenCreationRate;\n        Refund(msg.sender, ethValue);\n        if (!msg.sender.send(ethValue)) revert();\n    }\n}\n\n// SWC-102-Outdated Compiler Version: L2\n/* Holds all tGNT after simulated crowdfunding on testnet. */\n/* To receive some tGNT just call create. */\ncontract Faucet {\n    GolemNetworkToken public token;\n\n    function Faucet(address _token) {\n        token = GolemNetworkToken(_token);\n    }\n\n    // Note that this function does not actually create tGNT!\n    // Name was unchanged not to break API\n    function create() external {\n        uint256 tokens = 1000 * 10 ** uint256(token.decimals());\n        if (token.balanceOf(msg.sender) >= tokens) revert();\n        token.transfer(msg.sender, tokens);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/Faucet.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.25 <0.7.0;\n\n\n// SPDX-License-Identifier: MIT\n// SWC-103-Floating Pragma: L3\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-AliumSwap Smart Contract/alium-swap-periphery-6aff4c5ad4695b77358eae0627c98d72621256bc/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n//SWC-101-Integer Overflow and Underflow: All\n//SWC-102-Outdated Compiler Version: All\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "TODReceiver",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n//SWC-101-Integer Overflow and Underflow: All\n//SWC-102-Outdated Compiler Version: All\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "TODAmount",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.4;\n\n\n//SWC-101-Integer Overflow and Underflow: All\n//SWC-102-Outdated Compiler Version: All\n/**\n * @title ROSCA on a blockchain.\n *\n * A ROSCA (Rotating and Savings Credit Association) is an agreement between\n * trusted friends to contribute funds on a periodic basis to a \"pot\", and in\n * each round one of the participants receives the pot (termed \"winner\").\n * The winner is selected as the person who makes the lowest bid in that round\n * among those who have not won a bid before.\n * The discount (gap between bid and total round contributions) is dispersed\n * evenly between the participants.\n */\ncontract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "DAOConstantGas",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2020-07-14\n*/\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2020-07-22\n*/\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.16;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2019-03-27\n*/\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.11;\n\n\n/*\n\n  Copyright 2019 ZeroEx Intl.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n\n*/\ncontract Token {\n\n    \n    function totalSupply() constant returns (uint supply) {}\n\n    \n    \n    function balanceOf(address _owner) constant returns (uint balance) {}\n\n    \n    \n    \n    \n    function transfer(address _to, uint _value) returns (bool success) {}\n\n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}\n\n    \n    \n    \n    \n    function approve(address _spender, uint _value) returns (bool success) {}\n\n    \n    \n    \n    function allowance(address _owner, address _spender) constant returns (uint remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract ERC20Token is Token {\n\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns (bool) {\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint) balances;\n    mapping (address => mapping (address => uint)) allowed;\n    uint public totalSupply;\n}\n\ncontract UnlimitedAllowanceToken is ERC20Token {\n\n    uint constant MAX_UINT = 2**256 - 1;\n\n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint _value)\n        public\n        returns (bool)\n    {\n        uint allowance = allowed[_from][msg.sender];\n        if (balances[_from] >= _value\n            && allowance >= _value\n            && balances[_to] + _value >= balances[_to]\n        ) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            if (allowance < MAX_UINT) {\n                allowed[_from][msg.sender] -= _value;\n            }\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract ZRXToken is \n    UnlimitedAllowanceToken {\n\n    // solhint-disable const-name-snakecase\n    uint8 constant public decimals = 18;\n    uint256 public totalSupply = 10**27; // 1 billion tokens, 18 decimal places\n    string constant public name = \"0x Protocol Token\";\n    string constant public symbol = \"ZRX\";\n    // solhint-enableconst-name-snakecase\n\n    function ZRXToken()\n        public\n    {\n        balances[msg.sender] = totalSupply;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Exchange_v4/protocol-475b608338561a1dce3199bfb9fb59ee9372149b/contracts/erc20/contracts/src/ZRXToken.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity >=0.4.22 <0.9.0;\n\n\n// SPDX-License-Identifier: MIT\ncontract Migrations {\n  address public owner = msg.sender;\n  uint public last_completed_migration;\n\n  modifier restricted() {\n    require(\n      msg.sender == owner,\n      \"This function is restricted to the contract's owner\"\n    );\n    _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Furucombo-project2/trevi-b3f7fd332873321152db48c9d43fc23a60a29f1a/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.15;\n\n\ncontract BytesUtils {\n    function readBytes32(bytes data, uint256 index) internal constant returns (bytes32 o) {\n        assembly {\n            o := mload(add(data, add(32, mul(32, index))))\n        }\n    }\n}\n\n/* taking ideas from FirstBlood token */\ncontract RpSafeMath {\n    function safeAdd(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x + y;\n      assert((z >= x) && (z >= y));\n      return z;\n    }\n\n    function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {\n      assert(x >= y);\n      uint256 z = x - y;\n      return z;\n    }\n\n    function safeMult(uint256 x, uint256 y) internal returns(uint256) {\n      uint256 z = x * y;\n      assert((x == 0)||(z/x == y));\n      return z;\n    }\n\n    function min(uint256 a, uint256 b) internal returns(uint256) {\n        if (a < b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n    \n    function max(uint256 a, uint256 b) internal returns(uint256) {\n        if (a > b) { \n          return a;\n        } else { \n          return b; \n        }\n    }\n}\n\ncontract Ownable {\n    address public owner;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Ownable() public {\n        owner = msg.sender; \n    }\n\n    /**\n        @dev Transfers the ownership of the contract.\n\n        @param _to Address of the new owner\n    */\n    function transferTo(address _to) public onlyOwner returns (bool) {\n        require(_to != address(0));\n        owner = _to;\n        return true;\n    } \n}\n\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n\n/**\n    @dev Defines the interface of a standard RCN oracle.\n\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\n    it's primarily used by the exchange but could be used by any other agent.\n*/\ncontract Oracle is Ownable {\n    uint256 public constant VERSION = 2;\n\n    event NewSymbol(bytes32 _currency, string _ticker, uint8 _decimals);\n    \n    struct Symbol {\n        string ticker;\n        uint8 decimals;\n        bool supported;\n    }\n\n    mapping(bytes32 => Symbol) public currencies;\n\n    /**\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\n    */\n    function url() constant returns (string);\n\n    /**\n        @dev Returns a valid convertion rate from the currency given to RCN\n\n        @param symbol Symbol of the currency\n        @param data Generic data field, could be used for off-chain signing\n    */\n    function getRate(bytes32 symbol, bytes data) constant returns (uint256);\n\n    /**\n        @dev Adds a currency to the oracle, once added it cannot be removed\n\n        @param ticker Symbol of the currency\n        @param decimals Decimals of the convertion\n\n        @return the hash of the currency, calculated keccak256(ticker, decimals)\n    */\n    function addCurrency(string ticker, uint8 decimals) public onlyOwner returns (bytes32) {\n        NewSymbol(currency, ticker, decimals);\n        bytes32 currency = keccak256(ticker, decimals);\n        currencies[currency] = Symbol(ticker, decimals, true);\n        return currency;\n    }\n\n    /**\n        @return The number of decimals of a given currency hash, only if registered\n    */\n    function decimals(bytes32 symbol) constant returns (uint8) {\n        return currencies[symbol].decimals;\n    }\n\n    /**\n        @return true If the currency is supported\n    */\n    function supported(bytes32 symbol) constant returns (bool) {\n        return currencies[symbol].supported;\n    }\n}\n\ncontract Engine {\n    uint256 public VERSION;\n    string public VERSION_NAME;\n\n    enum Status { initial, lent, paid, destroyed }\n    struct Approbation {\n        bool approved;\n        bytes data;\n        bytes32 checksum;\n    }\n\n    function getTotalLoans() constant returns (uint256);\n    function getOracle(uint index) constant returns (Oracle);\n    function getBorrower(uint index) constant returns (address);\n    function getCosigner(uint index) constant returns (address);\n    function ownerOf(uint256) constant returns (address owner);\n    function getCreator(uint index) constant returns (address);\n    function getAmount(uint index) constant returns (uint256);\n    function getPaid(uint index) constant returns (uint256);\n    function getDueTime(uint index) constant returns (uint256);\n    function getApprobation(uint index, address _address) constant returns (bool);\n    function getStatus(uint index) constant returns (Status);\n    function isApproved(uint index) constant returns (bool);\n    function getPendingAmount(uint index) constant public returns (uint256);\n    function getCurrency(uint index) constant public returns (bytes32);\n    function cosign(uint index, uint256 cost) external returns (bool);\n    function approveLoan(uint index) public returns (bool);\n    function transfer(address to, uint256 index) public returns (bool);\n    function takeOwnership(uint256 index) public returns (bool);\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\n}\n\n/**\n    @dev Defines the interface of a standard RCN cosigner.\n\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\n    of the insurance and the cost of the given are defined by the cosigner. \n\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\n    \n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\n    call this method, like the transfer of the ownership of the loan.\n*/\ncontract Cosigner {\n    uint256 public constant VERSION = 2;\n    \n    /**\n        @return the url of the endpoint that exposes the insurance offers.\n    */\n    function url() constant returns (string);\n    \n    /**\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\n\n        @return the cost of the cosign, in RCN wei\n    */\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) constant returns (uint256);\n    \n    /**\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\n        does not return true to this method, the operation fails.\n\n        @return true if the cosigner accepts the liability\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\n    \n    /**\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\n        current lender of the loan.\n\n        @return true if the claim was done correctly.\n    */\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\n}\n\ncontract SimpleDelegable is Ownable {\n    mapping(address => bool) delegates;\n\n    modifier onlyDelegate() {\n        require(delegates[msg.sender]);\n        _;\n    }\n\n    function isDelegate(address _delegate) constant public returns (bool) {\n        return delegates[_delegate];\n    }\n\n    function addDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = true;\n        return true;\n    }\n\n    function removeDelegate(address _delegate) public onlyOwner returns (bool) {\n        delegates[_delegate] = false;\n        return true;\n    }\n}\n\ncontract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.18;\n\n\n/**@dev Simple interface to Owned base class */\ncontract IOwned {\n    function owner() public constant returns (address) {}\n    function transferOwnership(address _newOwner) public;\n}\n\ncontract Owned is IOwned {\n    address public owner;        \n\n    function Owned() public {\n        owner = msg.sender;\n    }\n\n    // allows execution by the owner only\n    modifier ownerOnly {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**@dev allows transferring the contract ownership. */\n    function transferOwnership(address _newOwner) public ownerOnly {\n        require(_newOwner != owner);\n        owner = _newOwner;\n    }\n}\n\n/**@dev ERC20 compliant token interface. \nhttps://theethereum.wiki/w/index.php/ERC20_Token_Standard \nhttps://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */\ncontract IERC20Token {\n\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external    \n    function name() public constant returns (string _name) { _name; }\n    function symbol() public constant returns (string _symbol) { _symbol; }\n    function decimals() public constant returns (uint8 _decimals) { _decimals; }\n    \n    function totalSupply() public constant returns (uint total) {total;}\n    function balanceOf(address _owner) public constant returns (uint balance) {_owner; balance;}    \n    function allowance(address _owner, address _spender) public constant returns (uint remaining) {_owner; _spender; remaining;}\n\n    function transfer(address _to, uint _value) public returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\n    function approve(address _spender, uint _value) public returns (bool success);\n    \n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\n/**dev Utility methods for overflow-proof arithmetic operations \n*/\ncontract SafeMath {\n\n    /**dev Returns the sum of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a+b >= a);\n        return a+b;\n    }\n\n    /**dev Returns the difference of a and b. Throws an exception if a is less than b*/\n    function safeSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(a >= b);\n        return a - b;\n    }\n\n    /**dev Returns the product of a and b. Throws an exception if it exceeds uint256 limits*/\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\n        uint256 z = x * y;\n        require((x == 0) || (z / x == y));\n        return z;\n    }\n\n    function safeDiv(uint256 x, uint256 y) internal pure returns (uint256) {\n        require(y != 0);\n        return x / y;\n    }\n}\n\n/**@dev Standard ERC20 compliant token implementation */\ncontract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}\n\n/**@dev This token stores list of preapproved spenders - those allowed to 'transferFrom' without approval.\n It also contains a flag 'transferAllowed' that switches possibility of user-to-user transfer */\ncontract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}\n\n\n\ncontract Manageable is Owned {\n\n    event ManagerSet(address manager, bool state);\n\n    mapping (address => bool) public managers;\n\n    function Manageable() public Owned() {\n        managers[owner] = true;\n    }\n\n    /**@dev Allows execution by managers only */\n    modifier managerOnly {\n        require(managers[msg.sender]);\n        _;\n    }\n\n    function transferOwnership(address _newOwner) public ownerOnly {\n        super.transferOwnership(_newOwner);\n\n        managers[_newOwner] = true;\n        managers[msg.sender] = false;\n    }\n\n    function setManager(address manager, bool state) public ownerOnly {\n        managers[manager] = state;\n        ManagerSet(manager, state);\n    }\n}\n\n\ncontract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}\n\n/**@dev A token that can be burnt */\ncontract IBurnableToken {\n    function burn(uint256 _value) public;\n}\n\n/**@dev A token that can be minted and burnt */\ncontract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}\n\ncontract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\ncontract ERC735 {\n\n    event ClaimRequested(uint256 indexed claimRequestId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimChanged(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    struct Claim {\n        uint256 topic;\n        uint256 scheme;\n        address issuer; // msg.sender\n        bytes signature; // this.address + topic + data\n        bytes data;\n        string uri;\n    }\n\n    function getClaim(bytes32 _claimId) public view returns(uint256 topic, uint256 scheme, address issuer, bytes signature, bytes data, string uri);\n    function getClaimIdsByTopic(uint256 _topic) public view returns(bytes32[] claimIds);\n    function addClaim(uint256 _topic, uint256 _scheme, address issuer, bytes _signature, bytes _data, string _uri) public returns (bytes32 claimRequestId);\n    function removeClaim(bytes32 _claimId) public returns (bool success);\n}\n\ncontract ERC725 {\n\n    uint256 constant MANAGEMENT_KEY = 1;\n    uint256 constant ACTION_KEY = 2;\n    uint256 constant CLAIM_SIGNER_KEY = 3;\n    uint256 constant ENCRYPTION_KEY = 4;\n\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    function getKey(bytes32 _key) public view returns(uint256[] purposes, uint256 keyType, bytes32 key);\n    function keyHasPurpose(bytes32 _key, uint256 _purpose) public view returns (bool exists);\n    function getKeysByPurpose(uint256 _purpose) public view returns(bytes32[] keys);\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType) public returns (bool success);\n    function removeKey(bytes32 _key, uint256 _purpose) public returns (bool success);\n    function execute(address _to, uint256 _value, bytes _data) public returns (uint256 executionId);\n    function approve(uint256 _id, bool _approve) public returns (bool success);\n}\n\nlibrary KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}\n\ncontract KeyHolder is ERC725 {\n    KeyHolderLibrary.KeyHolderData keyHolderData;\n\n    constructor() public {\n        KeyHolderLibrary.init(keyHolderData);\n    }\n\n    function getKey(bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return KeyHolderLibrary.getKey(keyHolderData, _key);\n    }\n\n    function getKeyPurposes(bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return KeyHolderLibrary.getKeyPurposes(keyHolderData, _key);\n    }\n\n    function getKeysByPurpose(uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return KeyHolderLibrary.getKeysByPurpose(keyHolderData, _purpose);\n    }\n\n    function addKey(bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        return KeyHolderLibrary.addKey(keyHolderData, _key, _purpose, _type);\n    }\n\n    function approve(uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        return KeyHolderLibrary.approve(keyHolderData, _id, _approve);\n    }\n\n    function execute(address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        return KeyHolderLibrary.execute(keyHolderData, _to, _value, _data);\n    }\n\n    function removeKey(bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        return KeyHolderLibrary.removeKey(keyHolderData, _key, _purpose);\n    }\n\n    function keyHasPurpose(bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool exists)\n    {\n        return KeyHolderLibrary.keyHasPurpose(keyHolderData, _key, _purpose);\n    }\n\n}\n\nlibrary ClaimHolderLibrary {\n    event ClaimAdded(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n    event ClaimRemoved(bytes32 indexed claimId, uint256 indexed topic, uint256 scheme, address indexed issuer, bytes signature, bytes data, string uri);\n\n    struct Claim {\n        uint256 topic;\n        uint256 scheme;\n        address issuer; // msg.sender\n        bytes signature; // this.address + topic + data\n        bytes data;\n        string uri;\n    }\n\n    struct Claims {\n        mapping (bytes32 => Claim) byId;\n        mapping (uint256 => bytes32[]) byTopic;\n    }\n\n    function addClaim(\n        KeyHolderLibrary.KeyHolderData storage _keyHolderData,\n        Claims storage _claims,\n        uint256 _topic,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    )\n        public\n        returns (bytes32 claimRequestId)\n    {\n        if (msg.sender != address(this)) {\n            require(KeyHolderLibrary.keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 3), \"Sender does not have claim signer key\");\n        }\n\n        bytes32 claimId = keccak256(abi.encodePacked(_issuer, _topic));\n\n        if (_claims.byId[claimId].issuer != _issuer) {\n            _claims.byTopic[_topic].push(claimId);\n        }\n\n        _claims.byId[claimId].topic = _topic;\n        _claims.byId[claimId].scheme = _scheme;\n        _claims.byId[claimId].issuer = _issuer;\n        _claims.byId[claimId].signature = _signature;\n        _claims.byId[claimId].data = _data;\n        _claims.byId[claimId].uri = _uri;\n\n        emit ClaimAdded(\n            claimId,\n            _topic,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n\n        return claimId;\n    }\n\n    function addClaims(\n        KeyHolderLibrary.KeyHolderData storage _keyHolderData,\n        Claims storage _claims,\n        uint256[] _topic,\n        address[] _issuer,\n        bytes _signature,\n        bytes _data,\n        uint256[] _offsets\n    )\n        public\n    {\n        uint offset = 0;\n        for (uint16 i = 0; i < _topic.length; i++) {\n            addClaim(\n                _keyHolderData,\n                _claims,\n                _topic[i],\n                1,\n                _issuer[i],\n                getBytes(_signature, (i * 65), 65),\n                getBytes(_data, offset, _offsets[i]),\n                \"\"\n            );\n            offset += _offsets[i];\n        }\n    }\n\n    function removeClaim(\n        KeyHolderLibrary.KeyHolderData storage _keyHolderData,\n        Claims storage _claims,\n        bytes32 _claimId\n    )\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(KeyHolderLibrary.keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\");\n        }\n\n        emit ClaimRemoved(\n            _claimId,\n            _claims.byId[_claimId].topic,\n            _claims.byId[_claimId].scheme,\n            _claims.byId[_claimId].issuer,\n            _claims.byId[_claimId].signature,\n            _claims.byId[_claimId].data,\n            _claims.byId[_claimId].uri\n        );\n\n        delete _claims.byId[_claimId];\n        return true;\n    }\n\n    function getClaim(Claims storage _claims, bytes32 _claimId)\n        public\n        view\n        returns(\n          uint256 topic,\n          uint256 scheme,\n          address issuer,\n          bytes signature,\n          bytes data,\n          string uri\n        )\n    {\n        return (\n            _claims.byId[_claimId].topic,\n            _claims.byId[_claimId].scheme,\n            _claims.byId[_claimId].issuer,\n            _claims.byId[_claimId].signature,\n            _claims.byId[_claimId].data,\n            _claims.byId[_claimId].uri\n        );\n    }\n\n    function getBytes(bytes _str, uint256 _offset, uint256 _length)\n        internal\n        pure\n        returns (bytes)\n    {\n        bytes memory sig = new bytes(_length);\n        uint256 j = 0;\n        for (uint256 k = _offset; k < _offset + _length; k++) {\n            sig[j] = _str[k];\n            j++;\n        }\n        return sig;\n    }\n}\n\ncontract ClaimHolder is KeyHolder, ERC735 {\n\n    ClaimHolderLibrary.Claims claims;\n\n    function addClaim(\n        uint256 _topic,\n        uint256 _scheme,\n        address _issuer,\n        bytes _signature,\n        bytes _data,\n        string _uri\n    )\n        public\n        returns (bytes32 claimRequestId)\n    {\n        return ClaimHolderLibrary.addClaim(\n            keyHolderData,\n            claims,\n            _topic,\n            _scheme,\n            _issuer,\n            _signature,\n            _data,\n            _uri\n        );\n    }\n\n    function addClaims(\n        uint256[] _topic,\n        address[] _issuer,\n        bytes _signature,\n        bytes _data,\n        uint256[] _offsets\n    )\n        public\n    {\n        ClaimHolderLibrary.addClaims(\n            keyHolderData,\n            claims,\n            _topic,\n            _issuer,\n            _signature,\n            _data,\n            _offsets\n        );\n    }\n\n    function removeClaim(bytes32 _claimId) public returns (bool success) {\n        return ClaimHolderLibrary.removeClaim(keyHolderData, claims, _claimId);\n    }\n\n    function getClaim(bytes32 _claimId)\n        public\n        view\n        returns(\n            uint256 topic,\n            uint256 scheme,\n            address issuer,\n            bytes signature,\n            bytes data,\n            string uri\n        )\n    {\n        return ClaimHolderLibrary.getClaim(claims, _claimId);\n    }\n\n    function getClaimIdsByTopic(uint256 _topic)\n        public\n        view\n        returns(bytes32[] claimIds)\n    {\n        return claims.byTopic[_topic];\n    }\n}\n\n\n\n\ncontract V00_UserRegistry {\n    /*\n    * Events\n    */\n\n    event NewUser(address _address, address _identity);\n\n    /*\n    * Storage\n    */\n\n    // Mapping from ethereum wallet to ERC725 identity\n    mapping(address => address) public users;\n\n    /*\n    * Public functions\n    */\n\n    \n    function registerUser()\n        public\n    {\n        users[tx.origin] = msg.sender;\n        emit NewUser(tx.origin, msg.sender);\n    }\n\n    \n    function clearUser()\n        public\n    {\n        users[msg.sender] = 0;\n    }\n}\n\ncontract ClaimHolderRegistered is ClaimHolder {\n\n    constructor (\n        address _userRegistryAddress\n    )\n        public\n    {\n        V00_UserRegistry userRegistry = V00_UserRegistry(_userRegistryAddress);\n        userRegistry.registerUser();\n    }\n}\n\n/**\n * NOTE: This contract exists as a convenience for deploying an identity with\n * some 'pre-signed' claims. If you don't care about that, just use ClaimHolder\n * instead.\n */\ncontract ClaimHolderPresigned is ClaimHolderRegistered {\n\n    constructor(\n        address _userRegistryAddress,\n        uint256[] _topic,\n        address[] _issuer,\n        bytes _signature,\n        bytes _data,\n        uint256[] _offsets\n    )\n        ClaimHolderRegistered(_userRegistryAddress)\n        public\n    {\n        ClaimHolderLibrary.addClaims(\n            keyHolderData,\n            claims,\n            _topic,\n            _issuer,\n            _signature,\n            _data,\n            _offsets\n        );\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/V00_UserRegistry.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-95d73f7b74483e72fffe1f8ee90f037a2f7b8773/legacy/common/Pausable.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n// https://docs.synthetix.io/contracts/Pausable\ncontract Pausable is Owned {\n    uint public lastPauseTime;\n    bool public paused;\n\n    /**\n     * @dev Constructor\n     * @param _owner The account which controls this contract.\n     */\n    constructor(address _owner) public Owned(_owner) {\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\n    }\n\n    /**\n     * @notice Change the paused state of the contract\n     * @dev Only the contract owner may call this.\n     */\n    function setPaused(bool _paused) external onlyOwner {\n        // Ensure we're actually changing the state before we do anything\n        if (_paused == paused) {\n            return;\n        }\n\n        // Set our paused state.\n        paused = _paused;\n\n        // If applicable, set the last pause time.\n        if (paused) {\n            lastPauseTime = now;\n        }\n\n        // Let everyone know that our pause state has changed.\n        emit PauseChanged(paused);\n    }\n\n    event PauseChanged(bool isPaused);\n\n    modifier notPaused {\n        require(!paused, \"This action cannot be performed while the contract is paused\");\n        _;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Fomalhaut Release Smart Contract Audit/synthetix-b1bbcf88cc3f49e5d67954003313ede4520ba00a/legacy/common/Pausable.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract State is Owned {\n    address public associatedContract;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n// https://docs.synthetix.io/contracts/ExchangeState\ncontract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// https://docs.synthetix.io/contracts/LimitedSetup\ncontract LimitedSetup {\n    uint setupExpiryTime;\n\n    /**\n     * @dev LimitedSetup Constructor.\n     * @param setupDuration The time the setup period will last for.\n     */\n    constructor(uint setupDuration) public {\n        setupExpiryTime = now + setupDuration;\n    }\n\n    modifier onlyDuringSetup {\n        require(now < setupExpiryTime, \"Can only perform this action during setup\");\n        _;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract State is Owned {\n    address public associatedContract;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n/**\n * @notice  This contract is based on the code available from this blog\n * https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88/\n * Implements support for storing a keccak256 key and value pairs. It is the more flexible\n * and extensible option. This ensures data schema changes can be implemented without\n * requiring upgrades to the storage contract.\n */\n// https://docs.synthetix.io/contracts/EternalStorage\ncontract EternalStorage is State {\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== DATA TYPES ========== */\n    mapping(bytes32 => uint) UIntStorage;\n    mapping(bytes32 => string) StringStorage;\n    mapping(bytes32 => address) AddressStorage;\n    mapping(bytes32 => bytes) BytesStorage;\n    mapping(bytes32 => bytes32) Bytes32Storage;\n    mapping(bytes32 => bool) BooleanStorage;\n    mapping(bytes32 => int) IntStorage;\n\n    // UIntStorage;\n    function getUIntValue(bytes32 record) external view returns (uint) {\n        return UIntStorage[record];\n    }\n\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\n        UIntStorage[record] = value;\n    }\n\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\n        delete UIntStorage[record];\n    }\n\n    // StringStorage\n    function getStringValue(bytes32 record) external view returns (string memory) {\n        return StringStorage[record];\n    }\n\n    function setStringValue(bytes32 record, string value) external onlyAssociatedContract {\n        StringStorage[record] = value;\n    }\n\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\n        delete StringStorage[record];\n    }\n\n    // AddressStorage\n    function getAddressValue(bytes32 record) external view returns (address) {\n        return AddressStorage[record];\n    }\n\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\n        AddressStorage[record] = value;\n    }\n\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\n        delete AddressStorage[record];\n    }\n\n    // BytesStorage\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\n        return BytesStorage[record];\n    }\n\n    function setBytesValue(bytes32 record, bytes value) external onlyAssociatedContract {\n        BytesStorage[record] = value;\n    }\n\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\n        delete BytesStorage[record];\n    }\n\n    // Bytes32Storage\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\n        return Bytes32Storage[record];\n    }\n\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\n        Bytes32Storage[record] = value;\n    }\n\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\n        delete Bytes32Storage[record];\n    }\n\n    // BooleanStorage\n    function getBooleanValue(bytes32 record) external view returns (bool) {\n        return BooleanStorage[record];\n    }\n\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\n        BooleanStorage[record] = value;\n    }\n\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\n        delete BooleanStorage[record];\n    }\n\n    // IntStorage\n    function getIntValue(bytes32 record) external view returns (int) {\n        return IntStorage[record];\n    }\n\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\n        IntStorage[record] = value;\n    }\n\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\n        delete IntStorage[record];\n    }\n}\n\n// https://docs.synthetix.io/contracts/FeePoolEternalStorage\ncontract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n    bytes32 constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    /**\n     * @dev Constructor.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\n\n    /**\n     * @notice Import data from FeePool.lastFeeWithdrawal\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\n     * @param accounts Array of addresses that have claimed\n     * @param feePeriodIDs Array feePeriodIDs with the accounts last claim\n     */\n    function importFeeWithdrawalData(address[] accounts, uint[] feePeriodIDs) external onlyOwner onlyDuringSetup {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/FeePoolEternalStorage.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ISynthetix is IERC20 {}\n\ncontract IFeePool {}\n\n// https://docs.synthetix.io/contracts/RewardEscrow\ncontract RewardEscrow is Owned {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint constant TIME_INDEX = 0;\n    uint constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(_feePool);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2]) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2]) {\n        uint index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520]) {\n        uint[520] memory _result;\n        uint schedules = numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) public onlyFeePool {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= synthetix.balanceOf(this),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            synthetix.transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/RewardEscrow.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract State is Owned {\n    address public associatedContract;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/common/State.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ninterface IFeePool {\n    function setRewardsToDistribute(uint amount) external;\n}\n\n// https://docs.synthetix.io/contracts/RewardsDistribution\ncontract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity 0.4.25;\n\n\n// from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.0.0/contracts/math/SafeMath.sol\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two numbers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two numbers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n\n// https://docs.synthetix.io/contracts/SafeDecimalMath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n}\n\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n        _;\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\ncontract IERC20 {\n    function totalSupply() public view returns (uint);\n\n    function balanceOf(address owner) public view returns (uint);\n\n    function allowance(address owner, address spender) public view returns (uint);\n\n    function transfer(address to, uint value) public returns (bool);\n\n    function approve(address spender, uint value) public returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) public returns (bool);\n\n    // ERC20 Optional\n    function name() public view returns (string);\n\n    function symbol() public view returns (string);\n\n    function decimals() public view returns (uint8);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ISynthetix is IERC20 {}\n\ncontract IFeePool {}\n\n// https://docs.synthetix.io/contracts/RewardEscrow\ncontract RewardEscrow is Owned {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint constant TIME_INDEX = 0;\n    uint constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(_feePool);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2]) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2]) {\n        uint index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520]) {\n        uint[520] memory _result;\n        uint schedules = numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) public onlyFeePool {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= synthetix.balanceOf(this),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            synthetix.transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardEscrow.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title IERC165\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\n */\ninterface IERC165 {\n\n  /**\n   * @notice Query if a contract implements an interface\n   * @param interfaceId The interface identifier, as specified in ERC-165\n   * @dev Interface identification is specified in ERC-165. This function\n   * uses less than 30,000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-214.md#specification\n * > Any attempts to make state-changing operations inside an execution instance with STATIC set to true will instead throw an exception.\n * > These operations include [...], LOG0, LOG1, LOG2, [...]\n *\n * therefore, because this contract is staticcall'd we need to not emit events (which is how solidity-coverage works)\n * solidity-coverage ignores the /mocks folder, so we duplicate its implementation here to avoid instrumenting it\n */\ncontract SupportsInterfaceWithLookupMock is IERC165 {\n\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\n  /**\n   * 0x01ffc9a7 ===\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\n   */\n\n  /**\n   * @dev a mapping of interface id to whether or not it's supported\n   */\n  mapping(bytes4 => bool) private _supportedInterfaces;\n\n  /**\n   * @dev A contract implementing SupportsInterfaceWithLookup\n   * implement ERC165 itself\n   */\n  constructor()\n    public\n  {\n    _registerInterface(InterfaceId_ERC165);\n  }\n\n  /**\n   * @dev implement supportsInterface(bytes4) using a lookup table\n   */\n  function supportsInterface(bytes4 interfaceId)\n    external\n    view\n    returns (bool)\n  {\n    return _supportedInterfaces[interfaceId];\n  }\n\n  /**\n   * @dev private method for registering an interface\n   */\n  function _registerInterface(bytes4 interfaceId)\n    internal\n  {\n    require(interfaceId != 0xffffffff);\n    _supportedInterfaces[interfaceId] = true;\n  }\n}\n\ncontract ERC165InterfacesSupported is SupportsInterfaceWithLookupMock {\n  constructor (bytes4[] interfaceIds)\n    public\n  {\n    for (uint256 i = 0; i < interfaceIds.length; i++) {\n      _registerInterface(interfaceIds[i]);\n    }\n  }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ERC165/ERC165InterfacesSupported.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Helps contracts guard against reentrancy attacks.\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\n * @dev If you mark a function `nonReentrant`, you should also\n * mark it `external`.\n */\ncontract ReentrancyGuard {\n\n  \n  uint256 private _guardCounter;\n\n  constructor() internal {\n    // The counter starts at one to prevent changing it from zero to a non-zero\n    // value, which is a more expensive operation.\n    _guardCounter = 1;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and make it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    _guardCounter += 1;\n    uint256 localCounter = _guardCounter;\n    _;\n    require(localCounter == _guardCounter);\n  }\n\n}\n\ncontract ReentrancyAttack {\n\n  function callSender(bytes4 data) public {\n    // solium-disable-next-line security/no-low-level-calls\n    require(msg.sender.call(abi.encodeWithSelector(data)));\n  }\n\n}\n\ncontract ReentrancyMock is ReentrancyGuard {\n\n  uint256 public counter;\n\n  constructor() public {\n    counter = 0;\n  }\n\n  function callback() external nonReentrant {\n    count();\n  }\n\n  function countLocalRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      countLocalRecursive(n - 1);\n    }\n  }\n\n  function countThisRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      // solium-disable-next-line security/no-low-level-calls\n      bool result = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n      require(result == true);\n    }\n  }\n\n  function countAndCall(ReentrancyAttack attacker) public nonReentrant {\n    count();\n    bytes4 func = bytes4(keccak256(\"callback()\"));\n    attacker.callSender(func);\n  }\n\n  function count() private {\n    counter += 1;\n  }\n\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity 0.4.24;\n\n\n// SPDX-FileCopyrightText: 2020 Lido <info@lido.fi>\n// SPDX-License-Identifier: GPL-3.0\n/**\n  * @dev Only for testing purposes! Lido version with some functions exposed.\n  */\ncontract LidoMockForOracle {\n    uint256 private totalPooledEther;\n\n    function totalSupply() external view returns (uint256) {\n        return totalPooledEther;\n    }\n\n    function pushBeacon(uint256 /*_beaconValidators*/, uint256 _beaconBalance) external {\n        totalPooledEther = _beaconBalance;\n    }\n\n    function getTotalShares() public view returns (uint256) {\n        return 42;\n    }\n\n    function pretendTotalPooledEtherGweiForTest(uint256 _val) public {\n        totalPooledEther = _val * 1e9; // gwei to wei\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Lido-WstETH/lido-dao-ea6fa222004b88e6a24b566a51e5b56b0079272d/contracts/0.4.24/test_helpers/LidoMockForOracle.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: Yes"
    },
    {
        "code_segment": "pragma solidity ^0.4.23;\n\n\ncontract Migrations {\n    address public owner;\n    uint public last_completed_migration;\n\n    modifier restricted() {\n        if (msg.sender == owner) _;\n    }\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function setCompleted(uint completed) public restricted {\n        last_completed_migration = completed;\n    }\n\n    function upgrade(address new_address) public restricted {\n        Migrations upgraded = Migrations(new_address);\n        upgraded.setCompleted(last_completed_migration);\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/blockchain/source/contracts/Migrations.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    },
    {
        "code_segment": "pragma solidity ^0.4.0;\n\n\ncontract AbstractENS {\n    function owner(bytes32 node) constant returns(address);\n    function resolver(bytes32 node) constant returns(address);\n    function ttl(bytes32 node) constant returns(uint64);\n    function setOwner(bytes32 node, address owner);\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner);\n    function setResolver(bytes32 node, address resolver);\n    function setTTL(bytes32 node, uint64 ttl);\n\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n}\n\n/**\n * The ENS registry contract.\n */\ncontract ENS is AbstractENS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        if (records[node].owner != msg.sender) throw;\n        _;\n    }\n\n    /**\n     * Constructs a new ENS registrar.\n     */\n    function ENS() {\n        records[0].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) constant returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) constant returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) constant returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) only_owner(node) {\n        Transfer(node, owner);\n        records[node].owner = owner;\n    }\n\n    /**\n     * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) {\n        var subnode = sha3(node, label);\n        NewOwner(node, label, owner);\n        records[subnode].owner = owner;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) only_owner(node) {\n        NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) only_owner(node) {\n        NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n}\n",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/vendor/github.com/ethereum/go-ethereum/contracts/ens/contract/ens.sol",
        "vulnerability": "MissingInputValidation",
        "check": "FP",
        "response": "Answer: No"
    }
]