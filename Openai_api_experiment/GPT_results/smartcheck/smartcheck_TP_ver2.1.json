[
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n/**\n *Submitted for verification at Etherscan.io on 2020-07-14\n*/\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "SOLIDITY_VISIBILITY",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The functions `stop` and `start` have no visibility specified, which defaults to `public`. Explicitly declaring visibility is a good practice."
    },
    {
        "code_segment": "pragma solidity ^0.4.21;\n\n\n// ownership contract\ncontract Owned {\n    address public owner;\n\n    event TransferOwnership(address oldaddr, address newaddr);\n\n    modifier onlyOwner() { if (msg.sender != owner) return; _; }\n\n    function Owned() public {\n        owner = msg.sender;\n    }\n    \n    function transferOwnership(address _new) onlyOwner public {\n        address oldaddr = owner;\n        owner = _new;\n        emit TransferOwnership(oldaddr, owner);\n    }\n}\n\n// erc20\ncontract ERC20Interface {\n\tuint256 public totalSupply;\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "SOLIDITY_VISIBILITY",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The functions `stop` and `start` are missing visibility specifiers, which defaults them to public, creating a potential unexpected exposure."
    },
    {
        "code_segment": "pragma solidity ^0.8.10;\n\n\n// SPDX-License-Identifier: MIT\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// SWC-103-Floating Pragma\ncontract SimpleToken is ERC20 {\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 totalSupply_\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, totalSupply_);\n    }\n\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-ApeCoin/0x4d224452801ACEd8B2F0aebE155379bb5D594381/SimpeToken.sol",
        "vulnerability": "SOLIDITY_PRAGMAS_VERSION",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The code uses a floating pragma `^0.8.10`, which can lead to unexpected behavior if a newer version of the compiler introduces breaking changes."
    },
    {
        "code_segment": "pragma solidity ^0.8.0;\n\n\n// SPDX-License-Identifier: MIT\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overloaded;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        _approve(sender, _msgSender(), currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n\n// SWC-102-Outdated Compiler Version: L3\ncontract CheckDot is ERC20 {\n    // CheckDot token decimal\n    uint8 public constant _decimals = 18;\n    // Total supply for the CheckDot token = 10M\n    uint256 private _totalSupply = 10000000 * (10 ** uint256(_decimals));\n    // Token CheckDot deployer\n    address private _checkDotDeployer;\n\n    constructor(address _deployer) ERC20(\"CheckDot\", \"CDT\") {\n        _checkDotDeployer = _deployer;\n        _mint(_checkDotDeployer, _totalSupply);\n    }\n\n    function burn(uint256 amount) external returns (bool) {\n        _burn(msg.sender, amount);\n        return true;\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-Checkdot Smart Contract/CheckdotERC20Contract-8a47ef13ace93e0bd473fb1c3893790569a2adc8/contracts/CheckDot.sol",
        "vulnerability": "SOLIDITY_PRAGMAS_VERSION",
        "check": "TP",
        "response": "Answer: No\nReason: pragma solidity version \"^0.8.0\" is specified, and it is a safe and updated version."
    },
    {
        "code_segment": "pragma solidity 0.8.11;\n\n\n// SWC-103-Floating Pragma: L2\n// SPDX-License-Identifier: Unlicensed\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n\ncontract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n    address private _previousOwner;\n    uint256 private _lockTime;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ncontract Fidometa is Context, IERC20, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _rOwned;\n    mapping(address => uint256) private _tOwned;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n    mapping(address => bool) public _isExcludedFromCommunity_charge;\n    mapping(address => bool) public _isExcludedFromReward;\n\n    address[] private _excluded;\n\n    mapping(address => bool) public _isExcludedFromEcoSysFee;\n    mapping(address => bool) public _isExcludedFromSurcharge1;\n    mapping(address => bool) public _isExcludedFromSurcharge2;\n    mapping(address => bool) public _isExcludedFromSurcharge3;\n\n    uint256 private constant MAX = ~uint256(0);\n\n    string public name = \"Fido Meta\";\n    string public symbol = \"FMC\";\n    uint8 public decimals = 9;\n    uint256 private _tTotal = 15000000000 * 10**uint256(decimals);\n    uint256 public _cap;\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\n    uint256 public _tCommunityChargeTotal;\n\n    address public _ecoSysWallet;\n    address public _surcharge_1_Wallet;\n    address public _surcharge_2_Wallet;\n    address public _surcharge_3_Wallet;\n\n    uint256 public _community_charge = 3 * 10**uint256(decimals);\n    uint256 public _ecoSysFee = 15 * 10**8;\n    uint256 public _surcharge1 = 5 * 10**8;\n    uint256 public _surcharge2 = 0;\n    uint256 public _surcharge3 = 0;\n\n    uint256 private _previousCommunityCharge = _community_charge;\n    uint256 private _previousEcoSysFee = _ecoSysFee;\n    uint256 private _previousSurcharge1 = _surcharge1;\n    uint256 private _previousSurcharge2 = _surcharge2;\n    uint256 private _previousSurcharge3 = _surcharge3;\n\n    uint256 public _maxTxAmount = 5000000 * 10**uint256(decimals);\n\n    event Burn(address from, uint256 value);\n    event Mint(address from, uint256 value);\n\n    mapping(address => LockDetails) public locks;\n\n    struct LockDetails {\n        uint256 startTime;\n        uint256 initialLock;\n        uint256 lockedToken;\n        uint256 remainedToken;\n        uint256 monthCount;\n    }\n\n    struct TValues {\n        uint256 tTransferAmount;\n        uint256 tCommunityCharge;\n        uint256 tEcoSysFee;\n        uint256 tSurcharge1;\n        uint256 tSurcharge2;\n        uint256 tSurcharge3;\n    }\n\n    struct MValues {\n        uint256 rAmount;\n        uint256 rTransferAmount;\n        uint256 rCommunityCharge;\n        uint256 tTransferAmount;\n        uint256 tCommunityCharge;\n        uint256 tEcoSysFee;\n        uint256 tSurcharge1;\n        uint256 tSurcharge2;\n        uint256 tSurcharge3;\n    }\n\n    constructor() {\n        _rOwned[_msgSender()] = _rTotal;\n\n        //exclude owner and this contract from fees\n        _isExcludedFromCommunity_charge[owner()] = true;\n        _isExcludedFromCommunity_charge[address(this)] = true;\n\n        _isExcludedFromEcoSysFee[owner()] = true;\n        _isExcludedFromEcoSysFee[address(this)] = true;\n\n        _isExcludedFromSurcharge1[owner()] = true;\n        _isExcludedFromSurcharge1[address(this)] = true;\n\n        _isExcludedFromSurcharge2[owner()] = true;\n        _isExcludedFromSurcharge2[address(this)] = true;\n\n        _isExcludedFromSurcharge3[owner()] = true;\n        _isExcludedFromSurcharge3[address(this)] = true;\n\n        _cap = _tTotal;\n    }\n\n    /**\n     * @dev gives total Supply\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _tTotal;\n    }\n\n    /**\n     * @dev gives balance of an account\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        if (_isExcludedFromReward[account]) return _tOwned[account];\n        return tokenFromReflection(_rOwned[account]);\n    }\n\n    /**\n     * @dev transfer Fund\n     */\n\n    function transfer(address recipient, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n\n    function allowance(address ownerAccount, address spender)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return _allowances[ownerAccount][spender];\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     */\n\n    function approve(address spender, uint256 amount)\n        external\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev increases allowance\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev decreases allowance\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        external\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"BEP20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n// SWC-119-Shadowing State Variables: L512 - L521\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        require(owner != address(0), \"BEP20: approve from the zero address\");\n        require(spender != address(0), \"BEP20: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /** @dev Burns a specific amount of tokens.\n     * @param value The amount of lowest token units to be burned.\n     */\n    function burn(uint256 value) external onlyOwner {\n        require(value > 0, \"BEP20: burn amount not valid\");\n        require(\n            value <= balanceOf(msg.sender),\n            \"BEP20: burn amount exceeds balance\"\n        );\n        _tTotal = _tTotal.sub(value);\n        emit Burn(msg.sender, value);\n    }\n\n    /** @dev Mint a specific amount of tokens.\n     * @param value The amount of lowest token units to be mint.\n     */\n    function mint(uint256 value) external onlyOwner {\n        require(value > 0, \"BEP20: mint amount not valid\");\n        require(totalSupply() + value <= _cap, \"BEP20Capped: cap exceeded\");\n        _tTotal = _tTotal.add(value);\n        emit Mint(msg.sender, value);\n    }\n\n    /**\n     * @dev Set charges of the FidoMeta Ecosystem that includes, CommunityCharge,EcoSysFee,Surcharge1,Surcharge2,Surcharge3\n     * community_charge : charges that deduct from the transaction and distributed to the community\n     * ecoSysFee : this fee will be deducted and go to Fidometa ecosystem wallet\n     * surcharge1,surcharge2,surcharge3 : these are the placeholder that can be used to provide optional charges for fidometa central bank ecosystem.\n     * Can only be called by the current owner.\n     */\n\n// SWC-135-Code With No Effects: L555 - L587\n    function setCharges(\n        uint256 community_charge,\n        uint256 ecoSysFee,\n        uint256 surcharge1,\n        uint256 surcharge2,\n        uint256 surcharge3\n    ) external onlyOwner {\n        require(\n            community_charge <= (100 * 10**uint256(decimals)),\n            \"Community Charge % should be less than equal to 100%\"\n        );\n        require(\n            ecoSysFee <= (100 * 10**uint256(decimals)),\n            \"EcoSysFee % should be less than equal to 100%\"\n        );\n        require(\n            surcharge1 <= (100 * 10**uint256(decimals)),\n            \"surcharge1 % should be less than equal to 100%\"\n        );\n        require(\n            surcharge2 <= (100 * 10**uint256(decimals)),\n            \"surcharge2 % should be less than equal to 100%\"\n        );\n        require(\n            surcharge3 <= (100 * 10**uint256(decimals)),\n            \"surcharge3 % should be less than equal to 100%\"\n        );\n        _community_charge = community_charge;\n        _ecoSysFee = ecoSysFee;\n        _surcharge1 = surcharge1;\n        _surcharge2 = surcharge2;\n        _surcharge3 = surcharge3;\n    }\n\n    /**\n     * @dev Set service wallet includes ecoSysWallet,surcharge_1_wallet,surcharge_2_wallet,surcharge_3_wallet\n     * ecoSysWallet: where ecoSysFee is to be deposited\n     * surcharge_1_wallet, surcharge_2_wallet, surcharge_3_wallet is where the surcahrge1,surcahrge2,surcahrge3 is to be deposited\n     * these service wallet should be excluded from all charges including EcoSysFee,Community_charge,surcharge1,surcharge2,surcharge3 and reward\n     * Can only be called by the current owner.\n     */\n\n    function setServiceWallet(\n        address ecoSysWallet,\n        address surcharge_1_wallet,\n        address surcharge_2_wallet,\n        address surcharge_3_wallet\n    ) external onlyOwner {\n        require(\n            ecoSysWallet != address(0),\n            \"Ecosystem wallet wallet is not valid\"\n        );\n\n        //add the new service wallet\n        _ecoSysWallet = ecoSysWallet;\n        _surcharge_1_Wallet = surcharge_1_wallet;\n        _surcharge_2_Wallet = surcharge_2_wallet;\n        _surcharge_3_Wallet = surcharge_3_wallet;\n\n        //exclude _ecoSysWallet  from charges\n        excludeFromCharges(_ecoSysWallet, true, true, true, true, true);\n        excludeFromCharges(_surcharge_1_Wallet, true, true, true, true, true);\n        excludeFromCharges(_surcharge_2_Wallet, true, true, true, true, true);\n        excludeFromCharges(_surcharge_3_Wallet, true, true, true, true, true);\n\n        _isExcludedFromReward[_ecoSysWallet] = true;\n        _isExcludedFromReward[_surcharge_1_Wallet] = true;\n        _isExcludedFromReward[_surcharge_2_Wallet] = true;\n        _isExcludedFromReward[_surcharge_3_Wallet] = true;\n    }\n\n    /**\n     * @dev tokenFromReflection\n     */\n    function tokenFromReflection(uint256 rAmount)\n        private\n        view\n        returns (uint256)\n    {\n        require(\n            rAmount <= _rTotal,\n            \"Amount must be less than total reflections\"\n        );\n        uint256 currentRate = _getRate();\n        return rAmount.div(currentRate);\n    }\n\n    /**\n     *  @dev  include or exclude an account from charges,\n     *  pass true/false\n     *  true means excluded and false means included\n     */\n    function excludeFromCharges(\n        address account,\n        bool communityCharge,\n        bool ecoSysFee,\n        bool surcharge1,\n        bool surcharge2,\n        bool surcharge3\n    ) public onlyOwner {\n        _isExcludedFromCommunity_charge[account] = communityCharge;\n        _isExcludedFromEcoSysFee[account] = ecoSysFee;\n        _isExcludedFromSurcharge1[account] = surcharge1;\n        _isExcludedFromSurcharge2[account] = surcharge2;\n        _isExcludedFromSurcharge3[account] = surcharge3;\n    }\n\n    //exclude an address from getting community reward\n    function excludeFromReward(address account) public onlyOwner {\n        require(!_isExcludedFromReward[account], \"Account is already excluded\");\n        if (_rOwned[account] > 0) {\n            _tOwned[account] = tokenFromReflection(_rOwned[account]);\n        }\n        _isExcludedFromReward[account] = true;\n        _excluded.push(account);\n    }\n\n    /**\n     *  @dev it set the maximum amount of token an address can tranfer at once\n     */\n    function setMaxTxPercent(uint256 maxTxPercent) external onlyOwner {\n        _maxTxAmount = _tTotal.mul(maxTxPercent).div(10**2);\n    }\n\n    /**\n     * @dev  reflection of fee on each transfer\n     */\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\n        _rTotal = _rTotal.sub(rFee);\n        _tCommunityChargeTotal = _tCommunityChargeTotal.add(tFee);\n    }\n\n    function _getValues(uint256 tAmount) private view returns (MValues memory) {\n        uint256 currentRate = _getRate();\n        TValues memory value = _getTValues(tAmount);\n        (\n            uint256 rAmount,\n            uint256 rTransferAmount,\n            uint256 rCommunityCharge\n        ) = _getRValues(tAmount, value.tCommunityCharge, currentRate);\n        uint256 rEcoSysFee = value.tEcoSysFee.mul(currentRate);\n        uint256 rSurcharge1 = value.tSurcharge1.mul(currentRate);\n        uint256 rSurcharge2 = value.tSurcharge2.mul(currentRate);\n        uint256 rSurcharge3 = value.tSurcharge3.mul(currentRate);\n        rTransferAmount = rTransferAmount\n            .sub(rEcoSysFee)\n            .sub(rSurcharge1)\n            .sub(rSurcharge2)\n            .sub(rSurcharge3);\n        MValues memory mValues = MValues({\n            rAmount: rAmount,\n            rTransferAmount: rTransferAmount,\n            rCommunityCharge: rCommunityCharge,\n            tTransferAmount: value.tTransferAmount,\n            tCommunityCharge: value.tCommunityCharge,\n            tEcoSysFee: value.tEcoSysFee,\n            tSurcharge1: value.tSurcharge1,\n            tSurcharge2: value.tSurcharge2,\n            tSurcharge3: value.tSurcharge3\n        });\n        return (mValues);\n    }\n\n    function _getTValues(uint256 tAmount)\n        private\n        view\n        returns (TValues memory)\n    {\n        uint256 tCommunityCharge = tAmount.mul(_community_charge).div(10**11);\n        uint256 tEcoSysFee = tAmount.mul(_ecoSysFee).div(10**11);\n        uint256 tSurcharge1 = tAmount.mul(_surcharge1).div(10**11);\n        uint256 tSurcharge2 = tAmount.mul(_surcharge2).div(10**11);\n        uint256 tSurcharge3 = tAmount.mul(_surcharge3).div(10**11);\n        uint256 tTransferAmountEco = tAmount.sub(tCommunityCharge).sub(\n            tEcoSysFee\n        );\n        uint256 tTransferAmount = tTransferAmountEco\n            .sub(tSurcharge1)\n            .sub(tSurcharge2)\n            .sub(tSurcharge3);\n        TValues memory tvalue = TValues({\n            tTransferAmount: tTransferAmount,\n            tCommunityCharge: tCommunityCharge,\n            tEcoSysFee: tEcoSysFee,\n            tSurcharge1: tSurcharge1,\n            tSurcharge2: tSurcharge2,\n            tSurcharge3: tSurcharge3\n        });\n        return (tvalue);\n    }\n\n    function _getRValues(\n        uint256 tAmount,\n        uint256 tFee,\n        uint256 currentRate\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        uint256 rAmount = tAmount.mul(currentRate);\n        uint256 rFee = tFee.mul(currentRate);\n        uint256 rTransferAmount = rAmount.sub(rFee);\n        return (rAmount, rTransferAmount, rFee);\n    }\n\n    function _getRate() private view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply.div(tSupply);\n    }\n\n    function _getCurrentSupply() private view returns (uint256, uint256) {\n        uint256 rSupply = _rTotal;\n        uint256 tSupply = _tTotal;\n        uint cacheLength = _excluded.length;\n        // SWC-128-DoS With Block Gas Limit: L772 - L779\n        for (uint256 i = 0; i < cacheLength; i++) {\n            if (\n                _rOwned[_excluded[i]] > rSupply ||\n                _tOwned[_excluded[i]] > tSupply\n            ) return (_rTotal, _tTotal);\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\n        }\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\n        return (rSupply, tSupply);\n    }\n\n    /**\n     * @dev take charges as per percentage\n     */\n    // SWC-135-Code With No Effects: L788 - L832\n    function takeCharges(\n        uint256 tEcoSys,\n        uint256 tSurcharge1,\n        uint256 tSurcharge2,\n        uint256 tSurcharge3\n    ) private {\n        uint256 currentRate = _getRate();\n        if (tEcoSys > 0) {\n            uint256 rEcosys = tEcoSys.mul(currentRate);\n            _rOwned[_ecoSysWallet] = _rOwned[_ecoSysWallet].add(rEcosys);\n            if (_isExcludedFromEcoSysFee[_ecoSysWallet])\n                _tOwned[_ecoSysWallet] = _tOwned[_ecoSysWallet].add(tEcoSys);\n        }\n        if (tSurcharge1 > 0) {\n            uint256 rSurcharge1 = tSurcharge1.mul(currentRate);\n            _rOwned[_surcharge_1_Wallet] = _rOwned[_surcharge_1_Wallet].add(\n                rSurcharge1\n            );\n            if (_isExcludedFromSurcharge1[_surcharge_1_Wallet])\n                _tOwned[_surcharge_1_Wallet] = _tOwned[_surcharge_1_Wallet].add(\n                    tSurcharge1\n                );\n        }\n        if (tSurcharge2 > 0) {\n            uint256 rSurcharge2 = tSurcharge2.mul(currentRate);\n            _rOwned[_surcharge_2_Wallet] = _rOwned[_surcharge_2_Wallet].add(\n                rSurcharge2\n            );\n            if (_isExcludedFromSurcharge1[_surcharge_2_Wallet])\n                _tOwned[_surcharge_2_Wallet] = _tOwned[_surcharge_2_Wallet].add(\n                    tSurcharge2\n                );\n        }\n        if (tSurcharge3 > 0) {\n            uint256 rSurcharge3 = tSurcharge3.mul(currentRate);\n            _rOwned[_surcharge_3_Wallet] = _rOwned[_surcharge_3_Wallet].add(\n                rSurcharge3\n            );\n            if (_isExcludedFromSurcharge3[_surcharge_3_Wallet])\n                _tOwned[_surcharge_3_Wallet] = _tOwned[_surcharge_3_Wallet].add(\n                    tSurcharge3\n                );\n        }\n    }\n\n    /**\n     * @dev Transfers the tokens from an owner's account to the receiver account,\n     * but only if the transaction initiator has sufficient allowance that\n     * has been previously approved by the owner to the transaction initiator\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"BEP20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        require(from != address(0), \"BEP20: transfer from the zero address\");\n        require(to != address(0), \"BEP20: transfer to the zero address\");\n        require(from != to, \"Invalid target\");\n        if (from != owner() && to != owner())\n            require(\n                amount <= _maxTxAmount,\n                \"Transfer amount exceeds the maxTxAmount.\"\n            );\n\n        // it checks if an account is serving vesting period,\n        //  if yes, it calculates how much token is withdrawable along with released token\n        //  if amount crosses the withdrawable return an error\n        if (locks[from].lockedToken > 0) {\n            uint256 withdrawable = balanceOf(from) - locks[from].remainedToken;\n            require(\n                amount <= withdrawable,\n                \"Not enough Unlocked token Available\"\n            );\n        }\n\n        //indicates if fee should be deducted from transfer\n        bool takeCommunityCharge = true;\n        bool takeEcosysFee = true;\n        bool takeSurcharge1 = true;\n        bool takeSurcharge2 = true;\n        bool takeSurcharge3 = true;\n\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromCommunity_charge[from]) {\n            takeCommunityCharge = false;\n        }\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromEcoSysFee[from]) {\n            takeEcosysFee = false;\n        }\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromSurcharge1[from]) {\n            takeSurcharge1 = false;\n        }\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromSurcharge2[from]) {\n            takeSurcharge2 = false;\n        }\n        //if any account belongs to _isExcludedFromFee account then remove the fee\n        if (_isExcludedFromSurcharge3[from]) {\n            takeSurcharge3 = false;\n        }\n\n        _tokenTransfer(\n            from,\n            to,\n            amount,\n            takeCommunityCharge,\n            takeEcosysFee,\n            takeSurcharge1,\n            takeSurcharge2,\n            takeSurcharge3\n        );\n    }\n\n    /**\n     * @dev transfer token\n     */\n    function _tokenTransfer(\n        address sender,\n        address recipient,\n        uint256 amount,\n        bool takeCommunityCharge,\n        bool takeEcosysFee,\n        bool takeSurcharge1,\n        bool takeSurcharge2,\n        bool takeSurcharge3\n    ) private {\n        if (!takeCommunityCharge) {\n            _previousCommunityCharge = _community_charge;\n            _community_charge = 0;\n        }\n\n        if (!takeEcosysFee) {\n            _previousEcoSysFee = _ecoSysFee;\n            _ecoSysFee = 0;\n        }\n\n        if (!takeSurcharge1) {\n            _previousSurcharge1 = _surcharge1;\n            _surcharge1 = 0;\n        }\n\n        if (!takeSurcharge2) {\n            _previousSurcharge2 = _surcharge2;\n            _surcharge2 = 0;\n        }\n\n        if (!takeSurcharge3) {\n            _previousSurcharge3 = _surcharge3;\n            _surcharge3 = 0;\n        }\n\n        if (\n            _isExcludedFromReward[sender] && !_isExcludedFromReward[recipient]\n        ) {\n            _transferFromExcluded(sender, recipient, amount);\n        } else if (\n            !_isExcludedFromReward[sender] && _isExcludedFromReward[recipient]\n        ) {\n            _transferToExcluded(sender, recipient, amount);\n        } else if (\n            !_isExcludedFromReward[sender] && !_isExcludedFromReward[recipient]\n        ) {\n            _transferStandard(sender, recipient, amount);\n        } else if (\n            _isExcludedFromReward[sender] && _isExcludedFromReward[recipient]\n        ) {\n            _transferBothExcluded(sender, recipient, amount);\n            // SWC-135-Code With No Effects: L977 - L979\n        } else {\n            _transferStandard(sender, recipient, amount);\n        }\n\n        if (!takeCommunityCharge) _community_charge = _previousCommunityCharge;\n        if (!takeEcosysFee) _ecoSysFee = _previousEcoSysFee;\n        if (!takeSurcharge1) _surcharge1 = _previousSurcharge1;\n        if (!takeSurcharge2) _surcharge2 = _previousSurcharge2;\n        if (!takeSurcharge3) _surcharge3 = _previousSurcharge3;\n    }\n\n    /**\n     * @dev it unlocks token from vesting period ,\n     * locked token for initially for initial days than unlock 20% of locked token every month\n     */\n\n    function unlock(address target_) external {\n        require(target_ != address(0), \"Invalid target\");\n        require(_msgSender() == target_, \"Invalid target\");\n        uint256 startTime = locks[target_].startTime;\n        uint256 lockedToken = locks[target_].lockedToken;\n        uint256 remainedToken = locks[target_].remainedToken;\n        uint256 monthCount = locks[target_].monthCount;\n        uint256 initialLock = locks[target_].initialLock;\n        require(remainedToken != 0, \"All tokens are unlocked\");\n\n        require(\n            block.timestamp > startTime + (initialLock * 1 days),\n            \"UnLocking period is not opened\"\n        );\n        // SWC-101-Integer Overflow and Underflow: L1004\n        uint256 timePassed = block.timestamp -\n            (startTime + (initialLock * 1 days));\n\n        uint256 monthNumber = (uint256(timePassed) + (uint256(30 days) - 1)) /\n            uint256(30 days);\n\n        uint256 remainedMonth = monthNumber - monthCount;\n\n        if (remainedMonth > 5) remainedMonth = 5;\n        require(remainedMonth > 0, \"Releasable token till now is released\");\n\n        uint256 receivableToken = (lockedToken * (remainedMonth * 20)) / 100;\n\n        locks[target_].monthCount += remainedMonth;\n        locks[target_].remainedToken -= receivableToken;\n\n        if (locks[target_].remainedToken == 0) {\n            delete locks[target_];\n        }\n    }\n\n    /** @dev Transfer with lock\n     * @param recipient The recipient address.\n     * @param tAmount Amount that has to be locked\n     * @param initialLock duration in days for locking\n     */\n\n    function transferWithLock(\n        address recipient,\n        uint256 tAmount,\n        uint256 initialLock\n    ) external onlyOwner {\n        require(recipient != address(0), \"Invalid target\");\n        // SWC-135-Code With No Effects: L1040 - L1043\n        require(\n            locks[recipient].lockedToken == 0,\n            \"This address is already in vesting period\"\n        );\n        require(\n            initialLock >= 0,\n            \"timeindays should be greater than or equal to 0\"\n        );\n        _transfer(_msgSender(), recipient, tAmount);\n        locks[recipient] = LockDetails(\n            block.timestamp,\n            initialLock,\n            tAmount,\n            tAmount,\n            0\n        );\n    }\n\n// SWC-135-Code With No Effects: L1060 - L1070\n    function _transferFromExcluded(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        MValues memory mvalues = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(mvalues.rAmount);\n        _doTransfer(mvalues, sender, recipient);\n    }\n\n    function _transferToExcluded(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        MValues memory mvalues = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(mvalues.rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(mvalues.tTransferAmount);\n        _doTransfer(mvalues, sender, recipient);\n    }\n\n    function _transferStandard(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        MValues memory mvalues = _getValues(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(mvalues.rAmount);\n        _doTransfer(mvalues, sender, recipient);\n    }\n\n    function _transferBothExcluded(\n        address sender,\n        address recipient,\n        uint256 tAmount\n    ) private {\n        MValues memory mvalues = _getValues(tAmount);\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\n        _rOwned[sender] = _rOwned[sender].sub(mvalues.rAmount);\n        _tOwned[recipient] = _tOwned[recipient].add(mvalues.tTransferAmount);\n        _doTransfer(mvalues, sender, recipient);\n    }\n\n    function _doTransfer(\n        MValues memory mvalues,\n        address sender,\n        address recipient\n    ) private {\n        _rOwned[recipient] = _rOwned[recipient].add(mvalues.rTransferAmount);\n        takeCharges(\n            mvalues.tEcoSysFee,\n            mvalues.tSurcharge1,\n            mvalues.tSurcharge2,\n            mvalues.tSurcharge3\n        );\n        _reflectFee(mvalues.rCommunityCharge, mvalues.tCommunityCharge);\n        emit Transfer(sender, recipient, mvalues.tTransferAmount);\n    }\n}\n",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Fidometa-V1/Smart_Contract-66f43e8644a20ed2ebbc4db94d6b2dcc797ac1c7/FidoMeta.sol",
        "vulnerability": "SOLIDITY_GAS_LIMIT_IN_LOOPS",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The `_getCurrentSupply` function contains a loop that iterates over the `_excluded` array, which could grow indefinitely, leading to potential gas limit issues."
    }
]