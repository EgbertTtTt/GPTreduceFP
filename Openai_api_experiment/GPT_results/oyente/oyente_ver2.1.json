[
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: No\nReason: The functions check for overflow and underflow conditions using inline assembly, which enhances precision and security by incorporating specific conditions to handle such exceptions."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/BasicMathLib/BasicMathLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function \"minus\" lacks a proper check to prevent `a` from being smaller than `b`, which can lead to an integer underflow."
    },
    {
        "code_segment": "library Array256Lib {\n\n  \n  \n  \n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\n    assembly {\n      mstore(0x60,self_slot)\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\n      }\n    }\n  }\n\n  \n  \n  \n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\n    assembly {\n      mstore(0x60,self_slot)\n      maxValue := sload(sha3(0x60,0x20))\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\n        case 1 {\n          maxValue := sload(add(sha3(0x60,0x20),i))\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\n    assembly {\n      mstore(0x60,self_slot)\n      minValue := sload(sha3(0x60,0x20))\n\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\n        case 0 {\n          minValue := sload(add(sha3(0x60,0x20),i))\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\n           public\n           view\n           returns(bool found, uint256 index) {\n    assembly{\n      mstore(0x60,self_slot)\n      switch isSorted\n      case 1 {\n        let high := sub(sload(self_slot),1)\n        let mid := 0\n        let low := 0\n        for { } iszero(gt(low, high)) { } {\n          mid := div(add(low,high),2)\n\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\n          case 1 {\n             low := add(mid,1)\n          }\n          case 0 {\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\n            case 1 {\n              high := sub(mid,1)\n            }\n            case 0 {\n              found := 1\n              index := mid\n              low := add(high,1)\n            }\n          }\n        }\n      }\n      case 0 {\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\n          case 1 {\n            found := 1\n            index := low\n            low := sload(self_slot)\n          }\n        }\n      }\n    }\n  }\n\n  \n  \n  \n  function getParentI(uint256 index) private pure returns (uint256 pI) {\n    uint256 i = index - 1;\n    pI = i/2;\n  }\n\n  \n  \n  \n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\n    uint256 i = index * 2;\n    lcI = i + 1;\n  }\n\n  \n  \n  function heapSort(uint256[] storage self) public {\n    uint256 end = self.length - 1;\n    uint256 start = getParentI(end);\n    uint256 root = start;\n    uint256 lChild;\n    uint256 rChild;\n    uint256 swap;\n    uint256 temp;\n    while(start >= 0){\n      root = start;\n      lChild = getLeftChildI(start);\n      while(lChild <= end){\n        rChild = lChild + 1;\n        swap = root;\n        if(self[swap] < self[lChild])\n          swap = lChild;\n        if((rChild <= end) && (self[swap]<self[rChild]))\n          swap = rChild;\n        if(swap == root)\n          lChild = end+1;\n        else {\n          temp = self[swap];\n          self[swap] = self[root];\n          self[root] = temp;\n          root = swap;\n          lChild = getLeftChildI(root);\n        }\n      }\n      if(start == 0)\n        break;\n      else\n        start = start - 1;\n    }\n    while(end > 0){\n      temp = self[end];\n      self[end] = self[0];\n      self[0] = temp;\n      end = end - 1;\n      root = 0;\n      lChild = getLeftChildI(0);\n      while(lChild <= end){\n        rChild = lChild + 1;\n        swap = root;\n        if(self[swap] < self[lChild])\n          swap = lChild;\n        if((rChild <= end) && (self[swap]<self[rChild]))\n          swap = rChild;\n        if(swap == root)\n          lChild = end + 1;\n        else {\n          temp = self[swap];\n          self[swap] = self[root];\n          self[root] = temp;\n          root = swap;\n          lChild = getLeftChildI(root);\n        }\n      }\n    }\n  }\n\n  \n  \n  function uniq(uint256[] storage self) public returns (uint256 length) {\n    bool contains;\n    uint256 index;\n\n    for (uint256 i = 0; i < self.length; i++) {\n      (contains, index) = indexOf(self, self[i], false);\n\n      if (i > index) {\n        for (uint256 j = i; j < self.length - 1; j++){\n          self[j] = self[j + 1];\n        }\n\n        delete self[self.length - 1];\n        self.length--;\n        i--;\n      }\n    }\n\n    length = self.length;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/ArrayUtilsLib/Array256Lib.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The function `getParentI` performs a subtraction operation (`index - 1`) without checking if `index` is greater than 0, leading to a potential underflow."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The smart contract uses assembly code to handle arithmetic operations, and it includes checks to prevent integer overflow and underflow."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The \"minus\" function includes checks to ensure that a subtraction resulting in a negative number does not occur, which prevents integer underflow."
    },
    {
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath operations from the BasicMathLib library for uint256 calculations, which prevents integer overflow vulnerabilities.\n\nAnswer: No\nReason: The code uses SafeMath operations from the BasicMathLib library for uint256 calculations, which prevents integer overflow vulnerabilities.\n\nAnswer: No\nReason: The code uses SafeMath operations from the BasicMathLib library for uint256 calculations, which prevents integer overflow vulnerabilities.\n\nAnswer: No\nReason: The code uses SafeMath operations from the BasicMathLib library for uint256 calculations, which prevents integer overflow vulnerabilities.\n\nAnswer: No\nReason: The code uses SafeMath operations from the BasicMathLib library for uint256 calculations, which prevents integer overflow vulnerabilities."
    },
    {
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The use of the \"now\" keyword in the functions (`init`, `crowdsaleActive`, `crowdsaleEnded`, `validPurchase`, `setTokens`) makes the contract vulnerable to timestamp manipulation by miners."
    },
    {
        "code_segment": "library CrowdsaleLib {\n  using BasicMathLib for uint256;\n\n  struct CrowdsaleStorage {\n  \taddress owner;     //owner of the crowdsale\n\n  \tuint256 tokensPerEth;  //number of tokens received per ether\n  \tuint256 startTime; //ICO start time, timestamp\n  \tuint256 endTime; //ICO end time, timestamp automatically calculated\n    uint256 ownerBalance; //owner wei Balance\n    uint256 startingTokenBalance; //initial amount of tokens for sale\n    uint256[] milestoneTimes; //Array of timestamps when token price and address cap changes\n    uint8 currentMilestone; //Pointer to the current milestone\n    uint8 percentBurn; //percentage of extra tokens to burn\n    bool tokensSet; //true if tokens have been prepared for crowdsale\n\n    //Maps timestamp to token price and address purchase cap starting at that time\n    mapping (uint256 => uint256[2]) saleData;\n\n    //shows how much wei an address has contributed\n  \tmapping (address => uint256) hasContributed;\n\n    //For token withdraw function, maps a user address to the amount of tokens they can withdraw\n  \tmapping (address => uint256) withdrawTokensMap;\n\n    // any leftover wei that buyers contributed that didn't add up to a whole token amount\n    mapping (address => uint256) leftoverWei;\n\n  \tCrowdsaleToken token; //token being sold\n  }\n\n  // Indicates when an address has withdrawn their supply of tokens\n  event LogTokensWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Indicates when an address has withdrawn their supply of extra wei\n  event LogWeiWithdrawn(address indexed _bidder, uint256 Amount);\n\n  // Logs when owner has pulled eth\n  event LogOwnerEthWithdrawn(address indexed owner, uint256 amount, string Msg);\n\n  // Generic Notice message that includes and address and number\n  event LogNoticeMsg(address _buyer, uint256 value, string Msg);\n\n  // Indicates when an error has occurred in the execution of a function\n  event LogErrorMsg(uint256 amount, string Msg);\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  function init(CrowdsaleStorage storage self,\n                address _owner,\n                uint256[] _saleData,\n                uint256 _endTime,\n                uint8 _percentBurn,\n                CrowdsaleToken _token)\n                public\n  {\n  \trequire(self.owner == 0);\n    require(_saleData.length > 0);\n    require((_saleData.length%3) == 0); // ensure saleData is 3-item sets\n    require(_saleData[0] > (now + 2 hours));\n    require(_endTime > _saleData[0]);\n    require(_owner > 0);\n    require(_percentBurn <= 100);\n    self.owner = _owner;\n    self.startTime = _saleData[0];\n    self.endTime = _endTime;\n    self.token = _token;\n    self.percentBurn = _percentBurn;\n\n    uint256 _tempTime;\n    for(uint256 i = 0; i < _saleData.length; i += 3){\n      require(_saleData[i] > _tempTime);\n      require(_saleData[i + 1] > 0);\n      require((_saleData[i + 2] == 0) || (_saleData[i + 2] >= 100));\n      self.milestoneTimes.push(_saleData[i]);\n      self.saleData[_saleData[i]][0] = _saleData[i + 1];\n      self.saleData[_saleData[i]][1] = _saleData[i + 2];\n      _tempTime = _saleData[i];\n    }\n    changeTokenPrice(self, _saleData[1]);\n  }\n\n  \n  \n  \n  function crowdsaleActive(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn (now >= self.startTime && now <= self.endTime);\n  }\n\n  \n  \n  \n  function crowdsaleEnded(CrowdsaleStorage storage self) public view returns (bool) {\n  \treturn now > self.endTime;\n  }\n\n  \n  \n  \n  function validPurchase(CrowdsaleStorage storage self) internal returns (bool) {\n    bool nonZeroPurchase = msg.value != 0;\n    if (crowdsaleActive(self) && nonZeroPurchase) {\n      return true;\n    } else {\n      LogErrorMsg(msg.value, \"Invalid Purchase! Check start time and amount of ether.\");\n      return false;\n    }\n  }\n\n  \n  \n  \n  function withdrawTokens(CrowdsaleStorage storage self) public returns (bool) {\n    bool ok;\n\n    if (self.withdrawTokensMap[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no tokens to withdraw!\");\n      return false;\n    }\n\n    if (msg.sender == self.owner) {\n      if(!crowdsaleEnded(self)){\n        LogErrorMsg(0, \"Owner cannot withdraw extra tokens until after the sale!\");\n        return false;\n      } else {\n        if(self.percentBurn > 0){\n          uint256 _burnAmount = (self.withdrawTokensMap[msg.sender] * self.percentBurn)/100;\n          self.withdrawTokensMap[msg.sender] = self.withdrawTokensMap[msg.sender] - _burnAmount;\n          ok = self.token.burnToken(_burnAmount);\n          require(ok);\n        }\n      }\n    }\n\n    var total = self.withdrawTokensMap[msg.sender];\n    self.withdrawTokensMap[msg.sender] = 0;\n    ok = self.token.transfer(msg.sender, total);\n    require(ok);\n    LogTokensWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawLeftoverWei(CrowdsaleStorage storage self) public returns (bool) {\n    if (self.leftoverWei[msg.sender] == 0) {\n      LogErrorMsg(0, \"Sender has no extra wei to withdraw!\");\n      return false;\n    }\n\n    var total = self.leftoverWei[msg.sender];\n    self.leftoverWei[msg.sender] = 0;\n    msg.sender.transfer(total);\n    LogWeiWithdrawn(msg.sender, total);\n    return true;\n  }\n\n  \n  \n  \n  function withdrawOwnerEth(CrowdsaleStorage storage self) public returns (bool) {\n    if ((!crowdsaleEnded(self)) && (self.token.balanceOf(this)>0)) {\n      LogErrorMsg(0, \"Cannot withdraw owner ether until after the sale!\");\n      return false;\n    }\n\n    require(msg.sender == self.owner);\n    require(self.ownerBalance > 0);\n\n    uint256 amount = self.ownerBalance;\n    self.ownerBalance = 0;\n    self.owner.transfer(amount);\n    LogOwnerEthWithdrawn(msg.sender,amount,\"Crowdsale owner has withdrawn all funds!\");\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeTokenPrice(CrowdsaleStorage storage self,\n                            uint256 _tokensPerEth)\n                            internal\n                            returns (bool)\n  {\n  \trequire(_tokensPerEth > 0);\n\n    self.tokensPerEth = _tokensPerEth;\n\n    return true;\n  }\n\n  \n  \n  \n  function setTokens(CrowdsaleStorage storage self) public returns (bool) {\n    require(msg.sender == self.owner);\n    require(!self.tokensSet);\n    require(now < self.endTime);\n\n    uint256 _tokenBalance;\n\n    _tokenBalance = self.token.balanceOf(this);\n    self.withdrawTokensMap[msg.sender] = _tokenBalance;\n    self.startingTokenBalance = _tokenBalance;\n    self.tokensSet = true;\n\n    return true;\n  }\n\n  \n  \n  \n  \n  function getSaleData(CrowdsaleStorage storage self, uint256 timestamp)\n                       public\n                       view\n                       returns (uint256[3])\n  {\n    uint256[3] memory _thisData;\n    uint256 index;\n\n    while((index < self.milestoneTimes.length) && (self.milestoneTimes[index] < timestamp)) {\n      index++;\n    }\n    if(index == 0)\n      index++;\n\n    _thisData[0] = self.milestoneTimes[index - 1];\n    _thisData[1] = self.saleData[_thisData[0]][0];\n    _thisData[2] = self.saleData[_thisData[0]][1];\n    return _thisData;\n  }\n\n  \n  \n  \n  function getTokensSold(CrowdsaleStorage storage self) public view returns (uint256) {\n    return self.startingTokenBalance - self.withdrawTokensMap[self.owner];\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not involve any function that explicitly depends on transaction ordering which could be exploited to gain an advantage based on the order of execution."
    },
    {
        "code_segment": "contract CrowdsaleToken {\n  using TokenLib for TokenLib.TokenStorage;\n\n  TokenLib.TokenStorage public token;\n\n  function CrowdsaleToken(address owner,\n                          string name,\n                          string symbol,\n                          uint8 decimals,\n                          uint256 initialSupply,\n                          bool allowMinting) public\n  {\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\n  }\n\n  function name() public view returns (string) {\n    return token.name;\n  }\n\n  function symbol() public view returns (string) {\n    return token.symbol;\n  }\n\n  function decimals() public view returns (uint8) {\n    return token.decimals;\n  }\n\n  function totalSupply() public view returns (uint256) {\n    return token.totalSupply;\n  }\n\n  function initialSupply() public view returns (uint256) {\n    return token.initialSupply;\n  }\n\n  function balanceOf(address who) public view returns (uint256) {\n    return token.balanceOf(who);\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256) {\n    return token.allowance(owner, spender);\n  }\n\n  function transfer(address to, uint value) public returns (bool ok) {\n    return token.transfer(to, value);\n  }\n\n  function transferFrom(address from, address to, uint value) public returns (bool ok) {\n    return token.transferFrom(from, to, value);\n  }\n\n  function approve(address spender, uint value) public returns (bool ok) {\n    return token.approve(spender, value);\n  }\n\n  function approveChange(address spender, uint256 valueChange, bool increase)\n                         public returns (bool ok)\n  {\n    return token.approveChange(spender, valueChange, increase);\n  }\n\n  function changeOwner(address newOwner) public returns (bool ok) {\n    return token.changeOwner(newOwner);\n  }\n\n  function mintToken(uint256 amount) public returns (bool ok) {\n    return token.mintToken(amount);\n  }\n\n  function closeMint() public returns (bool ok) {\n    return token.closeMint();\n  }\n\n  function burnToken(uint256 amount) public returns (bool ok) {\n    return token.burnToken(amount);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code depends on the TokenLib library for token operations, and there are no explicit arithmetic operations in this contract that can cause an integer underflow.\n\nAnswer: No\nReason: The code depends on the TokenLib library for token operations, and there are no explicit arithmetic operations in this contract that can cause an integer underflow.\n\nAnswer: No\nReason: The code depends on the TokenLib library for token operations, and there are no explicit arithmetic operations in this contract that can cause an integer underflow.\n\nAnswer: No\nReason: The code depends on the TokenLib library for token operations, and there are no explicit arithmetic operations in this contract that can cause an integer underflow.\n\nAnswer: No\nReason: The code depends on the TokenLib library for token operations, and there are no explicit arithmetic operations in this contract that can cause an integer underflow."
    },
    {
        "code_segment": "library TokenLib {\n  using BasicMathLib for uint256;\n\n  struct TokenStorage {\n    bool initialized;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    uint256 initialSupply;\n    address owner;\n    uint8 decimals;\n    bool stillMinting;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event OwnerChange(address from, address to);\n  event Burn(address indexed burner, uint256 value);\n  event MintingClosed(bool mintingClosed);\n\n  \n  \n  \n  \n  \n  \n  \n  function init(TokenStorage storage self,\n                address _owner,\n                string _name,\n                string _symbol,\n                uint8 _decimals,\n                uint256 _initial_supply,\n                bool _allowMinting)\n                public\n  {\n    require(!self.initialized);\n    self.initialized = true;\n    self.name = _name;\n    self.symbol = _symbol;\n    self.totalSupply = _initial_supply;\n    self.initialSupply = _initial_supply;\n    self.decimals = _decimals;\n    self.owner = _owner;\n    self.stillMinting = _allowMinting;\n    self.balances[_owner] = _initial_supply;\n  }\n\n  \n  \n  \n  \n  \n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    bool err;\n    uint256 balance;\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n    require(!err);\n    self.balances[msg.sender] = balance;\n    //It's not possible to overflow token supply\n    self.balances[_to] = self.balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  \n  function transferFrom(TokenStorage storage self,\n                        address _from,\n                        address _to,\n                        uint256 _value)\n                        public\n                        returns (bool)\n  {\n    var _allowance = self.allowed[_from][msg.sender];\n    bool err;\n    uint256 balanceOwner;\n    uint256 balanceSpender;\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n    require(!err);\n\n    (err,balanceSpender) = _allowance.minus(_value);\n    require(!err);\n\n    self.balances[_from] = balanceOwner;\n    self.allowed[_from][msg.sender] = balanceSpender;\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n    return self.balances[_owner];\n  }\n\n  \n  \n  \n  \n  \n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n    // must set to zero before changing approval amount in accordance with spec\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n    self.allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  function allowance(TokenStorage storage self, address _owner, address _spender)\n                     public\n                     view\n                     returns (uint256 remaining) {\n    return self.allowed[_owner][_spender];\n  }\n\n  \n  \n  \n  \n  \n  \n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n                          public returns (bool)\n  {\n    uint256 _newAllowed;\n    bool err;\n\n    if(_increase) {\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n      require(!err);\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n    } else {\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n        self.allowed[msg.sender][_spender] = 0;\n      } else {\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n        self.allowed[msg.sender][_spender] = _newAllowed;\n      }\n    }\n\n    Approval(msg.sender, _spender, _newAllowed);\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n    self.owner = _newOwner;\n    OwnerChange(msg.sender, _newOwner);\n    return true;\n  }\n\n  \n  \n  \n  \n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n    require((self.owner == msg.sender) && self.stillMinting);\n    uint256 _newAmount;\n    bool err;\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n    require(!err);\n\n    self.totalSupply =  _newAmount;\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n    Transfer(0x0, self.owner, _amount);\n    return true;\n  }\n\n  \n  \n  \n  function closeMint(TokenStorage storage self) public returns (bool) {\n    require(self.owner == msg.sender);\n\n    self.stillMinting = false;\n    MintingClosed(true);\n    return true;\n  }\n\n  \n  \n  \n  \n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n      uint256 _newBalance;\n      bool err;\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n      require(!err);\n\n      self.balances[msg.sender] = _newBalance;\n      self.totalSupply = self.totalSupply - _amount;\n      Burn(msg.sender, _amount);\n      Transfer(msg.sender, 0x0, _amount);\n      return true;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/IICOLib/truffle/contracts/InteractiveCrowdsaleLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: In the `transfer` function, there is a potential for integer overflow when adding `_value` to `self.balances[_to]` without checking for overflow."
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath functions for arithmetic operations, which prevents integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract Fee is Owned, Validating, StandardToken {\n\n  /* This notifies clients about the amount burnt */\n  event Burn(address indexed from, uint256 value);\n\n  string public name;                   //fancy name: eg Simon Bucks\n  uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n  string public symbol;                 //An identifier: eg SBX\n  uint256 public feeInCirculation;      //total fee in circulation\n  string public version = 'F0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n  address public minter;\n\n  modifier onlyMinter {\n    require(msg.sender == minter);\n    _;\n  }\n\n  \n  function Fee(\n  address[] _owners,\n  string _tokenName,\n  uint8 _decimalUnits,\n  string _tokenSymbol\n  )\n  public\n  notEmpty(_tokenName)\n  notEmpty(_tokenSymbol)\n  {\n    setOwners(_owners);\n    name = _tokenName;\n    decimals = _decimalUnits;\n    symbol = _tokenSymbol;\n  }\n\n  \n  \n  function setMinter(address _minter) external onlyOwner validAddress(_minter) {\n    minter = _minter;\n  }\n\n  \n  \n  function burnTokens(uint _value) public notZero(_value) {\n    require(balances[msg.sender] >= _value);\n\n    balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n    feeInCirculation = SafeMath.sub(feeInCirculation, _value);\n    Burn(msg.sender, _value);\n  }\n\n  \n  \n  \n  \n  function sendTokens(address _to, uint _value) public onlyMinter validAddress(_to) notZero(_value) {\n    balances[_to] = SafeMath.add(balances[_to], _value);\n    feeInCirculation = SafeMath.add(feeInCirculation, _value);\n    Transfer(msg.sender, _to, _value);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath library functions for arithmetic operations, which prevent integer underflows and overflows."
    },
    {
        "code_segment": "contract Owned {\n  event OwnerAddition(address indexed owner);\n\n  event OwnerRemoval(address indexed owner);\n\n  // owner address to enable admin functions\n  mapping (address => bool) public isOwner;\n\n  address[] public owners;\n\n  address public operator;\n\n  modifier onlyOwner {\n\n    require(isOwner[msg.sender]);\n    _;\n  }\n\n  modifier onlyOperator {\n    require(msg.sender == operator);\n    _;\n  }\n\n  function setOperator(address _operator) external onlyOwner {\n    require(_operator != address(0));\n    operator = _operator;\n  }\n\n  function removeOwner(address _owner) public onlyOwner {\n    require(owners.length > 1);\n    isOwner[_owner] = false;\n    for (uint i = 0; i < owners.length - 1; i++) {\n      if (owners[i] == _owner) {\n        owners[i] = owners[SafeMath.sub(owners.length, 1)];\n        break;\n      }\n    }\n    owners.length = SafeMath.sub(owners.length, 1);\n    OwnerRemoval(_owner);\n  }\n\n  function addOwner(address _owner) external onlyOwner {\n    require(_owner != address(0));\n    if(isOwner[_owner]) return;\n    isOwner[_owner] = true;\n    owners.push(_owner);\n    OwnerAddition(_owner);\n  }\n\n  function setOwners(address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++) {\n      require(_owners[i] != address(0));\n      isOwner[_owners[i]] = true;\n      OwnerAddition(_owners[i]);\n    }\n    owners = _owners;\n  }\n\n  function getOwners() public constant returns (address[])  {\n    return owners;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath for subtraction operations, which prevents integer overflow."
    },
    {
        "code_segment": "contract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Leverj/staking-e8716e4a11881fad181b5330206d8b0c27a58510/contracts/Fee.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: There is no check to prevent `balances[_to] += _value` from wrapping around if `balances[_to]` is close to the maximum uint256 value."
    },
    {
        "code_segment": "contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable {\n    uint256 public constant VERSION = 202;\n    string public constant VERSION_NAME = \"Basalt\";\n\n    uint256 private activeLoans = 0;\n    mapping(address => uint256) private lendersBalance;\n\n    function name() constant returns (string _name) {\n        _name = \"RCN - Nano loan engine - Basalt 202\";\n    }\n\n    function symbol() constant returns (string _symbol) {\n        _symbol = \"RCN-NLE-202\";\n    }\n\n    function totalSupply() constant returns (uint _totalSupply) {\n        _totalSupply = activeLoans;\n    }\n\n    function balanceOf(address _owner) constant returns (uint _balance) {\n        _balance = lendersBalance[_owner];\n    }\n\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) constant returns (uint tokenId) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0 || _index >= tokenCount) {\n            // Fail transaction\n            revert();\n        } else {\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n            // SWC-128-DoS With Block Gas Limit: L46\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    if (resultIndex == _index) {\n                        return loanId;\n                    }\n                    resultIndex++;\n                }\n            }\n\n            revert();\n        }\n    }\n\n    function tokensOfOwner(address _owner) external constant returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalLoans = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 loanId;\n\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\n                    result[resultIndex] = loanId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    Token public rcn;\n    bool public deprecated;\n\n    event CreatedLoan(uint _index, address _borrower, address _creator);\n    event ApprovedBy(uint _index, address _address);\n    event Lent(uint _index, address _lender, address _cosigner);\n    event DestroyedBy(uint _index, address _address);\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\n    event TotalPayment(uint _index);\n\n    function NanoLoanEngine(Token _rcn) public {\n        owner = msg.sender;\n        rcn = _rcn;\n    }\n\n    struct Loan {\n        Status status;\n        Oracle oracle;\n\n        address borrower;\n        address lender;\n        address creator;\n        address cosigner;\n        \n        uint256 amount;\n        uint256 interest;\n        uint256 punitoryInterest;\n        uint256 interestTimestamp;\n        uint256 paid;\n        uint256 interestRate;\n        uint256 interestRatePunitory;\n        uint256 dueTime;\n        uint256 duesIn;\n\n        bytes32 currency;\n        uint256 cancelableAt;\n        uint256 lenderBalance;\n\n        address approvedTransfer;\n        uint256 expirationRequest;\n\n        mapping(address => bool) approbations;\n    }\n\n    Loan[] private loans;\n\n    /**\n        @dev Creates a loan request, the loan can be generated with any borrower, cosigner, and conditions; if the \n        cosigner and borrower agree they must call the \"approve\" function.\n\n        The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\n\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\n        @param _borrower Address of the borrower\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\n            keccak256(ticker,decimals).\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\n            the currency is RCN, and the unit is wei.\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\n            Ej: interestRate 11108571428571 = 28% Anual interest\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \n        entirely or partially the loan before this term, no extra interest will be deducted.\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \n            the request is no longer valid.\n    */\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest) returns (uint256) {\n\n        require(!deprecated);\n        require(_cancelableAt <= _duesIn);\n        require(_oracleContract != address(0) || _currency == 0x0);\n        require(_borrower != address(0));\n        require(_amount != 0);\n        require(_interestRatePunitory != 0);\n        require(_interestRate != 0);\n        require(_expirationRequest > block.timestamp);\n\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest);\n        uint index = loans.push(loan) - 1;\n        CreatedLoan(index, _borrower, msg.sender);\n\n        if (msg.sender == _borrower) {\n            approveLoan(index);\n        }\n\n        return index;\n    }\n    \n    function ownerOf(uint256 index) constant returns (address owner) { owner = loans[index].lender; }\n    function getTotalLoans() constant returns (uint256) { return loans.length; }\n    function getOracle(uint index) constant returns (Oracle) { return loans[index].oracle; }\n    function getBorrower(uint index) constant returns (address) { return loans[index].borrower; }\n    function getCosigner(uint index) constant returns (address) { return loans[index].cosigner; }\n    function getCreator(uint index) constant returns (address) { return loans[index].creator; }\n    function getAmount(uint index) constant returns (uint256) { return loans[index].amount; }\n    function getPunitoryInterest(uint index) constant returns (uint256) { return loans[index].punitoryInterest; }\n    function getInterestTimestamp(uint index) constant returns (uint256) { return loans[index].interestTimestamp; }\n    function getPaid(uint index) constant returns (uint256) { return loans[index].paid; }\n    function getInterestRate(uint index) constant returns (uint256) { return loans[index].interestRate; }\n    function getInterestRatePunitory(uint index) constant returns (uint256) { return loans[index].interestRatePunitory; }\n    function getDueTime(uint index) constant returns (uint256) { return loans[index].dueTime; }\n    function getDuesIn(uint index) constant returns (uint256) { return loans[index].duesIn; }\n    function getCancelableAt(uint index) constant returns (uint256) { return loans[index].cancelableAt; }\n    function getApprobation(uint index, address _address) constant returns (bool) { return loans[index].approbations[_address]; }\n    function getStatus(uint index) constant returns (Status) { return loans[index].status; }\n    function getLenderBalance(uint index) constant returns (uint256) { return loans[index].lenderBalance; }\n    function getApprovedTransfer(uint index) constant returns (address) {return loans[index].approvedTransfer; }\n    function getCurrency(uint index) constant returns (bytes32) { return loans[index].currency; }\n    function getExpirationRequest(uint index) constant returns (uint256) { return loans[index].expirationRequest; }\n    function getInterest(uint index) constant returns (uint256) { return loans[index].interest; }\n\n    /**\n        @param index Index of the loan\n\n        @return true if the loan has been approved by the borrower and cosigner.\n    */\n    function isApproved(uint index) constant returns (bool) {\n        Loan storage loan = loans[index];\n        return loan.approbations[loan.borrower];\n    }\n\n    /**\n        @dev Called by the members of the loan to show that they agree with the terms of the loan; the borrower\n        must call this method before any lender could call the method \"lend\".\n            \n        Any address can call this method to be added to the \"approbations\" mapping.\n\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approveLoan(uint index) public returns(bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.initial);\n        loan.approbations[msg.sender] = true;\n        ApprovedBy(index, msg.sender);\n        return true;\n    }\n\n    /**\n        @dev Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\n\n        The loan must be previously approved by the borrower; before calling this function, the lender candidate must \n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\n        the requested amount, and the cosigner fee.\n        \n        @param index Index of the loan\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\n        @param cosignerData Data required by the cosigner to process the request.\n\n        @return true if the lend was done successfully\n    */\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.initial);\n        require(isApproved(index));\n        require(block.timestamp <= loan.expirationRequest);\n\n        loan.lender = msg.sender;\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\n        loan.interestTimestamp = block.timestamp;\n        loan.status = Status.lent;\n        \n        if (loan.cancelableAt > 0)\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\n\n        uint256 rate = getRate(loan, oracleData);\n\n        if (cosigner != address(0)) {\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\n            // address. If that does not happen, the transaction fails.\n            loan.cosigner = address(uint256(cosigner) + 2);\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\n            require(loan.cosigner == address(cosigner));\n        }\n        \n        require(rcn.transferFrom(msg.sender, loan.borrower, safeMult(loan.amount, rate)));\n        \n        // ERC721, create new loan and transfer it to the lender\n        Transfer(0x0, loan.lender, index);\n        activeLoans += 1;\n        lendersBalance[loan.lender] += 1;\n        Lent(index, loan.lender, cosigner);\n\n        return true;\n    }\n\n    /**\n        @dev The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee\n\n        @param index Index of the loan\n        @param cost Fee set by the cosigner\n\n        @return true If the cosign was successfull\n    */\n    function cosign(uint index, uint256 cost) external returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\n        require(loan.cosigner != address(0));\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\n        loan.cosigner = msg.sender;\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\n        return true;\n    }\n\n    /**\n        @dev Destroys a loan, the borrower could call this method if they performed an accidental or regretted \n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\n\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \n        the debt. \n\n        @param index Index of the loan\n\n        @return true if the destroy was done successfully\n    */\n    function destroy(uint index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(loan.status != Status.destroyed);\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\n        DestroyedBy(index, msg.sender);\n\n        // ERC721, remove loan from circulation\n        if (loan.status != Status.initial) {\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        loan.status = Status.destroyed;\n        return true;\n    }\n\n    /**\n        @dev Transfers a loan to a different lender, the caller must be the current lender or previously being\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\n\n        @param index Index of the loan\n        @param to New lender\n\n        @return true if the transfer was done successfully\n    */\n    function transfer(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        \n        require(loan.status != Status.destroyed && loan.status != Status.paid);\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\n        require(to != address(0));\n        loan.lender = to;\n        loan.approvedTransfer = address(0);\n\n        // ERC721, transfer loan to another address\n        lendersBalance[msg.sender] -= 1;\n        lendersBalance[to] += 1;\n        Transfer(loan.lender, to, index);\n\n        return true;\n    }\n\n    /**\n        @dev ERC721 method, transfers the loan to the msg.sender, the msg.sender must be approved using the \n        \"approve\" method.\n\n        @return true if the transfer was successfull\n    */\n    function takeOwnership(uint256 _index) public returns (bool) {\n        return transfer(msg.sender, _index);\n    }\n\n    /**\n        @dev Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\n\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\n\n        @param to Address allowed to transfer the loan or 0x0 to delete\n        @param index Index of the loan\n\n        @return true if the approve was done successfully\n    */\n    function approve(address to, uint256 index) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.approvedTransfer = to;\n        Approval(msg.sender, to, index);\n        return true;\n    }\n\n    /**\n        @dev Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \n        every second.\n\n        @param index Index of the loan\n\n        @return Aprox pending payment amount\n    */\n    function getPendingAmount(uint index) public constant returns (uint256) {\n        Loan storage loan = loans[index];\n        addInterest(index);\n        return getRawPendingAmount(loan);\n    }\n\n    function getRawPendingAmount(Loan loan) internal returns (uint256) {\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\n    }\n\n    /**\n        @dev Calculates the interest of a given amount, interest rate and delta time.\n\n        @param timeDelta Elapsed time\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\n        @param amount Amount to apply interest\n\n        @return realDelta The real timeDelta applied\n        @return interest The interest gained in the realDelta time\n    */\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) public constant returns (uint256 realDelta, uint256 interest) {\n        if (amount == 0) {\n            interest = 0;\n            realDelta = timeDelta;\n        } else {\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\n        }\n    }\n\n    /**\n        @dev Computes loan interest\n\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\n        \n        @param loan Loan to compute interest\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\n        if (timestamp > loan.interestTimestamp) {\n            uint256 newInterest = loan.interest;\n            uint256 newPunitoryInterest = loan.punitoryInterest;\n\n            uint256 newTimestamp;\n            uint256 realDelta;\n            uint256 calculatedInterest;\n\n            uint256 deltaTime;\n            uint256 pending;\n\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\n            if (endNonPunitory > loan.interestTimestamp) {\n                deltaTime = endNonPunitory - loan.interestTimestamp;\n\n                if (loan.paid < loan.amount) {\n                    pending = loan.amount - loan.paid;\n                } else {\n                    pending = 0;\n                }\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\n                newInterest = safeAdd(calculatedInterest, newInterest);\n                newTimestamp = loan.interestTimestamp + realDelta;\n            }\n\n            if (timestamp > loan.dueTime) {\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\n                deltaTime = timestamp - startPunitory;\n\n                uint256 debt = safeAdd(loan.amount, newInterest);\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\n\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\n                newTimestamp = startPunitory + realDelta;\n            }\n            \n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\n                loan.interestTimestamp = newTimestamp;\n                loan.interest = newInterest;\n                loan.punitoryInterest = newPunitoryInterest;\n            }\n        }\n    }\n\n    /**\n        @dev Computes loan interest only up to current unix time\n\n        @param timestamp Target absolute unix time to calculate interest.\n    */\n    function addInterestUpTo(Loan storage loan, uint256 timestamp) internal {\n        require(loan.status == Status.lent);\n        if (timestamp <= block.timestamp) {\n            internalAddInterest(loan, timestamp);\n        }\n    }\n\n    /**\n        @dev Updates the loan accumulated interests up to the current Unix time.\n        \n        @param index Index of the loan\n    */\n    function addInterest(uint index) public {\n        Loan storage loan = loans[index];\n        addInterestUpTo(loan, block.timestamp);\n    }\n    \n    /**\n        @dev Pay loan\n\n        Realizes a payment of a given Loan, before performing the payment the accumulated\n        interest is computed and added to the total pending amount.\n\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\n\n        Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\n\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\n        confirmation of the transaction. \n\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\n\n        @param index Index of the loan\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\n        @param _from The identity of the payer\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\n            by the url exposed in the url() method of the oracle.\n            \n        @return true if the payment was executed successfully\n    */\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\n        Loan storage loan = loans[index];\n\n        require(loan.status == Status.lent);\n        addInterest(index);\n        uint256 toPay = min(getPendingAmount(index), _amount);\n        PartialPayment(index, msg.sender, _from, toPay);\n\n        loan.paid = safeAdd(loan.paid, toPay);\n\n        if (getRawPendingAmount(loan) == 0) {\n            TotalPayment(index);\n            loan.status = Status.paid;\n\n            // ERC721, remove loan from circulation\n            lendersBalance[loan.lender] -= 1;\n            activeLoans -= 1;\n            Transfer(loan.lender, 0x0, index);\n        }\n\n        uint256 rate = getRate(loan, oracleData);\n        uint256 transferValue = safeMult(toPay, rate);\n        lockTokens(rcn, transferValue);\n        require(rcn.transferFrom(msg.sender, this, transferValue));\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\n\n        return true;\n    }\n\n    /**\n        @dev Retrieves the rate corresponding of the loan oracle, if the loan has no oracle the rate is 1\n\n        @param loan The loan with the cosigner\n        @param data Data required by the oracle\n\n        @return The rate of the oracle\n    */\n    function getRate(Loan loan, bytes data) internal returns (uint256) {\n        if (loan.oracle == address(0)) {\n            return 1;\n        } else {\n            return loan.oracle.getRate(loan.currency, data);\n        }\n    }\n\n    /**\n        @dev Withdraw lender funds\n\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \n        destination.\n\n        This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \n        autonomous organizations.\n\n        @param index Index of the loan\n        @param to Destination of the wiwthdraw funds\n        @param amount Amount to withdraw, in RCN\n\n        @return true if the withdraw was executed successfully\n    */\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\n        Loan storage loan = loans[index];\n        require(msg.sender == loan.lender);\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\n        require(rcn.transfer(to, amount));\n        unlockTokens(rcn, amount);\n        return true;\n    }\n\n    function withdrawalRange(uint256 fromIndex, uint256 toIndex, address to) public returns (uint256) {\n        uint256 loanId;\n        uint256 totalWithdraw = 0;\n\n        for (loanId = fromIndex; loanId <= toIndex; loanId++) {\n            Loan storage loan = loans[loanId];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n        \n        return totalWithdraw;\n    }\n\n    function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) {\n        uint256 inputId;\n        uint256 totalWithdraw = 0;\n\n        for (inputId = 0; inputId < loanIds.length; inputId++) {\n            Loan storage loan = loans[loanIds[inputId]];\n            if (loan.lender == msg.sender) {\n                totalWithdraw += loan.lenderBalance;\n                loan.lenderBalance = 0;\n            }\n        }\n\n        require(rcn.transfer(to, totalWithdraw));\n        unlockTokens(rcn, totalWithdraw);\n\n        return totalWithdraw;\n    }\n\n    /**\n        @dev Deprecates the engine, locks the creation of new loans.\n    */\n    function setDeprecated(bool _deprecated) public onlyOwner {\n        deprecated = _deprecated;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/NanoLoanEngine.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Use of addition operation without input validation in the `lend` function (`activeLoans += 1` and `lendersBalance[loan.lender] += 1`) may lead to an integer overflow."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library for arithmetic operations on `uint256`, which prevents integer overflow/underflow vulnerabilities."
    },
    {
        "code_segment": "contract StakingPool is Owned {\n    using SafeMath for uint256;\n    \n    Ierc20 public tswap;\n    Ierc20 public rewardToken;\n    uint256 poolDuration;\n    uint256 totalRewards;\n    uint256 rewardsWithdrawn;\n    uint256 poolStartTime;\n    uint256 poolEndTime;\n    uint256 totalStaked;\n    // Represents a single stake for a user. A user may have multiple.\n    struct Stake {\n        uint256 amount;\n        uint256 stakingTime;\n        uint256 lastWithdrawTime;\n    }\n    mapping (address => Stake[]) public userStaking;\n    \n    // Represents total staking of an user\n    struct UserTotals {\n        uint256 totalStaking;\n        uint256 totalStakingTIme;\n    }\n    mapping (address => UserTotals) public userTotalStaking;\n    \n    struct Ris3Rewards {\n        uint256 totalWithdrawn;\n        uint256 lastWithdrawTime;\n    }\n    mapping(address => Ris3Rewards) public userRewardInfo;\n    \n    event OwnerSetReward(uint256 amount);\n    event Staked(address userAddress, uint256 amount);\n    event StakingWithdrawal(address userAddress, uint256 amount);\n    event RewardWithdrawal(address userAddress, uint256 amount);\n    event PoolDurationChange(uint256 poolDuration);\n    \n    /**\n     * Constrctor function\n    */\n    constructor() public {\n        tswap = Ierc20(0xf823eA01D48F7Fb36b4b319f21dae404Ac86Bb8d);\n        rewardToken = Ierc20(0xdE55ea8232e0B1615d762eFCB17Cb2D7df164727);\n        poolDuration = 1 hours;\n    }\n    \n    //Set pool rewards\n    function ownerSetPoolRewards(uint256 _rewardAmount) external onlyOwner {\n        require(poolStartTime == 0, \"Pool rewards already set\");\n        require(_rewardAmount > 0, \"Cannot create pool with zero amount\");\n        \n        //set total rewards value\n        totalRewards = _rewardAmount;\n        \n        poolStartTime = now;\n        poolEndTime = now + poolDuration;\n        \n        //transfer tokens to contract\n        // SWC-104-Unchecked Call Return Value: L132\n        rewardToken.transferFrom(msg.sender, this, _rewardAmount);\n        emit OwnerSetReward(_rewardAmount);\n    }\n    \n    //Stake function for users to stake SWAP token\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Cannot stake 0\");\n        require(now < poolEndTime, \"Staking pool is closed\"); //staking pool is closed for staking\n        \n        //add value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.add(amount);\n        \n        //add new stake\n        Stake memory newStake = Stake(amount, now, 0);\n        userStaking[msg.sender].push(newStake);\n        \n        //add to total staked\n        totalStaked = totalStaked.add(amount);\n        \n        tswap.transferFrom(msg.sender, this, amount);\n        emit Staked(msg.sender, amount);\n    }\n    \n    //compute rewards\n    function computeNewReward(uint256 _rewardAmount, uint256 _stakedAmount, uint256 _stakeTimeSec) private view returns (uint256 _reward) {\n        uint256 rewardPerSecond = totalRewards.mul(1 ether);\n        if (rewardPerSecond != 0 ) {\n            rewardPerSecond = rewardPerSecond.div(poolDuration);\n        }\n        \n        if (rewardPerSecond > 0) {\n            uint256 rewardPerSecForEachTokenStaked = rewardPerSecond.div(totalStaked);\n            uint256 userRewards = rewardPerSecForEachTokenStaked.mul(_stakedAmount).mul(_stakeTimeSec);\n                    userRewards = userRewards.div(1 ether);\n            \n            return _rewardAmount.add(userRewards);\n        } else {\n            return 0;\n        }\n    }\n    \n    //calculate your rewards\n    function calculateReward(address _userAddress) public view returns (uint256 _reward) {\n        // all user stakes\n        Stake[] storage accountStakes = userStaking[_userAddress];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            i--;\n        }\n        \n        return rewardAmount;\n    }\n    \n    //Withdraw staking and rewards\n    function withdrawStaking(uint256 amount) external {\n        require(amount > 0, \"Amount can not be zero\");\n        require(userTotalStaking[msg.sender].totalStaking >= amount, \"You are trying to withdaw more than your stake\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 sharesLeftToBurn = amount;\n        uint256 rewardAmount = 0;\n        while (sharesLeftToBurn > 0) {\n            Stake storage lastStake = accountStakes[accountStakes.length - 1];\n            uint256 stakeTimeSec;\n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(lastStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(lastStake.stakingTime);\n                if(lastStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(lastStake.lastWithdrawTime);\n                }\n            }\n            \n            if (lastStake.amount <= sharesLeftToBurn) {\n                // fully redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, lastStake.amount, stakeTimeSec);\n                sharesLeftToBurn = sharesLeftToBurn.sub(lastStake.amount);\n                accountStakes.length--;\n            } else {\n                // partially redeem a past stake\n                rewardAmount = computeNewReward(rewardAmount, sharesLeftToBurn, stakeTimeSec);\n                lastStake.amount = lastStake.amount.sub(sharesLeftToBurn);\n                lastStake.lastWithdrawTime = now;\n                sharesLeftToBurn = 0;\n            }\n        }\n        \n        //substract value in staking\n        userTotalStaking[msg.sender].totalStaking = userTotalStaking[msg.sender].totalStaking.sub(amount);\n        \n        //substract from total staked\n        totalStaked = totalStaked.sub(amount);\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards and tokens\n        // SWC-104-Unchecked Call Return Value: L262\n        rewardToken.transfer(msg.sender, rewardAmount);\n        tswap.transfer(msg.sender, amount);\n        \n        emit RewardWithdrawal(msg.sender, rewardAmount);\n        emit StakingWithdrawal(msg.sender, amount);\n    }\n    \n    //Withdraw rewards\n    function withdrawRewardsOnly() external {\n        uint256 _rwdAmount = calculateReward(msg.sender);\n        require(_rwdAmount > 0, \"You do not have enough rewards\");\n        \n        // 1. User Accounting\n        Stake[] storage accountStakes = userStaking[msg.sender];\n        \n        // Redeem from most recent stake and go backwards in time.\n        uint256 rewardAmount = 0;\n        uint256 i = accountStakes.length;\n        while (i > 0) {\n            Stake storage userStake = accountStakes[i - 1];\n            uint256 stakeTimeSec;\n            \n            //check if current time is more than pool ending time\n            if (now > poolEndTime) {\n                stakeTimeSec = poolEndTime.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = poolEndTime.sub(userStake.lastWithdrawTime);\n                }\n            } else {\n                stakeTimeSec = now.sub(userStake.stakingTime);\n                if(userStake.lastWithdrawTime != 0){\n                    stakeTimeSec = now.sub(userStake.lastWithdrawTime);\n                }\n            }\n            \n            // fully redeem a past stake\n            rewardAmount = computeNewReward(rewardAmount, userStake.amount, stakeTimeSec);\n            userStake.lastWithdrawTime = now;\n            i--;\n        }\n        \n        //update user rewards info\n        userRewardInfo[msg.sender].totalWithdrawn = userRewardInfo[msg.sender].totalWithdrawn.add(rewardAmount);\n        userRewardInfo[msg.sender].lastWithdrawTime = now;\n        \n        //update total rewards withdrawn\n        rewardsWithdrawn = rewardsWithdrawn.add(rewardAmount);\n        \n        //transfer rewards\n        rewardToken.transfer(msg.sender, rewardAmount);\n        emit RewardWithdrawal(msg.sender, rewardAmount);\n    }\n    \n    //get staking details by user address\n    function getStakingAmount(address _userAddress) external constant returns (uint256 _stakedAmount) {\n        return userTotalStaking[_userAddress].totalStaking;\n    }\n    \n    //get total rewards collected by user\n    function getTotalRewardCollectedByUser(address userAddress) view external returns (uint256 _totalRewardCollected) \n    {\n        return userRewardInfo[userAddress].totalWithdrawn;\n    }\n    \n    //get total SWAP token staked in the contract\n    function getTotalStaked() external constant returns ( uint256 _totalStaked) {\n        return totalStaked;\n    }\n    \n    //get total rewards in the contract\n    function getTotalRewards() external constant returns ( uint256 _totalRewards) {\n        return totalRewards;\n    }\n    \n    //get pool details\n    function getPoolDetails() external view returns (address _baseToken, address _pairedToken, uint256 _totalRewards, uint256 _rewardsWithdrawn, uint256 _poolStartTime, uint256 _poolEndTime) {\n        return (address(tswap),address(rewardToken),totalRewards,rewardsWithdrawn,poolStartTime,poolEndTime);\n    }\n    \n    //get duration of pools\n    function getPoolDuration() external constant returns (uint256 _poolDuration) {\n        return poolDuration;\n    }\n\n    //set duration of pools by owner in seconds\n    function setPoolDuration(uint256 _poolDuration) external onlyOwner {\n        poolDuration = _poolDuration;\n        poolEndTime = poolStartTime + _poolDuration;\n        emit PoolDurationChange(_poolDuration);\n    }\n    \n    //get SWAP token address\n    function getSwapAddress() external constant returns (address _swapAddress) {\n        return address(tswap);\n    }\n    \n    //set tswap address\n    function setTswapAddress(address _address) external onlyOwner {\n        tswap = Ierc20(_address);\n    }\n    \n    //set reward token address\n    function setRewardTokenAddress(address _address) external onlyOwner {\n        rewardToken = Ierc20(_address);\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-TrustSwap-V1/code/StakingPool.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for all arithmetic operations, which prevents both integer overflow and underflow vulnerabilities."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L97\n    require(_value <= balances[msg.sender]);\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    return balances[_owner];\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for uint256 operations, which prevents integer overflow."
    },
    {
        "code_segment": "contract JarvisPlusToken is StandardToken, Ownable {\n\n    string public constant name = \"Jarvis+ Token\";\n    string public constant symbol = \"JAR\";\n    uint8 public constant decimals = 18;\n\n    // This is the initial amount of JAR.\n    uint256 private constant initialAmount = 600000000000000000000000000;\n\n    constructor() public {\n\n        // totalSupply_ = initialAmount;\n        // balances[owner].add(initialAmount);\n        // emit Transfer(address(0), owner, initialAmount);\n        owner = msg.sender;\n        if(totalSupply() ==  0) {\n            totalSupply_ = initialAmount;\n            owner = msg.sender;\n            balances[msg.sender] = initialAmount;\n            emit Transfer(address(0), msg.sender, initialAmount);\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses a safe method '.add()' and properly initializes values without directly adding to balances, thus avoiding overflow issues."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    // SWC-135-Code With No Effects: L167 - L168\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint256 _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint256 _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint256 oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-Jarvis+ Token (JAR) Security Audit/code/JarvisPlusToken_flat.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses the SafeMath library for arithmetic operations, which prevents integer overflows and underflows."
    },
    {
        "code_segment": "contract BurnableToken is BasicToken {\n\n  event Burn(address indexed burner, uint256 value);\n\n  /**\n   * @dev Burns a specific amount of tokens.\n   * @param _value The amount of token to be burned.\n   */\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n    // no need to require value <= totalSupply, since that would imply the\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library (indicated by the .sub method) to perform subtraction, which prevents integer overflow."
    },
    {
        "code_segment": "contract FreezableMintableToken is FreezableToken, MintableToken {\n    /**\n     * @dev Mint the specified amount of token to the specified address and freeze it until the specified date.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to mint and freeze.\n     * @param _until Release date, must be in future.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) {\n        totalSupply_ = totalSupply_.add(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Mint(_to, _amount);\n        emit Freezed(_to, _until, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code utilizes SafeMath's `add` function to handle arithmetic operations, which prevents Integer Overflow."
    },
    {
        "code_segment": "contract FreezableToken is StandardToken {\n    // freezing chains\n    mapping (bytes32 => uint64) internal chains;\n    // freezing amounts for each chain\n    mapping (bytes32 => uint) internal freezings;\n    // total freezing balance per address\n    mapping (address => uint) internal freezingBalance;\n\n    event Freezed(address indexed to, uint64 release, uint amount);\n    event Released(address indexed owner, uint amount);\n\n    /**\n     * @dev Gets the balance of the specified address include freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner) + freezingBalance[_owner];\n    }\n//SWC-101-Integer Overflow and Underflow:L408\n    /**\n     * @dev Gets the balance of the specified address without freezing tokens.\n     * @param _owner The address to query the the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function actualBalanceOf(address _owner) public view returns (uint256 balance) {\n        return super.balanceOf(_owner);\n    }\n\n    function freezingBalanceOf(address _owner) public view returns (uint256 balance) {\n        return freezingBalance[_owner];\n    }\n\n    /**\n     * @dev gets freezing count\n     * @param _addr Address of freeze tokens owner.\n     */\n    function freezingCount(address _addr) public view returns (uint count) {\n        uint64 release = chains[toKey(_addr, 0)];\n        while (release != 0) {\n            count++;\n            release = chains[toKey(_addr, release)];\n        }\n    }\n\n    /**\n     * @dev gets freezing end date and freezing balance for the freezing portion specified by index.\n     * @param _addr Address of freeze tokens owner.\n     * @param _index Freezing portion index. It ordered by release date descending.\n     */\n    function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) {\n        for (uint i = 0; i < _index + 1; i++) {\n            _release = chains[toKey(_addr, _release)];\n            if (_release == 0) {\n                return;\n            }\n        }\n        _balance = freezings[toKey(_addr, _release)];\n    }\n\n    /**\n     * @dev freeze your tokens to the specified address.\n     *      Be careful, gas usage is not deterministic,\n     *      and depends on how many freezes _to address already has.\n     * @param _to Address to which token will be freeze.\n     * @param _amount Amount of token to freeze.\n     * @param _until Release date, must be in future.\n     */\n    function freezeTo(address _to, uint _amount, uint64 _until) public {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        bytes32 currentKey = toKey(_to, _until);\n        freezings[currentKey] = freezings[currentKey].add(_amount);\n        freezingBalance[_to] = freezingBalance[_to].add(_amount);\n\n        freeze(_to, _until);\n        emit Transfer(msg.sender, _to, _amount);\n        emit Freezed(_to, _until, _amount);\n    }\n\n    /**\n     * @dev release first available freezing tokens.\n     */\n    function releaseOnce() public {\n        bytes32 headKey = toKey(msg.sender, 0);\n        uint64 head = chains[headKey];\n        require(head != 0);\n        require(uint64(block.timestamp) > head);\n        bytes32 currentKey = toKey(msg.sender, head);\n//SWC-116-Block values as a proxy for time:L481\n        uint64 next = chains[currentKey];\n\n        uint amount = freezings[currentKey];\n        delete freezings[currentKey];\n\n        balances[msg.sender] = balances[msg.sender].add(amount);\n        freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount);\n\n        if (next == 0) {\n            delete chains[headKey];\n        } else {\n            chains[headKey] = next;\n            delete chains[currentKey];\n        }\n        emit Released(msg.sender, amount);\n    }\n//SWC-116-Block values as a proxy for time:L509\n    /**\n     * @dev release all available for release freezing tokens. Gas usage is not deterministic!\n     * @return how many tokens was released\n     */\n    function releaseAll() public returns (uint tokens) {\n        uint release;\n        uint balance;\n        (release, balance) = getFreezing(msg.sender, 0);\n        while (release != 0 && block.timestamp > release) {\n            releaseOnce();\n            tokens += balance;\n            (release, balance) = getFreezing(msg.sender, 0);\n        }\n    }\n//SWC-101-Integer Overflow and Underflow:L511\n    function toKey(address _addr, uint _release) internal pure returns (bytes32 result) {\n        // WISH masc to increase entropy\n        result = 0x5749534800000000000000000000000000000000000000000000000000000000;\n        assembly {\n            result := or(result, mul(_addr, 0x10000000000000000))\n            result := or(result, and(_release, 0xffffffffffffffff))\n        }\n    }\n//SWC-116-Block values as a proxy for time:L526\n    function freeze(address _to, uint64 _until) internal {\n        require(_until > block.timestamp);\n        bytes32 key = toKey(_to, _until);\n        bytes32 parentKey = toKey(_to, uint64(0));\n        uint64 next = chains[parentKey];\n\n        if (next == 0) {\n            chains[parentKey] = _until;\n            return;\n        }\n\n        bytes32 nextKey = toKey(_to, next);\n        uint parent;\n\n        while (next != 0 && _until > next) {\n            parent = next;\n            parentKey = nextKey;\n\n            next = chains[nextKey];\n            nextKey = toKey(_to, next);\n        }\n\n        if (_until == next) {\n            return;\n        }\n\n        if (next != 0) {\n            chains[key] = next;\n        }\n\n        chains[parentKey] = _until;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's add and sub functions to handle arithmetic operations, ensuring there is no integer overflow."
    },
    {
        "code_segment": "contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable {\n    \n    event Initialized();\n    bool public initialized = false;\n\n    constructor() public {\n        init();\n        transferOwnership(TARGET_USER);\n    }\n    \n\n    function name() public pure returns (string _name) {\n        return TOKEN_NAME;\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return TOKEN_SYMBOL;\n    }\n\n    function decimals() public pure returns (uint8 _decimals) {\n        return TOKEN_DECIMALS_UINT8;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool _success) {\n        require(!paused);\n        return super.transfer(_to, _value);\n    }\n\n    \n    function init() private {\n        require(!initialized);\n        initialized = true;\n\n        if (PAUSED) {\n            pause();\n        }\n\n        \n        address[1] memory addresses = [address(0x1e57f50778fc34dae64d7f16ad120193f8631464)];\n        uint[1] memory amounts = [uint(10000000000000000)];\n        uint64[1] memory freezes = [uint64(0)];\n\n        for (uint i = 0; i < addresses.length; i++) {\n            if (freezes[i] == 0) {\n                mint(addresses[i], amounts[i]);\n            } else {\n                mintAndFreeze(addresses[i], amounts[i], freezes[i]);\n            }\n        }\n        \n\n        if (!CONTINUE_MINTING) {\n            finishMinting();\n        }\n\n        emit Initialized();\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform arithmetic operations that could lead to integer overflows."
    },
    {
        "code_segment": "contract MintableToken is StandardToken, Ownable {\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  modifier hasMintPermission() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Function to mint tokens\n   * @param _to The address that will receive the minted tokens.\n   * @param _amount The amount of tokens to mint.\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function mint(\n    address _to,\n    uint256 _amount\n  )\n    hasMintPermission\n    canMint\n    public\n    returns (bool)\n  {\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n  function finishMinting() onlyOwner canMint public returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes  \nDescription: The use of .add() from a library like SafeMath typically prevents overflow, but without seeing the exact implementation of StandardToken or SafeMath, we cannot guarantee protection."
    },
    {
        "code_segment": "contract StandardToken is BEP20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  )\n    public\n    returns (bool)\n  {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    emit Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    emit Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address _owner,\n    address _spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(\n    address _spender,\n    uint _addedValue\n  )\n    public\n    returns (bool)\n  {\n    allowed[msg.sender][_spender] = (\n      allowed[msg.sender][_spender].add(_addedValue));\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(\n    address _spender,\n    uint _subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/QuillAudits-NomadLand Smart Contract/code/MainToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The use of SafeMath library functions (`sub` and `add`) for arithmetic operations prevents integer overflow."
    },
    {
        "code_segment": "contract BridgeValidators is IBridgeValidators, EternalStorage, Ownable {\n    using SafeMath for uint256;\n    event ValidatorAdded (address validator);\n    event ValidatorRemoved (address validator);\n    event RequiredSignaturesChanged (uint256 requiredSignatures);\n\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)\n      public returns(bool)\n    {\n        require(!isInitialized());\n        require(_owner != address(0));\n        setOwner(_owner);\n        require(_requiredSignatures != 0);\n        require(_initialValidators.length >= _requiredSignatures);\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n            require(_initialValidators[i] != address(0));\n            assert(validators(_initialValidators[i]) != true);\n            setValidatorCount(validatorCount().add(1));\n            setValidator(_initialValidators[i], true);\n            emit ValidatorAdded(_initialValidators[i]);\n        }\n        //SWC-135-Code With No Effects: L31\n        require(validatorCount() >= _requiredSignatures);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        setInitialize(true);\n        return isInitialized();\n    }\n\n    function addValidator(address _validator) external onlyOwner {\n        require(_validator != address(0));\n        require(!isValidator(_validator));\n        setValidatorCount(validatorCount().add(1));\n        setValidator(_validator, true);\n        emit ValidatorAdded(_validator);\n    }\n\n    function removeValidator(address _validator) external onlyOwner {\n        require(validatorCount() > requiredSignatures());\n        require(isValidator(_validator));\n        setValidator(_validator, false);\n        setValidatorCount(validatorCount().sub(1));\n        emit ValidatorRemoved(_validator);\n    }\n\n    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {\n        require(validatorCount() >= _requiredSignatures);\n        require(_requiredSignatures != 0);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        emit RequiredSignaturesChanged(_requiredSignatures);\n    }\n\n    function requiredSignatures() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\n    }\n\n    function validatorCount() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))];\n    }\n\n    function validators(address _validator) public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))];\n    }\n\n    function isValidator(address _validator) public view returns(bool) {\n        return validators(_validator) == true;\n    }\n\n    function isInitialized() public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n    }\n\n    function setValidatorCount(uint256 _validatorCount) private {\n        uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))] = _validatorCount;\n    }\n\n    function setValidator(address _validator, bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))] = _status;\n    }\n\n    function setInitialize(bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath for uint256 operations, which prevents integer overflow."
    },
    {
        "code_segment": "contract BridgeValidators is IBridgeValidators, EternalStorage, Ownable {\n    using SafeMath for uint256;\n    event ValidatorAdded (address validator);\n    event ValidatorRemoved (address validator);\n    event RequiredSignaturesChanged (uint256 requiredSignatures);\n\n    function initialize(uint256 _requiredSignatures, address[] _initialValidators, address _owner)\n      public returns(bool)\n    {\n        require(!isInitialized());\n        require(_owner != address(0));\n        setOwner(_owner);\n        require(_requiredSignatures != 0);\n        require(_initialValidators.length >= _requiredSignatures);\n        for (uint256 i = 0; i < _initialValidators.length; i++) {\n            require(_initialValidators[i] != address(0));\n            assert(validators(_initialValidators[i]) != true);\n            setValidatorCount(validatorCount().add(1));\n            setValidator(_initialValidators[i], true);\n            emit ValidatorAdded(_initialValidators[i]);\n        }\n        //SWC-135-Code With No Effects: L31\n        require(validatorCount() >= _requiredSignatures);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        setInitialize(true);\n        return isInitialized();\n    }\n\n    function addValidator(address _validator) external onlyOwner {\n        require(_validator != address(0));\n        require(!isValidator(_validator));\n        setValidatorCount(validatorCount().add(1));\n        setValidator(_validator, true);\n        emit ValidatorAdded(_validator);\n    }\n\n    function removeValidator(address _validator) external onlyOwner {\n        require(validatorCount() > requiredSignatures());\n        require(isValidator(_validator));\n        setValidator(_validator, false);\n        setValidatorCount(validatorCount().sub(1));\n        emit ValidatorRemoved(_validator);\n    }\n\n    function setRequiredSignatures(uint256 _requiredSignatures) external onlyOwner {\n        require(validatorCount() >= _requiredSignatures);\n        require(_requiredSignatures != 0);\n        uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))] = _requiredSignatures;\n        emit RequiredSignaturesChanged(_requiredSignatures);\n    }\n\n    function requiredSignatures() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"requiredSignatures\"))];\n    }\n\n    function validatorCount() public view returns(uint256) {\n        return uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))];\n    }\n\n    function validators(address _validator) public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))];\n    }\n\n    function isValidator(address _validator) public view returns(bool) {\n        return validators(_validator) == true;\n    }\n\n    function isInitialized() public view returns(bool) {\n        return boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))];\n    }\n\n    function setValidatorCount(uint256 _validatorCount) private {\n        uintStorage[keccak256(abi.encodePacked(\"validatorCount\"))] = _validatorCount;\n    }\n\n    function setValidator(address _validator, bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"validators\", _validator))] = _status;\n    }\n\n    function setInitialize(bool _status) private {\n        boolStorage[keccak256(abi.encodePacked(\"isInitialized\"))] = _status;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract code uses SafeMath for uint256 operations, which prevents integer underflows."
    },
    {
        "code_segment": "contract Ownable is EternalStorage {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: There are no arithmetic operations in the provided code that could cause an integer overflow."
    },
    {
        "code_segment": "contract Ownable is EternalStorage {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/PepperSec-POA-Network-Bridge/tokenbridge-contracts-2bf70c7e9fd42968aec2dc352017618907834401/contracts/upgradeable_contracts/BridgeValidators.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform any arithmetic operations, thus there is no scope for integer underflow vulnerabilities."
    },
    {
        "code_segment": "contract MainContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n    struct AccountData {\n        uint8 accountType; // 0 => Freelancer, 1 => Approver, 2 => Customer\n        address personWalletAddress;\n        uint256 personWorkCount;\n        uint256[] personPuan; // Rate x/5\n        address[] WorkAddresses; // All work addresses\n        string personInfoData;\n    }\n\n    mapping(address => AccountData) accounts;\n    mapping(address => bool) personsAddress;\n    mapping(address => uint8) public feeRates;\n    mapping(address => bool) public availableTokens;\n    mapping(address => uint256) public approverLockBalances;\n    mapping(address => bool) public isDeployedWorks;\n\n    uint8 public bnbFeeRate;\n    uint256 public remainingArgonToken;\n    uint256 public approverMinArgonLimit;\n    address[] public deployedWorks;\n    address[] public allPersons;\n    address public feeAddress;\n    address public argonTokenContractAddress;\n    bool public isActive;\n    IERC20 public argonToken; // ArgonToken Contract Address\n\n    modifier isInAccounts() {\n        require(personsAddress[msg.sender]);\n        _;\n    }\n\n    modifier mustApprover() {\n        require(personsAddress[msg.sender]);\n        AccountData storage data = accounts[msg.sender];\n        require(data.accountType == 1);\n        _;\n    }\n\n    modifier mustActive() {\n        require(isActive);\n        _;\n    }\n\n    constructor(\n        address _argonTokenAddress,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) public {\n        argonToken = IERC20(_argonTokenAddress);\n        bnbFeeRate = _bnbFeeRate;\n        remainingArgonToken = 5e6 ether;\n        approverMinArgonLimit = 20000 * 10**18;\n        feeAddress = _feeAddress;\n        argonTokenContractAddress = _argonTokenAddress;\n    }\n\n    function changeActive(bool _active) external onlyApprover {\n        isActive = _active;\n    }\n\n    function changeAvailableTokenFee(\n        address _tokenAddress,\n        uint8 _feeRate,\n        bool _available\n    ) external onlyApprover {\n        feeRates[_tokenAddress] = _feeRate;\n        availableTokens[_tokenAddress] = _available;\n    }\n\n    function changeSettings(\n        uint256 _approverMinArgonLimit,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) external onlyApprover {\n        approverMinArgonLimit = _approverMinArgonLimit;\n        bnbFeeRate = _bnbFeeRate;\n        feeAddress = _feeAddress;\n    }\n\n    function sendArgonTokenAdmin(address _address, uint256 amount)\n        external\n        onlyApprover\n        nonReentrant\n    {\n        argonToken.transfer(_address, amount);\n    }\n\n    function unLock() external mustApprover nonReentrant {\n        require(approverLockBalances[msg.sender] > 0);\n        AccountData storage data = accounts[msg.sender];\n        require(data.WorkAddresses.length == 0);\n        delete accounts[msg.sender];\n        personsAddress[msg.sender] = false;\n        for (uint256 x = 0; x < allPersons.length; x++) {\n            if (allPersons[x] == msg.sender) {\n                delete allPersons[x];\n            }\n        }\n        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);\n        approverLockBalances[msg.sender] = 0;\n    }\n\n    function getAllPersons() external view returns (address[]) {\n        return allPersons;\n    }\n\n    function addPerson(uint8 _accountType, string _personInfoData)\n        external\n        mustActive\n        nonReentrant\n    {\n        if (_accountType == 1) {\n            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]\n                .safeAdd(approverMinArgonLimit);\n            require(\n                argonToken.transferFrom(\n                    msg.sender,\n                    address(this),\n                    approverMinArgonLimit\n                )\n            );\n        }\n        require(!personsAddress[msg.sender]);\n        AccountData memory newAccount =\n            AccountData({\n                accountType: _accountType,\n                personWalletAddress: msg.sender,\n                personWorkCount: 0,\n                personPuan: new uint256[](0),\n                WorkAddresses: new address[](0),\n                personInfoData: _personInfoData\n            });\n\n        accounts[msg.sender] = newAccount; // Adding a new account\n        allPersons.push(msg.sender); // Adding a new account\n        personsAddress[msg.sender] = true;\n    }\n\n    function getPersonInfoData(address _personAddress)\n        external\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256[],\n            address[],\n            string\n        )\n    {\n        AccountData storage data = accounts[_personAddress];\n        return (\n            data.accountType,\n            data.personWorkCount,\n            data.personPuan,\n            data.WorkAddresses,\n            data.personInfoData\n        );\n    }\n\n    function getPersonAccountType(address _personAddress)\n        public\n        view\n        returns (uint8)\n    {\n        AccountData storage data = accounts[_personAddress];\n        return data.accountType;\n    }\n\n    function updatePerson(string _personInfoData)\n        external\n        isInAccounts\n        mustActive\n    {\n        AccountData storage data = accounts[msg.sender];\n        data.personInfoData = _personInfoData;\n    }\n\n    function createWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget\n    ) external mustActive {\n        AccountData storage data = accounts[msg.sender];\n        require(getPersonAccountType(msg.sender) == 2);\n        address newWork =\n            new WorkContract(\n                _workTitle,\n                _workCategory,\n                _workDescription,\n                _workAvarageBudget,\n                msg.sender,\n                this\n            );\n        data.WorkAddresses.push(newWork); // Adding Person Works\n        deployedWorks.push(newWork); // Adding All Works\n        isDeployedWorks[newWork] = true;\n    }\n\n    function getWorks() external view returns (address[]) {\n        return deployedWorks;\n    }\n\n    function setPuan(uint256 _puan, address _freelancerAddress) external {\n        require(isDeployedWorks[msg.sender]);\n        AccountData storage data = accounts[_freelancerAddress];\n        data.personPuan.push(_puan);\n    }\n\n    function setApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        data.WorkAddresses.push(_workAddress);\n    }\n\n    function _removeApproverWorkAddressArray(\n        uint256 index,\n        address _approveraddress\n    ) private {\n        AccountData storage data = accounts[_approveraddress];\n\n        if (index >= data.WorkAddresses.length) return;\n\n        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {\n            data.WorkAddresses[i] = data.WorkAddresses[i + 1];\n        }\n        delete data.WorkAddresses[data.WorkAddresses.length - 1];\n        data.WorkAddresses.length--;\n    }\n\n    function deleteApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {\n            if (data.WorkAddresses[i] == _workAddress) {\n                _removeApproverWorkAddressArray(i, _approveraddress);\n            }\n        }\n    }\n\n    function checkDeadline(address _workAddress)\n        external\n        view\n        returns (bool, address)\n    {\n        WorkContract deployedWork;\n        deployedWork = WorkContract(_workAddress);\n        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {\n            return (true, _workAddress);\n        } else {\n            return (false, _workAddress);\n        }\n    }\n\n    function sendApproverArgonCoin(address _approveraddress) external {\n        require(isDeployedWorks[msg.sender]);\n\n        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);\n        argonToken.transfer(_approveraddress, amount);\n        remainingArgonToken = remainingArgonToken.safeSub(amount);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath for all mathematical operations involving uint256 data types, which protects against integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract MainContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n    struct AccountData {\n        uint8 accountType; // 0 => Freelancer, 1 => Approver, 2 => Customer\n        address personWalletAddress;\n        uint256 personWorkCount;\n        uint256[] personPuan; // Rate x/5\n        address[] WorkAddresses; // All work addresses\n        string personInfoData;\n    }\n\n    mapping(address => AccountData) accounts;\n    mapping(address => bool) personsAddress;\n    mapping(address => uint8) public feeRates;\n    mapping(address => bool) public availableTokens;\n    mapping(address => uint256) public approverLockBalances;\n    mapping(address => bool) public isDeployedWorks;\n\n    uint8 public bnbFeeRate;\n    uint256 public remainingArgonToken;\n    uint256 public approverMinArgonLimit;\n    address[] public deployedWorks;\n    address[] public allPersons;\n    address public feeAddress;\n    address public argonTokenContractAddress;\n    bool public isActive;\n    IERC20 public argonToken; // ArgonToken Contract Address\n\n    modifier isInAccounts() {\n        require(personsAddress[msg.sender]);\n        _;\n    }\n\n    modifier mustApprover() {\n        require(personsAddress[msg.sender]);\n        AccountData storage data = accounts[msg.sender];\n        require(data.accountType == 1);\n        _;\n    }\n\n    modifier mustActive() {\n        require(isActive);\n        _;\n    }\n\n    constructor(\n        address _argonTokenAddress,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) public {\n        argonToken = IERC20(_argonTokenAddress);\n        bnbFeeRate = _bnbFeeRate;\n        remainingArgonToken = 5e6 ether;\n        approverMinArgonLimit = 20000 * 10**18;\n        feeAddress = _feeAddress;\n        argonTokenContractAddress = _argonTokenAddress;\n    }\n\n    function changeActive(bool _active) external onlyApprover {\n        isActive = _active;\n    }\n\n    function changeAvailableTokenFee(\n        address _tokenAddress,\n        uint8 _feeRate,\n        bool _available\n    ) external onlyApprover {\n        feeRates[_tokenAddress] = _feeRate;\n        availableTokens[_tokenAddress] = _available;\n    }\n\n    function changeSettings(\n        uint256 _approverMinArgonLimit,\n        uint8 _bnbFeeRate,\n        address _feeAddress\n    ) external onlyApprover {\n        approverMinArgonLimit = _approverMinArgonLimit;\n        bnbFeeRate = _bnbFeeRate;\n        feeAddress = _feeAddress;\n    }\n\n    function sendArgonTokenAdmin(address _address, uint256 amount)\n        external\n        onlyApprover\n        nonReentrant\n    {\n        argonToken.transfer(_address, amount);\n    }\n\n    function unLock() external mustApprover nonReentrant {\n        require(approverLockBalances[msg.sender] > 0);\n        AccountData storage data = accounts[msg.sender];\n        require(data.WorkAddresses.length == 0);\n        delete accounts[msg.sender];\n        personsAddress[msg.sender] = false;\n        for (uint256 x = 0; x < allPersons.length; x++) {\n            if (allPersons[x] == msg.sender) {\n                delete allPersons[x];\n            }\n        }\n        argonToken.transfer(msg.sender, approverLockBalances[msg.sender]);\n        approverLockBalances[msg.sender] = 0;\n    }\n\n    function getAllPersons() external view returns (address[]) {\n        return allPersons;\n    }\n\n    function addPerson(uint8 _accountType, string _personInfoData)\n        external\n        mustActive\n        nonReentrant\n    {\n        if (_accountType == 1) {\n            approverLockBalances[msg.sender] = approverLockBalances[msg.sender]\n                .safeAdd(approverMinArgonLimit);\n            require(\n                argonToken.transferFrom(\n                    msg.sender,\n                    address(this),\n                    approverMinArgonLimit\n                )\n            );\n        }\n        require(!personsAddress[msg.sender]);\n        AccountData memory newAccount =\n            AccountData({\n                accountType: _accountType,\n                personWalletAddress: msg.sender,\n                personWorkCount: 0,\n                personPuan: new uint256[](0),\n                WorkAddresses: new address[](0),\n                personInfoData: _personInfoData\n            });\n\n        accounts[msg.sender] = newAccount; // Adding a new account\n        allPersons.push(msg.sender); // Adding a new account\n        personsAddress[msg.sender] = true;\n    }\n\n    function getPersonInfoData(address _personAddress)\n        external\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256[],\n            address[],\n            string\n        )\n    {\n        AccountData storage data = accounts[_personAddress];\n        return (\n            data.accountType,\n            data.personWorkCount,\n            data.personPuan,\n            data.WorkAddresses,\n            data.personInfoData\n        );\n    }\n\n    function getPersonAccountType(address _personAddress)\n        public\n        view\n        returns (uint8)\n    {\n        AccountData storage data = accounts[_personAddress];\n        return data.accountType;\n    }\n\n    function updatePerson(string _personInfoData)\n        external\n        isInAccounts\n        mustActive\n    {\n        AccountData storage data = accounts[msg.sender];\n        data.personInfoData = _personInfoData;\n    }\n\n    function createWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget\n    ) external mustActive {\n        AccountData storage data = accounts[msg.sender];\n        require(getPersonAccountType(msg.sender) == 2);\n        address newWork =\n            new WorkContract(\n                _workTitle,\n                _workCategory,\n                _workDescription,\n                _workAvarageBudget,\n                msg.sender,\n                this\n            );\n        data.WorkAddresses.push(newWork); // Adding Person Works\n        deployedWorks.push(newWork); // Adding All Works\n        isDeployedWorks[newWork] = true;\n    }\n\n    function getWorks() external view returns (address[]) {\n        return deployedWorks;\n    }\n\n    function setPuan(uint256 _puan, address _freelancerAddress) external {\n        require(isDeployedWorks[msg.sender]);\n        AccountData storage data = accounts[_freelancerAddress];\n        data.personPuan.push(_puan);\n    }\n\n    function setApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        data.WorkAddresses.push(_workAddress);\n    }\n\n    function _removeApproverWorkAddressArray(\n        uint256 index,\n        address _approveraddress\n    ) private {\n        AccountData storage data = accounts[_approveraddress];\n\n        if (index >= data.WorkAddresses.length) return;\n\n        for (uint256 i = index; i < data.WorkAddresses.length - 1; i++) {\n            data.WorkAddresses[i] = data.WorkAddresses[i + 1];\n        }\n        delete data.WorkAddresses[data.WorkAddresses.length - 1];\n        data.WorkAddresses.length--;\n    }\n\n    function deleteApproverWorkAddress(\n        address _workAddress,\n        address _approveraddress\n    ) external {\n        require(isDeployedWorks[msg.sender]);\n\n        AccountData storage data = accounts[_approveraddress];\n        for (uint256 i = 0; i < data.WorkAddresses.length; i++) {\n            if (data.WorkAddresses[i] == _workAddress) {\n                _removeApproverWorkAddressArray(i, _approveraddress);\n            }\n        }\n    }\n\n    function checkDeadline(address _workAddress)\n        external\n        view\n        returns (bool, address)\n    {\n        WorkContract deployedWork;\n        deployedWork = WorkContract(_workAddress);\n        if (now > deployedWork.deadLine() && deployedWork.deadLine() != 0) {\n            return (true, _workAddress);\n        } else {\n            return (false, _workAddress);\n        }\n    }\n\n    function sendApproverArgonCoin(address _approveraddress) external {\n        require(isDeployedWorks[msg.sender]);\n\n        uint256 amount = (remainingArgonToken.safeMul(3)).safeDiv(1e5);\n        argonToken.transfer(_approveraddress, amount);\n        remainingArgonToken = remainingArgonToken.safeSub(amount);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library for all arithmetic operations, which guards against integer underflows and overflows."
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract code uses SafeMath library functions for arithmetic operations to prevent overflows."
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code utilizes SafeMath library which mitigates integer underflow and overflow vulnerabilities."
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Timestamp Dependency",
        "check": "FP",
        "response": "Answer: Yes\nDescription: Use of \"now\" for time-dependent operations."
    },
    {
        "code_segment": "contract WorkContract is ApproverRole, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    MainContract deployedFromContract;\n    struct Offer {\n        uint256 offerPrice;\n        address freelancerAddress;\n        string description;\n        string title;\n        uint256 deadline;\n        address offerTokenContract;\n        bool tokenContractIsBNB;\n        bool ArgonShield;\n    }\n\n    string public workTitle;\n    string public workCategory;\n    string public workDescription;\n    string public workAvarageBudget;\n    string public workFilesLink;\n    string public employerCancelDescription;\n    string public approverReport;\n    string public employerRemark;\n\n    uint256 public workCreateTime;\n    uint256 public deadLine;\n    uint256 public freelancerSendFilesDate;\n    uint256 public workStartDate;\n    uint256 public workEndDate;\n    uint256 public approverConfirmStatus;\n    uint256 public approverStartDate;\n    uint256 public workPrice;\n    uint256 public workOfferCount;\n\n    bool public workStatus;\n    bool public isBNB;\n    bool public argonShield;\n    bool public freelancerSendFiles;\n    bool public employerReceiveFiles;\n\n    address public employerAddress;\n    address public approverAddress;\n    address public tokenContractAddress;\n    address public freelancerAddress;\n    address[] public allFreelancerAddress;\n\n    IERC20 public argonToken; // ***ArgonToken Contract***\n    mapping(address => Offer) offers;\n\n    modifier mustActive() {\n        require(deployedFromContract.isActive());\n        _;\n    }\n\n    modifier requireForApprover() {\n        require(approverConfirmStatus == 0 && approverStartDate > 0);\n        require(argonShield);\n        _;\n    }\n\n    constructor(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _employerAddress,\n        address _t\n    ) public {\n        require(MainContract(_t).isActive());\n        require(MainContract(_t).getPersonAccountType(_employerAddress) == 2);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workCreateTime = now;\n        workAvarageBudget = _workAvarageBudget;\n        workOfferCount = 0;\n        workStatus = false;\n        employerAddress = _employerAddress;\n        freelancerSendFiles = false;\n        employerReceiveFiles = false;\n        deployedFromContract = MainContract(_t);\n        argonToken = IERC20(MainContract(_t).argonTokenContractAddress());\n    }\n\n    function getAllFreelancers() external view returns (address[]) {\n        return allFreelancerAddress;\n    }\n\n    function updateWork(\n        string _workTitle,\n        string _workCategory,\n        string _workDescription,\n        string _workAvarageBudget,\n        address _workaddress\n    ) external mustActive {\n        require(this == _workaddress);\n        require(msg.sender == employerAddress);\n        workTitle = _workTitle;\n        workCategory = _workCategory;\n        workDescription = _workDescription;\n        workAvarageBudget = _workAvarageBudget;\n    }\n\n    function createOffer(\n        uint256 _offerPrice,\n        string _description,\n        uint256 _deadline,\n        string _title,\n        address _tokenContract,\n        bool _isBNB,\n        bool _ArgonShield\n    ) external mustActive {\n        require(deployedFromContract.getPersonAccountType(msg.sender) == 0);\n        if (!_isBNB) {\n            require(_tokenContract != address(0));\n            require(deployedFromContract.availableTokens(_tokenContract));\n        }\n        Offer memory newOffer =\n            Offer({\n                offerPrice: _offerPrice,\n                freelancerAddress: msg.sender,\n                description: _description,\n                deadline: _deadline,\n                title: _title,\n                offerTokenContract: _tokenContract,\n                tokenContractIsBNB: _isBNB,\n                ArgonShield: _ArgonShield\n            });\n        offers[msg.sender] = newOffer;\n        allFreelancerAddress.push(msg.sender);\n        workOfferCount++;\n    }\n\n    function deleteOffer() external mustActive {\n        delete offers[msg.sender];\n        workOfferCount--;\n    }\n\n    function updateOffer(\n        uint256 _offerPrice,\n        string _description,\n        string _title,\n        bool _ArgonShield\n    ) external mustActive {\n        Offer storage data = offers[msg.sender];\n        data.offerPrice = _offerPrice;\n        data.description = _description;\n        data.title = _title;\n        data.ArgonShield = _ArgonShield;\n    }\n\n    function getOfferData(address _freelancerAddress)\n        external\n        view\n        returns (\n            uint256,\n            address,\n            string,\n            string,\n            uint256,\n            address,\n            bool,\n            bool\n        )\n    {\n        Offer storage data = offers[_freelancerAddress];\n        return (\n            data.offerPrice,\n            data.freelancerAddress,\n            data.description,\n            data.title,\n            data.deadline,\n            data.offerTokenContract,\n            data.tokenContractIsBNB,\n            data.ArgonShield\n        );\n    }\n\n    function selectOffer(address _freelancerAddress, address _approveraddress)\n        external\n        payable\n        mustActive\n    {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n\n        require(msg.value >= data.offerPrice);\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = true;\n        argonShield = data.ArgonShield;\n    }\n\n    function selectOfferWithToken(\n        address _freelancerAddress,\n        address _approveraddress\n    ) external mustActive {\n        require(msg.sender == employerAddress);\n        Offer storage data = offers[_freelancerAddress];\n        require(!data.tokenContractIsBNB);\n        if (data.ArgonShield) {\n            require(\n                deployedFromContract.approverLockBalances(_approveraddress) >=\n                    deployedFromContract.approverMinArgonLimit()\n            );\n\n            approverAddress = _approveraddress;\n            deployedFromContract.setApproverWorkAddress(this, _approveraddress);\n        }\n        freelancerAddress = data.freelancerAddress;\n        workStatus = true;\n        workStartDate = now;\n        deadLine = data.deadline;\n        workPrice = data.offerPrice;\n        isBNB = false;\n        tokenContractAddress = data.offerTokenContract;\n        require(\n            IERC20(data.offerTokenContract).transferFrom(\n                msg.sender,\n                address(this),\n                data.offerPrice\n            )\n        );\n        argonShield = data.ArgonShield;\n    }\n\n    function freelancerSendFile(string _workFilesLink) external {\n        require(msg.sender == freelancerAddress);\n        require(!freelancerSendFiles);\n        freelancerSendFiles = true;\n        workFilesLink = _workFilesLink;\n        freelancerSendFilesDate = now;\n    }\n\n    function _payFreelancer() private {\n        uint256 amount;\n\n        if (isBNB) {\n            amount = workPrice.safeSub(\n                (workPrice.safeMul(deployedFromContract.bnbFeeRate())).safeDiv(\n                    1e6\n                )\n            );\n            freelancerAddress.transfer(amount);\n            deployedFromContract.feeAddress().transfer(\n                workPrice.safeSub(amount)\n            );\n        } else {\n            amount = workPrice.safeSub(\n                (\n                    workPrice.safeMul(\n                        deployedFromContract.feeRates(tokenContractAddress)\n                    )\n                )\n                    .safeDiv(1e6)\n            );\n\n            IERC20(tokenContractAddress).transfer(freelancerAddress, amount);\n            IERC20(tokenContractAddress).transfer(\n                deployedFromContract.feeAddress(),\n                workPrice.safeSub(amount)\n            );\n        }\n    }\n\n    function _payEmployer() private {\n        if (isBNB) {\n            employerAddress.transfer(workPrice);\n        } else {\n            IERC20(tokenContractAddress).transfer(employerAddress, workPrice);\n        }\n    }\n\n    function employerReceiveFile(uint256 _puan, string _remark)\n        external\n        nonReentrant\n    {\n        require(msg.sender == employerAddress);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n        require(!employerReceiveFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(_puan, freelancerAddress);\n        employerRemark = _remark;\n        employerReceiveFiles = true;\n        workEndDate = now;\n    }\n\n    function employerCancel(string _depscription) external {\n        require(msg.sender == employerAddress);\n        require(argonShield);\n        require(approverStartDate == 0);\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles, \"freelancer must be sent files\");\n\n        approverConfirmStatus = 0;\n        employerCancelDescription = _depscription;\n        approverStartDate = now;\n    }\n\n    function confirmApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n\n        approverConfirmStatus = 1;\n        _payFreelancer();\n        approverReport = _description;\n        workEndDate = now;\n    }\n\n    function cancelApprover(string _description)\n        external\n        nonReentrant\n        requireForApprover\n    {\n        if (now > approverStartDate.safeAdd(5 days)) {\n            require(isApprover(msg.sender));\n        } else {\n            require(msg.sender == approverAddress);\n            deployedFromContract.deleteApproverWorkAddress(\n                this,\n                approverAddress\n            );\n            deployedFromContract.sendApproverArgonCoin(approverAddress);\n        }\n        approverConfirmStatus = 2;\n        approverReport = _description;\n        _payEmployer();\n    }\n\n    function autoConfirm() external nonReentrant {\n        require(now > freelancerSendFilesDate.safeAdd(5 days));\n        require(!employerReceiveFiles);\n        require(freelancerSendFiles);\n        _payFreelancer();\n        deployedFromContract.setPuan(5, freelancerAddress);\n        employerRemark = \"Auto Confirmed By Smart Contract\";\n        workEndDate = now;\n    }\n\n    function sendDeadline() external nonReentrant {\n        require(now > deadLine);\n        require(!freelancerSendFiles);\n        _payEmployer();\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Hacken-Argon Foundation/platform-contracts-8996d21499ede3f2eb36320ded9563f5467a0fa6/ArgonFreelancers.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not seem to manipulate state variables or the sequence of transactions in a way that would give advantages based on transaction order. Thus, there's no clear TOD vulnerability."
    },
    {
        "code_segment": "library SafeMathLib {\n\n  function times(uint a, uint b) returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function minus(uint a, uint b) returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function plus(uint a, uint b) returns (uint) {\n    uint c = a + b;\n    assert(c>=a);\n    return c;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Security Audit for Patientory (PTOY) Token ICO/smart-contracts-master/contracts/SafeMathLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses assertions to prevent integer overflow in all arithmetic functions."
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code uses simple addition operations such as `giver.kudosGiven += kudos;` and `project.kudosTotal += kudos;` without checking for overflow conditions. This can potentially lead to integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract ProjectKudos {\n    \n    // votes limit for judge\n    uint KUDOS_LIMIT_JUDGE = 1000;\n\n    // votes limit for regular user\n    uint KUDOS_LIMIT_USER  = 10;\n\n    // enumerates reasons \n    // which additional votes can be granted for\n    enum GrantReason {\n        Facebook,\n        Twitter, \n        Fake\n    }\n//    SWC-135-Code With No Effects:L20-24,281-303,313-320\n    // keeps project votes data\n    struct ProjectInfo {\n        mapping(address => uint) kudosByUser;\n        uint kudosTotal;\n    }\n\n    // keeps user votes data\n    struct UserInfo {\n        uint kudosLimit;\n        uint kudosGiven;\n        bool isJudge;\n        mapping(uint => bool) grant;\n    }\n\n    // keeps links between user's votes \n    // and projects he voted for\n    struct UserIndex {\n        bytes32[] projects;\n        uint[] kudos;\n        mapping(bytes32 => uint) kudosIdx;\n    }\n    \n    // keeps time frames for vote period \n    struct VotePeriod {\n        uint start;\n        uint end;\n    }\n    \n    // contract creator's address\n    address owner;\n    \n    // vote period\n    VotePeriod votePeriod;\n\n    // user votes mapping\n    mapping(address => UserInfo) users;\n\n    // user index, \n    // helps to get votes given by one user for every project\n    mapping(address => UserIndex) usersIndex;\n\n    // project votes mapping\n    mapping(bytes32 => ProjectInfo) projects;\n    \n    // emitted when vote is done\n    event Vote(\n        // address of voter\n        address indexed voter,\n        // sha3 of project code\n        bytes32 indexed projectCode,\n        // votes given\n        uint indexed count\n    );\n    \n    /**\n     * @dev Contract's constructor.\n     * Stores contract's owner and sets up vote period\n     */\n    function ProjectKudos() {\n        \n        owner = msg.sender;\n        \n        votePeriod = VotePeriod(\n            1479996000,     // GMT: 24-Nov-2016 14:00, Voting starts, 1st week passed\n            1482415200      // GMT: 22-Dec-2016 14:00, Voting ends, Hackathon ends\n        );\n    }\n\n    /**\n     * @dev Registers voter to the event.\n     * Executable only by contract's owner.\n     *\n     * @param userAddres address of the user to register\n     * @param isJudge should be true if user is judge, false otherwise\n     */\n    function register(address userAddres, bool isJudge) onlyOwner {\n                            \n        UserInfo user = users[userAddres];\n\n        if (user.kudosLimit > 0) throw;\n\n        if (isJudge)\n            user.kudosLimit = KUDOS_LIMIT_JUDGE;\n        else \n            user.kudosLimit = KUDOS_LIMIT_USER;\n        \n        user.isJudge = isJudge;\n        \n        users[userAddres] = user;\n    }\n    \n    /**\n     *  @dev Gives votes to the project.\n     *  Can only be executed within vote period.\n     *  User signed the Tx becomes votes giver.\n     *\n     *  @param projectCode code of the project, must be less than or equal to 32 bytes\n     *  @param kudos - votes to be given\n     */\n    function giveKudos(string projectCode, uint kudos) duringVote {\n        \n        UserInfo giver = users[msg.sender];\n\n        if (giver.kudosGiven + kudos > giver.kudosLimit) throw;\n        \n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n\n        giver.kudosGiven += kudos;\n        project.kudosTotal += kudos;\n        project.kudosByUser[msg.sender] += kudos;\n\n        // save index of user voting history\n        updateUsersIndex(code, project.kudosByUser[msg.sender]);\n        \n        Vote(msg.sender, sha3(projectCode), kudos);\n    }\n\n    /**\n     * @dev Grants extra kudos for identity proof.\n     *\n     * @param userToGrant address of user to grant additional \n     * votes for social proof\n     * \n     * @param reason granting reason, \n     * possible reasons are listed in GrantReason enum\n     */         \n    function grantKudos(address userToGrant, uint reason) onlyOwner {\n    \n        UserInfo user = users[userToGrant];\n    \n        GrantReason grantReason = grantUintToReason(reason);\n        \n        if (grantReason != GrantReason.Facebook &&\n            grantReason != GrantReason.Twitter) throw;\n    \n        // if user is judge his identity is known\n        // not reasonble to grant more kudos for social \n        // proof.\n        if (user.isJudge) throw;\n        \n        // if not granted for that reason yet\n        if (user.grant[reason]) throw;\n        \n        // grant 100 votes\n        user.kudosLimit += 100;\n        \n        // mark reason \n        user.grant[reason] = true;\n    }\n    \n    \n    // ********************* //\n    // *   Constant Calls  * //\n    // ********************* //\n    \n    /**\n     * @dev Returns total votes given to the project\n     * \n     * @param projectCode project's code\n     * \n     * @return number of give votes\n     */\n    function getProjectKudos(string projectCode) constant returns(uint) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        return project.kudosTotal;\n    }\n\n    /**\n     * @dev Returns an array of votes given to the project\n     * corresponding to array of users passed in function call\n     * \n     * @param projectCode project's code\n     * @param users array of user addresses\n     * \n     * @return array of votes given by passed users\n     */\n    function getProjectKudosByUsers(string projectCode, address[] users) constant returns(uint[]) {\n        bytes32 code = strToBytes(projectCode);\n        ProjectInfo project = projects[code];\n        mapping(address => uint) kudosByUser = project.kudosByUser;\n        uint[] memory userKudos = new uint[](users.length);\n        for (uint i = 0; i < users.length; i++) {\n            userKudos[i] = kudosByUser[users[i]];    \n       }\n       \n       return userKudos;\n    }\n\n    /**\n     * @dev Returns votes given by speicified user \n     * to the list of projects ever voted by that user\n     * \n     * @param giver user's address\n     * @return projects array of project codes represented by bytes32 array\n     * @return kudos array of votes given by user, \n     *         index of vote corresponds to index of project from projects array\n     */\n    function getKudosPerProject(address giver) constant returns (bytes32[] projects, uint[] kudos) {\n        UserIndex idx = usersIndex[giver];\n        projects = idx.projects;\n        kudos = idx.kudos;\n    }\n\n    /**\n     * @dev Returns votes allowed to be given by user\n     * \n     * @param addr user's address\n     * @return number of votes left\n     */\n    function getKudosLeft(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosLimit - user.kudosGiven;\n    }\n\n    /**\n     * @dev Returns votes given by user\n     * \n     * @param addr user's address\n     * @return number of votes given\n     */\n    function getKudosGiven(address addr) constant returns(uint) {\n        UserInfo user = users[addr];\n        return user.kudosGiven;\n    }\n\n   \n    // ********************* //\n    // *   Private Calls   * //\n    // ********************* //\n    \n    /**\n     * @dev Private function. Updates users index\n     * \n     * @param code project code represented by bytes32 array\n     * @param kudos votes total given to the project by sender\n     */\n    function updateUsersIndex(bytes32 code, uint kudos) private {\n        \n        UserIndex idx = usersIndex[msg.sender];\n        uint i = idx.kudosIdx[code];\n        \n        // add new entry to index\n        if (i == 0) {\n            i = idx.projects.length + 1;\n            idx.projects.length += 1;\n            idx.kudos.length += 1;\n            idx.projects[i - 1] = code;\n            idx.kudosIdx[code] = i;\n        }\n\n        idx.kudos[i - 1] = kudos;\n    }\n    \n    /**\n     * @dev Translates GrantReason code to GrantReason\n     * \n     * @param reason the code of the reason\n     * @return GrantReason corresponding to the code\n     */\n    function grantUintToReason(uint reason) private returns (GrantReason result) {\n        if (reason == 0)  return GrantReason.Facebook;\n        if (reason == 1)  return GrantReason.Twitter;\n        return GrantReason.Fake;\n    }\n    \n    /**\n     * @dev Translates GrantReason to its code\n     * \n     * @param reason GrantReason instance\n     * @return corresponding reason code\n     */\n    function grantReasonToUint(GrantReason reason) private returns (uint result) {\n        if (reason == GrantReason.Facebook) return 0;\n        if (reason == GrantReason.Twitter)  return 1;\n        return 3;\n    }\n    \n    /**\n     * @dev Low level function.\n     * Converts string to bytes32 array.\n     * Throws if string length is more than 32 bytes\n     * \n     * @param str string\n     * @return bytes32 representation of str\n     */\n    function strToBytes(string str) private returns (bytes32 ret) {\n        \n        if (bytes(str).length > 32) throw;\n        \n        assembly {\n            ret := mload(add(str, 32))\n        }\n    } \n\n    \n    // ********************* //\n    // *     Modifiers     * //\n    // ********************* //\n//    SWC-135-Code With No Effects:L330-334\n    /**\n     * @dev Throws if called not during the vote period\n     */\n    modifier duringVote() {\n        if (now < votePeriod.start) throw;\n        if (now >= votePeriod.end) throw;\n        _;\n    }\n//    SWC-116-Block values as a proxy for time:L331,332\n    /**\n     * @dev Throws if called not by contract's owner\n     */\n    modifier onlyOwner() { \n        if (msg.sender != owner) throw;\n        _;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-EtherCamp_ProjectKudos_public_code/virtual-accelerator-6665fdd4b71088443a74d1ed9fda52c6a8c8b975/ProjectKudos.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: Solidity versions 0.4.0 and above include implicit overflow and underflow checks for arithmetic operations, and there are no unchecked arithmetic operations in the given code."
    },
    {
        "code_segment": "contract KOK_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"KOK\";\n\tstring public constant name = \"KOK Coin\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 5000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n// SWC-118-Incorrect Constructor Name: L63\n\tfunction KOKContract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L88\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L92\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-KOK Token Smart Contract Audit/ERC-20-55a501fde12e782b99fe9d5756388c0de82f45ba/contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract does not use SafeMath functions to perform arithmetic operations on uint256 variables, making it susceptible to integer overflow."
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The contract contains unchecked arithmetic operations in the `multiMint` and `lastMint` functions, leading to potential integer overflows. Specifically, the lack of safe arithmetic operations in lines like `total += amounts[i]` and `totalSupply += remaining`."
    },
    {
        "code_segment": "contract DTT {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 6; // Makes JavaScript able to handle precise calculations (until totalSupply < 9 milliards)\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => mapping(uint => bool)) public usedSigIds; // Used in *ViaSignature(..)\n    address public tokenDistributor; // Account authorized to distribute tokens only during the token distribution event\n    address public rescueAccount; // Account authorized to withdraw tokens accidentally sent to this contract\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    bytes public ethSignedMessagePrefix = \"\\x19Ethereum Signed Message:\\n\";\n    enum sigStandard { typed, personal, stringHex }\n    enum sigDestination { transfer, approve, approveAndCall, transferFrom }\n    bytes32 public sigDestinationTransfer = keccak256(\n        \"address Token Contract Address\",\n        \"address Sender's Address\",\n        \"address Recipient's Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferViaSignature`: keccak256(address(this), from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationTransferFrom = keccak256(\n        \"address Token Contract Address\",\n        \"address Address Approved for Withdraw\",\n        \"address Account to Withdraw From\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `transferFromViaSignature`: keccak256(address(this), signer, from, to, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApprove = keccak256(\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveViaSignature`: keccak256(address(this), from, spender, value, fee, deadline, sigId)\n    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`\n        \"address Token Contract Address\",\n        \"address Withdrawal Approval Address\",\n        \"address Withdrawal Recipient Address\",\n        \"uint256 Amount to Transfer (last six digits are decimals)\",\n        \"bytes Data to Transfer\",\n        \"uint256 Fee in Tokens Paid to Executor (last six digits are decimals)\",\n        \"uint256 Signature Expiration Timestamp (unix timestamp)\",\n        \"uint256 Signature ID\"\n    ); // `approveAndCallViaSignature`: keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId)\n\n    constructor (string tokenName, string tokenSymbol) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n        rescueAccount = tokenDistributor = msg.sender;\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value` tokens `from` -> `to`. Throws if transfer is impossible.\n     */\n    function internalTransfer (address from, address to, uint value) internal {\n        // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n        require(to != 0x0 && balanceOf[from] >= value && balanceOf[to] + value >= balanceOf[to]);\n        balanceOf[from] -= value;\n        balanceOf[to] += value;\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * Utility internal function used to safely transfer `value1` tokens `from` -> `to1`, and `value2` tokens\n     * `from` -> `to2`, minimizing gas usage (calling `internalTransfer` twice is more expensive). Throws if\n     * transfers are impossible.\n     */\n    function internalDoubleTransfer (address from, address to1, uint value1, address to2, uint value2) internal {\n        require( // Prevent people from accidentally burning their tokens + uint256 wrap prevention\n            to1 != 0x0 && to2 != 0x0 && value1 + value2 >= value1 && balanceOf[from] >= value1 + value2\n            && balanceOf[to1] + value1 >= balanceOf[to1] && balanceOf[to2] + value2 >= balanceOf[to2]\n        );\n        balanceOf[from] -= value1 + value2;\n        balanceOf[to1] += value1;\n        emit Transfer(from, to1, value1);\n        if (value2 > 0) {\n            balanceOf[to2] += value2;\n            emit Transfer(from, to2, value2);\n        }\n    }\n\n    /**\n     * Internal method that makes sure that the given signature corresponds to a given data and is made by `signer`.\n     * It utilizes three (four) standards of message signing in Ethereum, as at the moment of this smart contract\n     * development there is no single signing standard defined. For example, Metamask and Geth both support\n     * personal_sign standard, SignTypedData is only supported by Matamask, Trezor does not support \"widely adopted\"\n     * Ethereum personal_sign but rather personal_sign with fixed prefix and so on.\n     * Note that it is always possible to forge any of these signatures using the private key, the problem is that\n     * third-party wallets must adopt a single standard for signing messages.\n     */\n    function requireSignature (\n        bytes32 data, address signer, uint256 deadline, uint256 sigId, bytes sig, sigStandard std, sigDestination signDest\n    ) internal {\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        assembly { // solium-disable-line security/no-inline-assembly\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27)\n            v += 27;\n        require(block.timestamp <= deadline && !usedSigIds[signer][sigId]); // solium-disable-line security/no-block-members\n        if (std == sigStandard.typed) { // Typed signature. This is the most likely scenario to be used and accepted\n            require(\n                signer == ecrecover(\n                    keccak256(\n                        signDest == sigDestination.transfer\n                            ? sigDestinationTransfer\n                            : signDest == sigDestination.approve\n                                ? sigDestinationApprove\n                                : signDest == sigDestination.approveAndCall\n                                    ? sigDestinationApproveAndCall\n                                    : sigDestinationTransferFrom,\n                        data\n                    ),\n                    v, r, s\n                )\n            );\n        } else if (std == sigStandard.personal) { // Ethereum signed message signature (Geth and Trezor)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"32\", data), v, r, s) // Geth-adopted\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x20\", data), v, r, s) // Trezor-adopted\n            );\n        } else { // == 2; Signed string hash signature (the most expensive but universal)\n            require(\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"64\", hexToString(data)), v, r, s) // Geth\n                ||\n                signer == ecrecover(keccak256(ethSignedMessagePrefix, \"\\x40\", hexToString(data)), v, r, s) // Trezor\n            );\n        }\n        usedSigIds[signer][sigId] = true;\n    }\n\n    /**\n     * Utility costly function to encode bytes HEX representation as string.\n     * @param sig - signature to encode.\n     */\n    function hexToString (bytes32 sig) internal pure returns (bytes) { // /to-try/ convert to two uint256 and test gas\n        bytes memory str = new bytes(64);\n        for (uint8 i = 0; i < 32; ++i) {\n            str[2 * i] = byte((uint8(sig[i]) / 16 < 10 ? 48 : 87) + uint8(sig[i]) / 16);\n            str[2 * i + 1] = byte((uint8(sig[i]) % 16 < 10 ? 48 : 87) + (uint8(sig[i]) % 16));\n        }\n        return str;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the account of sender.\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transfer (address to, uint256 value) public returns (bool) {\n        internalTransfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * This function distincts transaction signer from transaction executor. It allows anyone to transfer tokens\n     * from the `from` account by providing a valid signature, which can only be obtained from the `from` account\n     * owner.\n     * Note that passed parameter sigId is unique and cannot be passed twice (prevents replay attacks). When there's\n     * a need to make signature once again (because the first on is lost or whatever), user should sign the message\n     * with the same sigId, thus ensuring that the previous signature won't be used if the new one passes.\n     * Use case: the user wants to send some tokens to other user or smart contract, but don't have ether to do so.\n     * @param from - the account giving its signature to transfer `value` tokens to `to` address\n     * @param to - the account receiving `value` tokens\n     * @param value - the value in tokens to transfer\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitly tell which standard they use\n     */\n    function transferViaSignature (\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, to, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.transfer\n        );\n        internalDoubleTransfer(from, to, value, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Allow `spender` to take `value` tokens from the transaction sender's account.\n     * Beware that changing an allowance with this method brings the risk that `spender` may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender - the address authorized to spend\n     * @param value - the maximum amount they can spend\n     */\n    function approve (address spender, uint256 value) public returns (bool) {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `approve`.\n     * Use case: the user wants to set an allowance for the smart contract or another user without having ether on their\n     * balance.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address\n     * @param value - the value in tokens to approve to withdraw\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approve\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Transfer `value` tokens to `to` address from the `from` account, using the previously set allowance.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFrom (address from, address to, uint256 value) public returns (bool) {\n        require(value <= allowance[from][msg.sender]); // Test whether allowance was set\n        allowance[from][msg.sender] -= value;\n        internalTransfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * Same as `transferViaSignature`, but for `transferFrom`.\n     * Use case: the user wants to withdraw tokens from a smart contract or another user who allowed the user to do so.\n     * Important note: fee is subtracted from `value` before it reaches `to`.\n     * @param from - the address to transfer tokens from\n     * @param to - the address of the recipient\n     * @param value - the amount to send\n     */\n    function transferFromViaSignature (\n        address     signer,\n        address     from,\n        address     to,\n        uint256     value,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),\n            signer, deadline, sigId, sig, sigStd, sigDestination.transferFrom\n        );\n        require(value <= allowance[from][signer] && value >= fee);\n        allowance[from][signer] -= value;\n        internalDoubleTransfer(from, to, value - fee, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * Utility function, which acts the same as approve(...) does, but also calls `receiveApproval` function on a\n     * `spender` address, which is usually the address of the smart contract. In the same call, smart contract can\n     * withdraw tokens from the sender's account and receive additional `extraData` for processing.\n     * @param spender - the address to be authorized to spend tokens\n     * @param value - the max amount the `spender` can withdraw\n     * @param extraData - some extra information to send to the approved contract\n     */\n    function approveAndCall (address spender, uint256 value, bytes extraData) public returns (bool) {\n        approve(spender, value);\n        tokenRecipient(spender).receiveApproval(msg.sender, value, this, extraData);\n        return true;\n    }\n\n    /**\n     * Same as `approveViaSignature`, but for `approveAndCall`.\n     * Use case: the user wants to send tokens to the smart contract and pass additional data within one transaction.\n     * @param from - the account to approve withdrawal from, which signed all below parameters\n     * @param spender - the account allowed to withdraw tokens from `from` address (in this case, smart contract only)\n     * @param value - the value in tokens to approve to withdraw\n     * @param extraData - additional data to pass to the `spender` smart contract\n     * @param fee - a fee to pay to transaction executor (`msg.sender`)\n     * @param deadline - until when the signature is valid\n     * @param sigId - signature unique ID. Signatures made with the same signature ID cannot be submitted twice\n     * @param sig - signature made by `from`, which is the proof of `from`'s agreement with the above parameters\n     * @param sigStd - chosen standard for signature validation. The signer must explicitely tell which standard they use\n     */\n    function approveAndCallViaSignature (\n        address     from,\n        address     spender,\n        uint256     value,\n        bytes       extraData,\n        uint256     fee,\n        uint256     deadline,\n        uint256     sigId,\n        bytes       sig,\n        sigStandard sigStd\n    ) external returns (bool) {\n        requireSignature(\n            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),\n            from, deadline, sigId, sig, sigStd, sigDestination.approveAndCall\n        );\n        allowance[from][spender] = value;\n        emit Approval(from, spender, value);\n        tokenRecipient(spender).receiveApproval(from, value, this, extraData);\n        internalTransfer(from, msg.sender, fee);\n        return true;\n    }\n\n    /**\n     * `tokenDistributor` is authorized to distribute tokens to the parties who participated in the token sale by the\n     * time the `lastMint` function is triggered, which closes the ability to mint any new tokens forever.\n     * @param recipients - Addresses of token recipients\n     * @param amounts - Corresponding amount of each token recipient in `recipients`\n     */\n    function multiMint (address[] recipients, uint256[] amounts) external {\n        \n        // Once the token distribution ends, tokenDistributor will become 0x0 and multiMint will never work\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && recipients.length == amounts.length);\n\n        uint total = 0;\n        // SWC-101-Integer Overflow and Underflow: L375-376\n        for (uint i = 0; i < recipients.length; ++i) {\n            balanceOf[recipients[i]] += amounts[i];\n            total += amounts[i];\n            emit Transfer(0x0, recipients[i], amounts[i]);\n        }\n\n        totalSupply += total;\n        \n    }\n\n    /**\n     * The last mint that will ever happen. Disables the multiMint function and mints remaining 40% of tokens (in\n     * regard of 60% tokens minted before) to a `tokenDistributor` address.\n     */\n    function lastMint () external {\n\n        require(tokenDistributor != 0x0 && tokenDistributor == msg.sender && totalSupply > 0);\n\n        uint256 remaining = totalSupply * 40 / 60; // Portion of tokens for DreamTeam (40%)\n        // SWC-101-Integer Overflow and Underflow: L399\n        // To make the total supply rounded (no fractional part), subtract the fractional part from DreamTeam's balance\n        uint256 fractionalPart = (remaining + totalSupply) % (uint256(10) ** decimals);\n        if (fractionalPart <= remaining)\n            remaining -= fractionalPart; // Remove the fractional part to round the totalSupply\n\n        balanceOf[tokenDistributor] += remaining;\n        emit Transfer(0x0, tokenDistributor, remaining);\n\n        totalSupply += remaining;\n        tokenDistributor = 0x0; // Disable multiMint and lastMint functions forever\n\n    }\n\n    /**\n     * ERC20 token is not designed to hold any tokens itself. This function allows to rescue tokens accidentally sent\n     * to the address of this smart contract.\n     * @param tokenContract - ERC-20 compatible token\n     * @param value - amount to rescue\n     */\n    function rescueTokens (DTT tokenContract, uint256 value) public {\n        require(msg.sender == rescueAccount);\n        tokenContract.approve(rescueAccount, value);\n    }\n\n    /**\n     * Utility function that allows to change the rescueAccount address.\n     * @param newRescueAccount - account which will be authorized to rescue tokens.\n     */\n    function changeRescueAccount (address newRescueAccount) public {\n        require(msg.sender == rescueAccount);\n        rescueAccount = newRescueAccount;\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DreamTeam Token Audit/smart-contracts-616ed2538526001d25b75680e4d3bd8f3c4deac2/contracts/token/DTT.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The internalTransfer and internalDoubleTransfer functions directly subtract `value` from `balanceOf[from]`. If `balanceOf[from]` is less than `value`, arithmetic underflow will occur, potentially causing a vulnerability."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library for all arithmetic operations, which prevents integer overflow and underflow."
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n// SWC-101-Integer Overflow and Underflow: L225\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses safe practices when defining `INITIAL_SUPPLY` and does not perform any arithmetic operations that could lead to integer overflow. The constant initialization does not involve user input or dynamic operations; thus, there is no risk of overflow in the provided segment."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-FIN/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath library's sub and add functions, which handle integer overflow and underflow."
    },
    {
        "code_segment": "contract TMC_Contract is ERC20Interface, Owned {\n\tstring public constant symbol = \"TMC\";\n\tstring public constant name = \"TMC Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 500000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction TMC_Contract() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L86\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L90\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-TMC Token Smart Contract Audit/ERC20-Contract-b923cde02d2fd928760cc1e810410c2064fe1530/ERC20_Contract.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses safe checks on balance manipulations that prevent overflow issues."
    },
    {
        "code_segment": "contract DescendingPriceCryptoKittyAuction is DescendingPriceAuction, CryptoKittyAuction {\n  constructor(address _cryptoKittyAddress) CryptoKittyAuction(_cryptoKittyAddress) public { }\n\n  /**\n  * @notice Creates and starts an auction with the given pricing and asset information.\n  * @dev Composes the setup for the DescendingPriceAuction, CryptoKittyAuction and AuctionBase.\n  */\n  function createAuction(uint256 startPrice, uint256 priceFloor, uint256 duration, uint256 kittyId) whenNotPaused public payable returns (uint256) {\n    uint256 auctionId = createEmptyAuction();\n    setAuctionPricing(startPrice, priceFloor, duration, auctionId);\n    setAuctionAsset(kittyId, auctionId);\n    return auctionId;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-AUX Platform Security Audit/auction-contracts-0da231969b7f791cb1c131956b3f8886f860617b/DescendingPriceCryptoKitty.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The contract is potentially vulnerable to Transaction-Ordering Dependence (TOD) because the auction creation logic may be exploited if miners or bots can influence the transaction ordering to manipulate auction outcomes in their favor."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) public balances;\n\n    uint256 public totalSupply_;\n\n    /**\n    * @dev Total number of tokens in existence\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    /**\n    * @dev Transfer token for a specified address\n    * @param _to The address to transfer to.\n    * @param _value The amount to be transferred.\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender]);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library functions `sub` and `add` for mathematical operations, which protect against integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract BeamToken is MintableToken {\n\n    string public constant name = \"Beams\"; // solium-disable-line uppercase\n    string public constant symbol = \"BEAM\"; // solBeamCrowdsaleContractium-disable-line uppercase\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\n\n    mapping (address => bool) public isLocked;\n\n    uint256 public constant INITIAL_SUPPLY = 0;\n\n    constructor() public {\n        totalSupply_ = INITIAL_SUPPLY;\n    }\n\n    function setLock(address _who, bool _lock) public onlyOwner {\n        require(isLocked[_who] != _lock);\n        isLocked[_who] = _lock;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the caller is not in locklist.\n     */\n    modifier whenNotLocked() {\n        require(!isLocked[msg.sender]);\n        _;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotLocked\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotLocked\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code relies on the parent class (MintableToken) for arithmetic operations like transfers and approvals, which are assumed to properly handle integer overflows, thus no direct integer operations susceptible to overflow are present in the provided code."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n    event Mint(address indexed to, uint256 amount);\n    event MintFinished();\n\n    bool public mintingFinished = false;\n\n    modifier canMint() {\n        require(!mintingFinished);\n        _;\n    }\n\n    /**\n     * @dev Function to mint tokens\n     * @param _to The address that will receive the minted tokens.\n     * @param _amount The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(\n        address _to,\n        uint256 _amount\n    )\n        public\n        onlyManager\n        canMint\n        returns (bool)\n    {\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n        return true;\n    }\n\n  /**\n   * @dev Function to stop minting new tokens.\n   * @return True if the operation was successful.\n   */\n    function finishMinting() public onlyOwner canMint  returns (bool) {\n        mintingFinished = true;\n        emit MintFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The add operation on `totalSupply_` and `balances[_to]` can cause an integer overflow without using SafeMath functions."
    },
    {
        "code_segment": "contract Pausable is Whitelist {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n    modifier whenNotPaused() {\n        require((!paused) || (whitelist[msg.sender]));\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused {\n        paused = true;\n        emit Pause();\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused {\n        paused = false;\n        emit Unpause();\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: There are no arithmetic operations that could result in an integer overflow."
    },
    {
        "code_segment": "contract PausableToken is StandardToken, Pausable {\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        whenNotPaused\n        returns (bool)\n    {\n        return super.approve(_spender, _value);\n    }\n\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.increaseApproval(_spender, _addedValue);\n    }\n\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        whenNotPaused\n        returns (bool success)\n    {\n        return super.decreaseApproval(_spender, _subtractedValue);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform arithmetic operations on user inputs directly without checks, and inherits functionality from `StandardToken`, which likely contains safeguards against integer overflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param _from address The address which you want to send tokens from\n     * @param _to address The address which you want to transfer to\n     * @param _value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        returns (bool)\n    {\n        require(_to != address(0));\n        require(_value <= balances[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * @param _spender The address which will spend the funds.\n    * @param _value The amount of tokens to be spent.\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\n    * @param _owner address The address which owns the funds.\n    * @param _spender address The address which will spend the funds.\n    * @return A uint256 specifying the amount of tokens still available for the spender.\n    */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To increment\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _addedValue The amount of tokens to increase the allowance by.\n    */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n        public\n        returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n        allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\n    * approve should be called when allowed[_spender] == 0. To decrement\n    * allowed value is better to use this function to avoid 2 calls (and wait until\n    * the first transaction is mined)\n    * From MonolithDAO Token.sol\n    * @param _spender The address which will spend the funds.\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\n    */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n        public\n        returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath library functions (add and sub), which protect against integer overflows and underflows."
    },
    {
        "code_segment": "contract Whitelist is Ownable {\n    mapping(address => bool) public whitelist;\n\n    event WhitelistedAddressAdded(address addr);\n    event WhitelistedAddressRemoved(address addr);\n\n    /**\n     * @dev Throws if called by any account that's not whitelisted.\n     */\n    modifier onlyWhitelisted() {\n        require(whitelist[msg.sender]);\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param addr address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (!whitelist[addr]) {\n            whitelist[addr] = true;\n            emit WhitelistedAddressAdded(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was added to the whitelist,\n     * false if all addresses were already in the whitelist\n     */\n    function addAddressesToWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (addAddressToWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n    /**\n     * @dev remove an address from the whitelist\n     * @param addr address\n     * @return true if the address was removed from the whitelist,\n     * false if the address wasn't in the whitelist in the first place\n     */\n    function removeAddressFromWhitelist(address addr) public onlyOwner returns(bool success) {\n        if (whitelist[addr]) {\n            whitelist[addr] = false;\n            emit WhitelistedAddressRemoved(addr);\n            success = true;\n        }\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param addrs addresses\n     * @return true if at least one address was removed from the whitelist,\n     * false if all addresses weren't in the whitelist in the first place\n     */\n    function removeAddressesFromWhitelist(address[] addrs) public onlyOwner returns(bool success) {\n        for (uint256 i = 0; i < addrs.length; i++) {\n            if (removeAddressFromWhitelist(addrs[i])) {\n                success = true;\n            }\n        }\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Beam/beam-11b086ca757f1612cd67c1bf6d7ab470591676b1/contracts/BeamToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not involve any arithmetic operations that could result in an integer overflow."
    },
    {
        "code_segment": "contract Bitpara is BurnableToken {\n\n    /**\n     * @dev It will transfer to owner a specific amount of tokens.\n     * @param _value The amount of token to be transferred.\n     */\n\n  function transferToOwner(address _from, uint256 _value) onlyOwner public returns (bool) {\n    balances[_from] = balances[_from].sub(_value);\n    balances[owner] = balances[owner].add(_value);\n    Transfer(_from, owner, _value);\n    return true;\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library methods 'sub' and 'add' which mitigate the risk of integer overflow and underflow."
    },
    {
        "code_segment": "contract BurnableToken is MintableToken {\n\n    event Burn(address indexed owner, uint256 _value);\n    \n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param _value The amount of token to be burned.\n     */\n     \n    function burn(uint256 _value) onlyOwner public returns (bool) {\n        require(_value > 0);\n        balances[owner] = balances[owner].sub(_value);\n        tokensIssuedTotal = tokensIssuedTotal.sub(_value);\n        Burn(owner, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's sub function, which prevents integer overflow."
    },
    {
        "code_segment": "contract MintableToken is PausableToken {\n   event Mint(address indexed owner, uint _amount);\n\n  /**\n   * @dev Function to mint tokens\n   * @return A boolean that indicates if the operation was successful.\n   */\n   \n   \n  function mint(uint256 _amount) onlyOwner public returns (bool) {\n    tokensIssuedTotal = tokensIssuedTotal.add(_amount);\n    balances[owner] = balances[owner].add(_amount);\n    Mint(owner, _amount);\n    Transfer(0, owner, _amount);\n    return true;\n  }\n  \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-Bitpara Smart Contract Audit/bitpara-master/bitpara.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code directly adds the amount to `tokensIssuedTotal` and `balances[owner]` without any checks, which can cause an integer overflow."
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform arithmetic operations where integer overflow can occur."
    },
    {
        "code_segment": "contract DMToken is Vesting {\n\n    string public name = \"DMarket Token\";\n    string public symbol = \"DMT\";\n    uint256 public decimals = 8;\n\n    function DMToken() public {\n        hardCap = 15644283100000000;\n    }\n\n    function multiTransfer(address[] recipients, uint256[] amounts) public {\n        require(recipients.length == amounts.length);\n        for (uint i = 0; i < recipients.length; i++) {\n            transfer(recipients[i], amounts[i]);\n        }\n    }\n\n    function multiVesting(\n        address[] _address,\n        uint256[] _amount,\n        uint256[] _start,\n        uint256[] _end\n    ) public onlyOwner {\n        require(\n            _address.length == _amount.length &&\n            _address.length == _start.length &&\n            _address.length == _end.length\n        );\n        for (uint i = 0; i < _address.length; i++) {\n            addVestingMember(_address[i], _amount[i], _start[i], _end[i]);\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not involve any arithmetic operations where integer underflow can occur."
    },
    {
        "code_segment": "contract Vesting is MintableToken {\n\n    event VestingMemberAdded(address indexed _address, uint256 _amount, uint _start, uint _end);\n\n    struct _Vesting {\n        uint256 totalSum;     //total amount\n        uint256 start;        //start block\n        uint256 end;          //end block\n        uint256 usedAmount;   //the amount of paid payments\n    }\n\n    mapping (address => _Vesting ) public vestingMembers;\n\n    function addVestingMember(\n        address _address,\n        uint256 _amount,\n        uint256 _start,\n        uint256 _end\n    ) onlyOwner public returns (bool) {\n        require(\n            _address != address(0) &&\n            _amount > 0 &&\n            _start < _end &&\n            vestingMembers[_address].totalSum == 0 &&\n            balances[msg.sender] > _amount\n        );\n\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\n\n        vestingMembers[_address].totalSum = _amount;    //total amount\n        vestingMembers[_address].start = _start;        //start block\n        vestingMembers[_address].end = _end;            //end block\n        vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n\n        VestingMemberAdded(_address, _amount, _start, _end);\n\n        return true;\n    }\n\n    function currentPart(address _address) private constant returns (uint256) {\n        if (vestingMembers[_address].totalSum == 0 || block.number <= vestingMembers[_address].start) {\n            return 0;\n        }\n        if (block.number >= vestingMembers[_address].end) {\n            return vestingMembers[_address].totalSum.sub(vestingMembers[_address].usedAmount);\n        }\n\n        return vestingMembers[_address].totalSum\n        .mul(block.number - vestingMembers[_address].start)\n        .div(vestingMembers[_address].end - vestingMembers[_address].start)\n        .sub(vestingMembers[_address].usedAmount);\n    }\n\n    function subFromBalance(address _address, uint256 _amount) private returns (uint256) {\n        require(_address != address(0));\n\n        if (vestingMembers[_address].totalSum == 0) {\n            balances[_address] = balances[_address].sub(_amount);\n            return balances[_address];\n        }\n        uint256 summary = balanceOf(_address);\n        require(summary >= _amount);\n\n        if (balances[_address] > _amount) {\n            balances[_address] = balances[_address].sub(_amount);\n        } else {\n            uint256 part = currentPart(_address);\n            if (block.number >= vestingMembers[_address].end) {\n                vestingMembers[_address].totalSum = 0;          //total amount\n                vestingMembers[_address].start = 0;             //start block\n                vestingMembers[_address].end = 0;               //end block\n                vestingMembers[_address].usedAmount = 0;        //the amount of paid payments\n            } else {\n                vestingMembers[_address].usedAmount = vestingMembers[_address].usedAmount.add(part);\n            }\n            balances[_address] = balances[_address].add(part).sub(_amount);\n        }\n\n        return balances[_address];\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        if (vestingMembers[_owner].totalSum == 0) {\n            return balances[_owner];\n        } else {\n            return balances[_owner].add(currentPart(_owner));\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balanceOf(msg.sender));\n\n        subFromBalance(msg.sender, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        uint256 _allowance = allowed[_from][msg.sender];\n\n        subFromBalance(_from, _value);\n\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-DMToken Security Audit V2 2019 Updated/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No  \nReason: The code uses the SafeMath library’s sub and add functions, which prevent integer overflow and underflow issues."
    },
    {
        "code_segment": "contract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code utilizes SafeMath for arithmetic operations, which prevents integer overflows."
    },
    {
        "code_segment": "contract ERC20Token is IERC20Token, SafeMath {\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[msg.sender] >= _value);\n\n        balances[msg.sender] = safeSub(balances[msg.sender], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n\n        balances[_to] = safeAdd(balances[_to], _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\n      return allowed[_owner][_spender];\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath functions `safeSub` and `safeAdd`, which prevent integer underflows and overflows."
    },
    {
        "code_segment": "contract LockedTokens is SafeMath {\n    struct Tokens {\n        uint256 amount;\n        uint256 lockEndTime;\n        bool released;\n    }\n\n    event TokensUnlocked(address _to, uint256 _value);\n\n    IERC20Token public token;\n    address public crowdsaleAddress;\n    mapping(address => Tokens[]) public walletTokens;\n\n    /**\n     * @dev LockedTokens constructor\n     * @param _token ERC20 compatible token contract\n     * @param _crowdsaleAddress Crowdsale contract address\n     */\n    function LockedTokens(IERC20Token _token, address _crowdsaleAddress) public {\n        token = _token;\n        crowdsaleAddress = _crowdsaleAddress;\n    }\n\n    /**\n     * @dev Functions locks tokens\n     * @param _to Wallet address to transfer tokens after _lockEndTime\n     * @param _amount Amount of tokens to lock\n     * @param _lockEndTime End of lock period\n     */\n    function addTokens(address _to, uint256 _amount, uint256 _lockEndTime) external {\n        require(msg.sender == crowdsaleAddress);\n        walletTokens[_to].push(Tokens({amount: _amount, lockEndTime: _lockEndTime, released: false}));\n    }\n\n    /**\n     * @dev Called by owner of locked tokens to release them\n     */\n    function releaseTokens() public {\n        require(walletTokens[msg.sender].length > 0);\n\n        for(uint256 i = 0; i < walletTokens[msg.sender].length; i++) {\n            if(!walletTokens[msg.sender][i].released && now >= walletTokens[msg.sender][i].lockEndTime) {\n                walletTokens[msg.sender][i].released = true;\n                token.transfer(msg.sender, walletTokens[msg.sender][i].amount);\n                TokensUnlocked(msg.sender, walletTokens[msg.sender][i].amount);\n            }\n        }\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract inherits SafeMath library which prevents integer overflow in arithmetic operations."
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses safe math functions (`safeAdd`, `safeSub`) to handle arithmetic operations, thus preventing integer overflow vulnerabilities.\n\nAnswer: No\nReason: The contract uses safe math functions (`safeAdd`, `safeSub`) to handle arithmetic operations, thus preventing integer overflow vulnerabilities.\n\nAnswer: No\nReason: The contract uses safe math functions (`safeAdd`, `safeSub`) to handle arithmetic operations, thus preventing integer overflow vulnerabilities.\n\nAnswer: No\nReason: The contract uses safe math functions (`safeAdd`, `safeSub`) to handle arithmetic operations, thus preventing integer overflow vulnerabilities.\n\nAnswer: No\nReason: The contract uses safe math functions (`safeAdd`, `safeSub`) to handle arithmetic operations, thus preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract ManagedToken is ERC20Token, MultiOwnable {\n    bool public allowTransfers = false;\n    bool public issuanceFinished = false;\n\n    ITokenEventListener public eventListener;\n\n    event AllowTransfersChanged(bool _newState);\n    event Issue(address indexed _to, uint256 _value);\n    event Destroy(address indexed _from, uint256 _value);\n    event IssuanceFinished();\n\n    modifier transfersAllowed() {\n        require(allowTransfers);\n        _;\n    }\n\n    modifier canIssue() {\n        require(!issuanceFinished);\n        _;\n    }\n\n    /**\n     * @dev ManagedToken constructor\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     */\n    function ManagedToken(address _listener, address[] _owners) public {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        }\n        _setOwners(_owners);\n    }\n\n    /**\n     * @dev Enable/disable token transfers. Can be called only by owners\n     * @param _allowTransfers True - allow False - disable\n     */\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\n        allowTransfers = _allowTransfers;\n        AllowTransfersChanged(_allowTransfers);\n    }\n\n    /**\n     * @dev Set/remove token event listener\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\n     */\n    function setListener(address _listener) public onlyOwner {\n        if(_listener != address(0)) {\n            eventListener = ITokenEventListener(_listener);\n        } else {\n            delete eventListener;\n        }\n    }\n\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transfer(_to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\n        }\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\n        bool success = super.transferFrom(_from, _to, _value);\n        if(hasListener() && success) {\n            eventListener.onTokenTransfer(_from, _to, _value);\n        }\n        return success;\n    }\n\n    function hasListener() internal view returns(bool) {\n        if(eventListener == address(0)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * @dev Issue tokens to specified wallet\n     * @param _to Wallet address\n     * @param _value Amount of tokens\n     */\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\n        totalSupply = safeAdd(totalSupply, _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n        Issue(_to, _value);\n        Transfer(address(0), _to, _value);\n    }\n\n    /**\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\n     * @dev Fund contract address must be in the list of owners to burn token during refund\n     * @param _from Wallet address\n     * @param _value Amount of tokens to destroy\n     */\n    function destroy(address _from, uint256 _value) external {\n        require(ownerByAddress[msg.sender] || msg.sender == _from);\n        require(balances[_from] >= _value);\n        totalSupply = safeSub(totalSupply, _value);\n        balances[_from] = safeSub(balances[_from], _value);\n        Transfer(_from, address(0), _value);\n        Destroy(_from, _value);\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = safeAdd(allowed[msg.sender][_spender], _addedValue);\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     *\n     * approve should be called when allowed[_spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From OpenZeppelin StandardToken.sol\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n        uint oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = safeSub(oldValue, _subtractedValue);\n        }\n        Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /**\n     * @dev Finish token issuance\n     * @return True if success\n     */\n    function finishIssuance() public onlyOwner returns (bool) {\n        issuanceFinished = true;\n        IssuanceFinished();\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses safe mathematical operations like `safeAdd` and `safeSub` which prevent integer underflow and overflow conditions."
    },
    {
        "code_segment": "contract MultiOwnable {\n    address public manager; // address used to set owners\n    address[] public owners;\n    mapping(address => bool) public ownerByAddress;\n\n    event SetOwners(address[] owners);\n\n    modifier onlyOwner() {\n        require(ownerByAddress[msg.sender] == true);\n        _;\n    }\n\n    /**\n     * @dev MultiOwnable constructor sets the manager\n     */\n    function MultiOwnable() public {\n        manager = msg.sender;\n    }\n\n    /**\n     * @dev Function to set owners addresses\n     */\n    function setOwners(address[] _owners) public {\n        require(msg.sender == manager);\n        _setOwners(_owners);\n\n    }\n\n    function _setOwners(address[] _owners) internal {\n        for(uint256 i = 0; i < owners.length; i++) {\n            ownerByAddress[owners[i]] = false;\n        }\n\n\n        for(uint256 j = 0; j < _owners.length; j++) {\n            ownerByAddress[_owners[j]] = true;\n        }\n        owners = _owners;\n        SetOwners(_owners);\n    }\n\n    function getOwners() public constant returns (address[]) {\n        return owners;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform arithmetic operations susceptible to integer overflow."
    },
    {
        "code_segment": "contract TransferLimitedToken is ManagedToken {\n    uint256 public constant LIMIT_TRANSFERS_PERIOD = 365 days;\n\n    mapping(address => bool) public limitedWallets;\n    uint256 public limitEndDate;\n    address public limitedWalletsManager;\n    bool public isLimitEnabled;\n\n    modifier onlyManager() {\n        require(msg.sender == limitedWalletsManager);\n        _;\n    }\n\n    /**\n     * @dev Check if transfer between addresses is available\n     * @param _from From address\n     * @param _to To address\n     */\n    modifier canTransfer(address _from, address _to)  {\n        require(now >= limitEndDate || !isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\n        _;\n    }\n\n    /**\n     * @dev TransferLimitedToken constructor\n     * @param _limitStartDate Limit start date\n     * @param _listener Token listener(address can be 0x0)\n     * @param _owners Owners list\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\n     */\n    function TransferLimitedToken(\n        uint256 _limitStartDate,\n        address _listener,\n        address[] _owners,\n        address _limitedWalletsManager\n    ) public ManagedToken(_listener, _owners)\n    {\n        limitEndDate = _limitStartDate + LIMIT_TRANSFERS_PERIOD;\n        isLimitEnabled = true;\n        limitedWalletsManager = _limitedWalletsManager;\n    }\n\n    /**\n     * @dev Add address to limitedWallets\n     * @dev Can be called only by manager\n     */\n    function addLimitedWalletAddress(address _wallet) public {\n        require(msg.sender == limitedWalletsManager || ownerByAddress[msg.sender]);\n        limitedWallets[_wallet] = true;\n    }\n\n    /**\n     * @dev Del address from limitedWallets\n     * @dev Can be called only by manager\n     */\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\n        limitedWallets[_wallet] = false;\n    }\n\n    /**\n     * @dev Disable transfer limit manually. Can be called only by manager\n     */\n    function disableLimit() public onlyManager {\n        isLimitEnabled = false;\n    }\n\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\n        return super.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\n        return super.transferFrom(_from, _to, _value);\n    }\n\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\n        return super.approve(_spender,_value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/New_Alchemy_Security_Audit-The Abyss DAICO Smart Contract Audit (New)/abyss-daico-21d6232a802cd966b86629cadeac0b7f3816f719/Crowdsale.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: No arithmetic operations involving user input that could result in an overflow."
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /*\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation. \n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n\n  }\n\n  /*\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /*\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /*\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform arithmetic operations on integers that could exceed the maximum size of their data type, thus preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken {\n\n  event UpdatedTokenInformation(string newName, string newSymbol);\n\n  string public name;\n\n  string public symbol;\n\n  uint public decimals;\n\n  /*\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   */\n  function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n    UpgradeableToken(msg.sender) {\n\n    // Create any address, can be transferred\n    // to team multisig via changeOwner(),\n    // also remember to call setUpgradeMaster()\n    owner = msg.sender;\n\n    name = _name;\n    symbol = _symbol;\n\n    totalSupply = _initialSupply;\n\n    decimals = _decimals;\n\n    // Create initially all balance on the team multisig\n    balances[owner] = totalSupply;\n\n    if(totalSupply > 0) {\n      Minted(owner, totalSupply);\n    }\n\n    // No more new supply allowed after the token creation. \n    if(!_mintable) {\n      mintingFinished = true;\n      if(totalSupply == 0) {\n        throw; // Cannot create a token without supply and no minting\n      }\n    }\n\n  }\n\n  /*\n   * When token is released to be transferable, enforce no new tokens can be created.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /*\n   * Allow upgrade agent functionality kick in only if the crowdsale was success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  /*\n   * Owner can update token information here\n   */\n  function setTokenInformation(string _name, string _symbol) onlyOwner {\n    name = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any arithmetic operations on integers that could result in underflow."
    },
    {
        "code_segment": "contract TapcoinToken is CrowdsaleToken {\n  function TapcoinToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)\n   CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinbae-TapCoins_Token_Contract/code/Etherscan-0x9F599410D207f3D2828a8712e5e543AC2E040382.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any arithmetic operations that could cause an integer underflow."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath for all arithmetic operations, which prevents integer overflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's `sub` and `add` functions for all arithmetic operations involving uint256 variables, which prevent integer overflow and underflow."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/TokenProxy.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `totalSupply_` and `balances[user]` updates in `transferFromGate` and `withdrawTo` functions can lead to integer overflow if unchecked."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for arithmetic operations, which prevents integer overflow and underflow."
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The balances[addr] += v operation can result in an integer overflow if the value of v is large enough to cause the balance of addr to exceed the maximum value allowed for a uint. Similarly, balance -= v can result in an underflow causing incorrect balances."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses safe math operations (`.sub` and `.add`) to handle arithmetic operations, thus preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GolemNetworkTokenBatching.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: In the code provided, arithmetic operations are performed using safe methods to avoid integer overflow or underflow. The subtraction in `withdrawTo` is controlled by the `require` check, ensuring that the subtracted value does not exceed the balance. The addition in `transferFromGate` logically handles increments, ensuring safe operations."
    },
    {
        "code_segment": "contract GNTDeposit is ReceivingContract {\n    address public concent;\n    address public coldwallet;\n    uint256 public withdrawal_delay;\n\n    ERC20 public token;\n    // owner => amount\n    mapping (address => uint256) public balances;\n    // owner => timestamp after which withdraw is possible\n    //        | 0 if locked\n    mapping (address => uint256) public locked_until;\n\n    event Deposit(address indexed _owner, uint256 _amount);\n    event Withdraw(address indexed _from, address indexed _to, uint256 _amount);\n    event Lock(address indexed _owner);\n    event Unlock(address indexed _owner);\n    event Burn(address indexed _who, uint256 _amount);\n    event ReimburseForSubtask(address indexed _requestor, address indexed _provider, uint256 _amount, bytes32 _subtask_id);\n    event ReimburseForNoPayment(address indexed _requestor, address indexed _provider, uint256 _amount, uint256 _closure_time);\n    event ReimburseForVerificationCosts(address indexed _from, uint256 _amount, bytes32 _subtask_id);\n\n    function GNTDeposit(\n        ERC20 _token,\n        address _concent,\n        address _coldwallet,\n        uint256 _withdrawal_delay\n    )\n        public\n    {\n        token = _token;\n        concent = _concent;\n        coldwallet = _coldwallet;\n        withdrawal_delay = _withdrawal_delay;\n    }\n\n    // modifiers\n\n    modifier onlyUnlocked() {\n        require(isUnlocked(msg.sender));\n        _;\n    }\n\n    modifier onlyConcent() {\n        require(msg.sender == concent);\n        _;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    // views\n\n    function balanceOf(address _owner) external view returns (uint256) {\n        return balances[_owner];\n    }\n\n    function isLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] == 0;\n    }\n\n    function isTimeLocked(address _owner) external view returns (bool) {\n        return locked_until[_owner] > block.timestamp;\n    }\n\n    function isUnlocked(address _owner) public view returns (bool) {\n        return locked_until[_owner] != 0 && locked_until[_owner] < block.timestamp;\n    }\n\n    function getTimelock(address _owner) external view returns (uint256) {\n        return locked_until[_owner];\n    }\n\n    // deposit API\n\n    function unlock() external {\n        locked_until[msg.sender] = block.timestamp + withdrawal_delay;\n        Unlock(msg.sender);\n    }\n\n    function lock() external {\n        locked_until[msg.sender] = 0;\n        Lock(msg.sender);\n    }\n\n    function onTokenReceived(address _from, uint _amount, bytes /* _data */) public onlyToken {\n        balances[_from] += _amount;\n        Deposit(_from, _amount);\n    }\n\n    function withdraw(address _to) onlyUnlocked external {\n        var _amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        locked_until[msg.sender] = 0;\n        require(token.transfer(_to, _amount));\n        Withdraw(msg.sender, _to, _amount);\n    }\n\n    function burn(address _whom, uint256 _burn) onlyConcent external {\n        _reimburse(_whom, 0xdeadbeef, _burn);\n        Burn(_whom, _burn);\n    }\n\n    function reimburseForSubtask(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForSubtask(_requestor, _provider, _amount, _subtask_id);\n    }\n\n    function reimburseForNoPayment(\n        address _requestor,\n        address _provider,\n        uint256 _amount,\n        uint256 _closure_time\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_requestor, _provider, _amount);\n        ReimburseForNoPayment(_requestor, _provider, _amount, _closure_time);\n    }\n\n    function reimburseForVerificationCosts(\n        address _from,\n        uint256 _amount,\n        bytes32 _subtask_id\n    )\n        onlyConcent\n        external\n    {\n        _reimburse(_from, coldwallet, _amount);\n        ReimburseForVerificationCosts(_from, _amount, _subtask_id);\n    }\n\n    // internals\n\n    function _reimburse(address _from, address _to, uint256 _amount) private {\n        require(balances[_from] >= _amount);\n        balances[_from] -= _amount;\n        if (balances[_from] == 0) {\n            locked_until[_from] = 0;\n        }\n        require(token.transfer(_to, _amount));\n    }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTDeposit.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The addition operation `balances[_from] += _amount;` in the function `onTokenReceived` can cause an integer overflow."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  uint256 totalSupply_;\n\n  /**\n  * @dev total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return totalSupply_;\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library functions for all arithmetic operations involving uint256, which prevents integer overflow."
    },
    {
        "code_segment": "contract GNTPaymentChannels is ReceivingContract {\n\n    GolemNetworkTokenBatching public token;\n\n    struct PaymentChannel {\n        address owner;\n        address receiver;\n        uint256 deposited;\n        // withdrawn <= deposited (less or equal)\n        uint256 withdrawn;\n        //   0, if locked\n        // | timestamp, after which withdraw is possible\n        uint256 locked_until;\n    }\n\n    uint256 id;\n    mapping (bytes32 => PaymentChannel) public channels;\n    uint256 close_delay;\n\n    event NewChannel(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Fund(address indexed _receiver, bytes32 indexed _channel, uint256 amount);\n    event Withdraw(address indexed _owner, address indexed _receiver);\n    event TimeLocked(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event Close(address indexed _owner, address indexed _receiver, bytes32 _channel);\n    event ForceClose(address indexed _owner, address indexed _receiver, bytes32 _channel);\n\n    function GNTPaymentChannels(address _token, uint256 _close_delay)\n        public {\n        token = GolemNetworkTokenBatching(_token);\n        id = 0;\n        close_delay = _close_delay;\n    }\n\n    modifier onlyToken() {\n        require(msg.sender == address(token));\n        _;\n    }\n\n    modifier onlyValidSig(bytes32 _ch, uint _value,\n                      uint8 _v, bytes32 _r, bytes32 _s) {\n        require(isValidSig(_ch, _value, _v, _r, _s));\n        _;\n    }\n\n    modifier onlyOwner(bytes32 _channel) {\n        require(msg.sender == channels[_channel].owner);\n        _;\n    }\n\n    modifier unlocked(bytes32 _channel) {\n        require(isUnlocked(_channel));\n        _;\n    }\n\n    // helpers: check channel status\n\n    function getDeposited(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        PaymentChannel ch = channels[_channel];\n        return ch.deposited;\n    }\n\n    function getWithdrawn(bytes32 _channel)\n        external\n        view\n        returns (uint256) {\n        return channels[_channel].withdrawn;\n    }\n\n    function getOwner(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].owner;\n    }\n\n    function getReceiver(bytes32 _channel)\n        external\n        view\n        returns (address) {\n        return channels[_channel].receiver;\n    }\n\n    function isLocked(bytes32 _channel) public returns (bool) {\n        return channels[_channel].locked_until == 0;\n    }\n\n    function isTimeLocked(bytes32 _channel) public view returns (bool) {\n        return channels[_channel].locked_until >= block.timestamp;\n    }\n\n    function isUnlocked(bytes32 _channel) public view returns (bool) {\n        return ((channels[_channel].locked_until != 0) &&\n                (channels[_channel].locked_until < block.timestamp));\n    }\n\n    function isValidSig(bytes32 _ch, uint _value,\n                        uint8 _v, bytes32 _r, bytes32 _s) view returns (bool) {\n        return (channels[_ch].owner) == (ecrecover(sha3(_ch, _value), _v, _r, _s));\n    }\n\n    // functions that modify state\n\n    // FIXME: Channel needs to be created before it can be funded.\n    function createChannel(address _receiver)\n        external {\n        bytes32 channel = sha3(id++);\n        channels[channel] = PaymentChannel(msg.sender, _receiver, 0, 0, 0);\n        NewChannel(msg.sender, _receiver, channel); // event\n    }\n\n    // Fund existing channel; can be done multiple times.\n    function onTokenReceived(address _from, uint _value, bytes _data) {\n        bytes32 channel;\n        assembly {\n          channel := mload(add(_data, 32))\n        }\n        PaymentChannel ch = channels[channel];\n        require(_from == ch.owner);\n        ch.deposited += _value;\n        Fund(ch.receiver, channel, _value);\n    }\n\n    // Fund existing channel; can be done multiple times.\n    // Uses ERC20 token API\n    function fund(bytes32 _channel, uint256 _amount)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        // check if channel exists\n        // this prevents fund loss\n        require(ch.receiver != address(0));\n        if (token.transferFrom(msg.sender, address(this), _amount)) {\n            ch.deposited += _amount;\n            ch.locked_until = 0;\n            Fund(ch.receiver, _channel, _amount); // event\n            return true;\n        }\n        return false;\n    }\n\n    // Receiver can withdraw multiple times without closing the channel\n    function withdraw(bytes32 _channel, uint256 _value,\n                      uint8 _v, bytes32 _r, bytes32 _s)\n        external\n        onlyValidSig(_channel, _value, _v, _r, _s)\n        returns (bool) {\n        PaymentChannel ch = channels[_channel];\n        require(ch.withdrawn < _value); // <- STRICT less than!\n        var amount = _value - ch.withdrawn;\n        // Receiver has been cheated! Withdraw as much as possible.\n        if (ch.deposited - ch.withdrawn < amount)\n            amount = ch.deposited - ch.withdrawn;\n        return _do_withdraw(_channel, amount);\n    }\n\n    // If receiver does not want to close channel, owner can do that\n    // by calling unlock and waiting for grace period (close_delay).\n    function unlock(bytes32 _channel)\n        external\n        onlyOwner(_channel) {\n        PaymentChannel ch = channels[_channel];\n        ch.locked_until = block.timestamp + close_delay;\n        TimeLocked(ch.owner, ch.receiver, _channel);\n    }\n\n    // Owner can close channel to reclaim its money.\n    function close(bytes32 _channel)\n        external\n        onlyOwner(_channel)\n        unlocked(_channel)\n        returns (bool) {\n        return _do_close(_channel, false);\n    }\n\n    // Receiver can close channel and return owner all of the funds.\n    // Receiver should `withdraw` its own funds first!\n    function forceClose(bytes32 _channel)\n        external\n        returns (bool) {\n        require(msg.sender == channels[_channel].receiver);\n        return _do_close(_channel, true);\n    }\n\n    // internals\n\n    function _do_withdraw(bytes32 _channel, uint256 _amount)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        if (token.transfer(ch.receiver, _amount)) {\n            ch.withdrawn += _amount;\n            Withdraw(ch.owner, ch.receiver);\n            return true;\n        }\n        return false;\n    }\n\n    function _do_close(bytes32 _channel, bool force)\n        private\n        returns (bool) {\n\n        PaymentChannel ch = channels[_channel];\n        var amount = ch.deposited - ch.withdrawn;\n        if (token.transfer(ch.owner, amount)) {\n            if (force)\n                { ForceClose(ch.owner, ch.receiver, _channel); }\n            else\n                { Close(ch.owner, ch.receiver, _channel); }\n            delete channels[_channel];\n            return true;\n        }\n        return false;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `+=` and `-` operations on `deposited` and `withdrawn` are not checked for overflow or underflow."
    },
    {
        "code_segment": "contract GolemNetworkTokenBatching is TokenProxy {\n\n    string public constant name = \"Golem Network Token Batching\";\n    string public constant symbol = \"GNTB\";\n    uint8 public constant decimals = 18;\n\n\n    event BatchTransfer(address indexed from, address indexed to, uint256 value,\n        uint64 closureTime);\n\n    function GolemNetworkTokenBatching(ERC20Basic _gntToken) TokenProxy(_gntToken) public {\n    }\n\n    function batchTransfer(bytes32[] payments, uint64 closureTime) external {\n        require(block.timestamp >= closureTime);\n\n        uint balance = balances[msg.sender];\n\n        for (uint i = 0; i < payments.length; ++i) {\n            // A payment contains compressed data:\n            // first 96 bits (12 bytes) is a value,\n            // following 160 bits (20 bytes) is an address.\n            bytes32 payment = payments[i];\n            address addr = address(payment);\n            uint v = uint(payment) / 2**160;\n            require(v <= balance);\n            balances[addr] += v;\n            balance -= v;\n            BatchTransfer(msg.sender, addr, v, closureTime);\n        }\n\n        balances[msg.sender] = balance;\n    }\n\n    function transferAndCall(address to, uint256 value, bytes data) external {\n      // Transfer always returns true so no need to check return value\n      transfer(to, value);\n\n      // No need to check whether recipient is a contract, this method is\n      // supposed to used only with contract recipients\n      ReceivingContract(to).onTokenReceived(msg.sender, value, data);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code carefully checks and updates balances in a manner that does not result in integer overflow. It decrements and increments the balances for each payment, and ensures that the decremented balance does not go below zero."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath functions (sub and add) which prevent integer overflow and underflow."
    },
    {
        "code_segment": "contract TokenProxy is StandardToken {\n\n    ERC20Basic public TOKEN;\n\n    mapping(address => address) private gates;\n\n\n    event GateOpened(address indexed gate, address indexed user);\n\n    event Minted(address indexed to, uint256 amount);\n\n    event Burned(address indexed from, uint256 amount);\n\n    function TokenProxy(ERC20Basic _token) public {\n        TOKEN = _token;\n    }\n\n    function getGateAddress(address _user) external view returns (address) {\n        return gates[_user];\n    }\n\n    \n    function openGate() external {\n        address user = msg.sender;\n\n        // Do not allow creating more than one Gate per User.\n        require(gates[user] == 0);\n\n        // Create new Gate.\n        address gate = new Gate(TOKEN, this);\n\n        // Remember User - Gate relationship.\n        gates[user] = gate;\n\n        GateOpened(gate, user);\n    }\n\n    function transferFromGate() external {\n        address user = msg.sender;\n\n        address gate = gates[user];\n\n        // Make sure the User's Gate exists.\n        require(gate != 0);\n\n        uint256 value = TOKEN.balanceOf(gate);\n\n        Gate(gate).transferToProxy(value);\n\n        // Handle the information about the amount of migrated tokens.\n        // This is a trusted information becase it comes from the Gate.\n        totalSupply_ += value;\n        balances[user] += value;\n\n        Minted(user, value);\n    }\n\n    function withdraw(uint256 _value) external {\n      withdrawTo(_value, msg.sender);\n    }\n\n    function withdrawTo(uint256 _value, address _destination) public {\n        address user = msg.sender;\n        uint256 balance = balances[user];\n        require(_value <= balance);\n\n        balances[user] = (balance - _value);\n        totalSupply_ -= _value;\n\n        TOKEN.transfer(_destination, _value);\n\n        Burned(user, _value);\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Trail_of_Bits-golem/golem-contracts-62a1e0dab3baf8e9bff79b653dffa7df5f2d10a0/contracts/GNTPaymentChannels.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code does not check for overflow when adding to `totalSupply_` and `balances[user]` in `transferFromGate` function."
    },
    {
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library for arithmetic operations, which protects against integer overflows and underflows."
    },
    {
        "code_segment": "contract PolyDistribution is Ownable {\n  using SafeMath for uint256;\n\n  PolyToken public POLY;\n\n  uint256 private constant decimalFactor = 10**uint256(18);\n  enum AllocationType { PRESALE, FOUNDER, AIRDROP, ADVISOR, RESERVE, BONUS1, BONUS2, BONUS3 }\n  uint256 public constant INITIAL_SUPPLY   = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_TOTAL_SUPPLY    = 1000000000 * decimalFactor;\n  uint256 public AVAILABLE_PRESALE_SUPPLY  =  240000000 * decimalFactor; // 100% Released at Token Distribution (TD)\n  uint256 public AVAILABLE_FOUNDER_SUPPLY  =  150000000 * decimalFactor; // 25% Released at TD +1 year -> 100% at TD +4 years\n  uint256 public AVAILABLE_AIRDROP_SUPPLY  =   10000000 * decimalFactor; // 100% Released at TD\n  uint256 public AVAILABLE_ADVISOR_SUPPLY  =   25000000 * decimalFactor; // 100% Released at TD +7 months\n  uint256 public AVAILABLE_RESERVE_SUPPLY  =  495000000 * decimalFactor; // 12.5% Released at TD +6 months -> 100% at TD +4 years\n\n  uint256 public AVAILABLE_BONUS1_SUPPLY  =    20000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS2_SUPPLY  =    30000000 * decimalFactor;\n  uint256 public AVAILABLE_BONUS3_SUPPLY  =    30000000 * decimalFactor;\n\n  uint256 public grandTotalClaimed = 0;\n  uint256 public startTime;\n\n  // Allocation with vesting information\n  struct Allocation {\n    uint8 AllocationSupply; // Type of allocation\n    uint256 endCliff;       // Tokens are locked until\n    uint256 endVesting;     // This is when the tokens are fully unvested\n    uint256 totalAllocated; // Total tokens allocated\n    uint256 amountClaimed;  // Total tokens claimed\n  }\n  mapping (address => Allocation) public allocations;\n\n  // List of admins\n  mapping (address => bool) public airdropAdmins;\n\n  // Keeps track of whether or not a 250 POLY airdrop has been made to a particular address\n  mapping (address => bool) public airdrops;\n\n  modifier onlyOwnerOrAdmin() {\n    require(msg.sender == owner || airdropAdmins[msg.sender]);\n    _;\n  }\n\n  event LogNewAllocation(address indexed _recipient, AllocationType indexed _fromSupply, uint256 _totalAllocated, uint256 _grandTotalAllocated);\n  event LogPolyClaimed(address indexed _recipient, uint8 indexed _fromSupply, uint256 _amountClaimed, uint256 _totalAllocated, uint256 _grandTotalClaimed);\n\n  /**\n    * @dev Constructor function - Set the poly token address\n    * @param _startTime The time when PolyDistribution goes live\n    */\n    function PolyDistribution(uint256 _startTime) public {\n      require(_startTime >= now);\n      require(AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY.add(AVAILABLE_FOUNDER_SUPPLY).add(AVAILABLE_AIRDROP_SUPPLY).add(AVAILABLE_ADVISOR_SUPPLY).add(AVAILABLE_BONUS1_SUPPLY).add(AVAILABLE_BONUS2_SUPPLY).add(AVAILABLE_BONUS3_SUPPLY).add(AVAILABLE_RESERVE_SUPPLY));\n      startTime = _startTime;\n      POLY = new PolyToken(this);\n    }\n\n  /**\n    * @dev Allow the owner of the contract to assign a new allocation\n    * @param _recipient The recipient of the allocation\n    * @param _totalAllocated The total amount of POLY available to the receipient (after vesting)\n    * @param _supply The POLY supply the allocation will be taken from\n    */\n  function setAllocation (address _recipient, uint256 _totalAllocated, AllocationType _supply) onlyOwner public {\n    require(allocations[_recipient].totalAllocated == 0 && _totalAllocated > 0);\n    require(_supply >= AllocationType.PRESALE && _supply <= AllocationType.BONUS3);\n    require(_recipient != address(0));\n    if (_supply == AllocationType.PRESALE) {\n      AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.PRESALE), 0, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.FOUNDER) {\n      AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.FOUNDER), startTime + 1 years, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.ADVISOR) {\n      AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.ADVISOR), startTime + 212 days, 0, _totalAllocated, 0);\n    } else if (_supply == AllocationType.RESERVE) {\n      AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.RESERVE), startTime + 182 days, startTime + 4 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS1) {\n      AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS1), startTime + 1 years, startTime + 1 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS2) {\n      AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS2), startTime + 2 years, startTime + 2 years, _totalAllocated, 0);\n    } else if (_supply == AllocationType.BONUS3) {\n      AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY.sub(_totalAllocated);\n      allocations[_recipient] = Allocation(uint8(AllocationType.BONUS3), startTime + 3 years, startTime + 3 years, _totalAllocated, 0);\n    }\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(_totalAllocated);\n    LogNewAllocation(_recipient, _supply, _totalAllocated, grandTotalAllocated());\n  }\n\n  /**\n    * @dev Add an airdrop admin\n    */\n  function setAirdropAdmin(address _admin, bool _isAdmin) public onlyOwner {\n    airdropAdmins[_admin] = _isAdmin;\n  }\n\n  /**\n    * @dev perform a transfer of allocations\n    * @param _recipient is a list of recipients\n    */\n  function airdropTokens(address[] _recipient) public onlyOwnerOrAdmin {\n    require(now >= startTime);\n    uint airdropped;\n    //SWC-101-Integer Overflow and Underflow: L121\n    for(uint8 i = 0; i< _recipient.length; i++)\n    {\n        if (!airdrops[_recipient[i]]) {\n          airdrops[_recipient[i]] = true;\n          require(POLY.transfer(_recipient[i], 250 * decimalFactor));\n          airdropped = airdropped.add(250 * decimalFactor);\n        }\n    }\n    AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY.sub(airdropped);\n    AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY.sub(airdropped);\n    grandTotalClaimed = grandTotalClaimed.add(airdropped);\n  }\n\n  /**\n    * @dev Transfer a recipients available allocation to their address\n    * @param _recipient The address to withdraw tokens for\n    */\n  function transferTokens (address _recipient) public {\n    require(allocations[_recipient].amountClaimed < allocations[_recipient].totalAllocated);\n    require(now >= allocations[_recipient].endCliff);\n    require(now >= startTime);\n    uint256 newAmountClaimed;\n    if (allocations[_recipient].endVesting > now) {\n      // Transfer available amount based on vesting schedule and allocation\n      newAmountClaimed = allocations[_recipient].totalAllocated.mul(now.sub(startTime)).div(allocations[_recipient].endVesting.sub(startTime));\n    } else {\n      // Transfer total allocated (minus previously claimed tokens)\n      newAmountClaimed = allocations[_recipient].totalAllocated;\n    }\n    uint256 tokensToTransfer = newAmountClaimed.sub(allocations[_recipient].amountClaimed);\n    allocations[_recipient].amountClaimed = newAmountClaimed;\n    POLY.transfer(_recipient, tokensToTransfer);\n    grandTotalClaimed = grandTotalClaimed.add(tokensToTransfer);\n    LogPolyClaimed(_recipient, allocations[_recipient].AllocationSupply, tokensToTransfer, newAmountClaimed, grandTotalClaimed);\n  }\n\n  // Returns the amount of POLY allocated\n  function grandTotalAllocated() public view returns (uint256) {\n    return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY;\n  }\n\n  // Allow transfer of accidentally sent ERC20 tokens\n  function refundTokens(address _recipient, address _token) public onlyOwner {\n    require(_token != address(POLY));\n    IERC20 token = IERC20(_token);\n    uint256 balance = token.balanceOf(this);\n    token.transfer(_recipient, balance);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath for all arithmetic operations, preventing integer underflow vulnerabilities."
    },
    {
        "code_segment": "contract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library for arithmetic operations, which prevents integer overflow."
    },
    {
        "code_segment": "contract PolyToken is IERC20 {\n  using SafeMath for uint256;\n\n  // Poly Token parameters\n  string public name = 'Polymath';\n  string public symbol = 'POLY';\n  uint8 public constant decimals = 18;\n  uint256 public constant decimalFactor = 10 ** uint256(decimals);\n  uint256 public totalSupply = 1000000000 * decimalFactor;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  /**\n  * @dev Constructor for Poly creation\n  * @dev Assigns the totalSupply to the PolyDistribution contract\n  */\n  function PolyToken(address _polyDistributionContractAddress) public {\n    balances[_polyDistributionContractAddress] = totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public view returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public view returns (uint256) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   *\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n    uint oldValue = allowed[msg.sender][_spender];\n    if (_subtractedValue > oldValue) {\n      allowed[msg.sender][_spender] = 0;\n    } else {\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n    }\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n    return true;\n  }\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-Polymath/polymath-token-672fabe081e8f90ea025252d92c2eb247d60010e/contracts/PolyDistribution.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The SafeMath library is used for all arithmetic operations, preventing integer underflows."
    },
    {
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "Integer Underflow",
        "check": "TP",
        "response": "Answer: No\nReason: The code uses uint which are unsigned integers, preventing underflow by design."
    },
    {
        "code_segment": "contract ROSCA {\n\n  \n  // CONSTANTS\n  \n  uint64 constant internal MIN_CONTRIBUTION_SIZE = 1 finney;  // 1e-3 ether\n  uint128 constant internal MAX_CONTRIBUTION_SIZE = 10 ether;\n\n  // Maximum fee (in 1/1000s) from dispersements that is shared between foreperson and other stakeholders..\n  uint16 constant internal MAX_FEE_IN_THOUSANDTHS = 20;\n\n  // Start time of the ROSCA must be at least this much time ahead of when the ROSCA is created\n  uint32 constant internal MINIMUM_TIME_BEFORE_ROSCA_START = 1 days;\n\n  uint8 constant internal MIN_ROUND_PERIOD_IN_DAYS = 1;\n  uint8 constant internal MAX_ROUND_PERIOD_IN_DAYS = 30;\n  // the winning bid must be at least this much of the maximum (aka default) pot value\n  uint8 constant internal MIN_DISTRIBUTION_PERCENT = 65;\n\n  // Every new bid has to be at most this much of the previous lowest bid\n  uint8 constant internal MAX_NEXT_BID_RATIO = 98;\n\n  // TODO: MUST change this prior to production. Currently this is accounts[9] of the testrpc config\n  // used in tests.\n  // Address from which fees can be withdrawn.\n  address constant internal FEE_ADDRESS = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  // TODO(ron): replace this with an actual wallet. Right now this is accounts[9] of the testrpc used\n  // by tests.\n  // WeTrust's account from which Escape Hatch can be enanbled.\n  address constant internal ESCAPE_HATCH_ENABLER = 0x1df62f291b2e969fb0849d99d9ce41e2f137006e;\n\n  \n  // EVENTS\n  \n  event LogContributionMade(address user, uint256 amount);\n  event LogStartOfRound(uint256 currentRound);\n  event LogNewLowestBid(uint256 bid,address winnerAddress);\n  event LogRoundFundsReleased(address winnerAddress, uint256 amountInWei);\n  event LogRoundNoWinner(uint256 currentRound);\n  event LogFundsWithdrawal(address user, uint256 amount);\n  event LogForepersonSurplusWithdrawal(uint256 amount);\n  // Fired when withdrawer is entitled for a larger amount than the contract\n  // actually holds (excluding fees). A LogFundsWithdrawal will follow\n  // this event with the actual amount released, if send() is successful.\n  event LogCannotWithdrawFully(uint256 creditAmount);\n  event LogUnsuccessfulBid(address bidder,uint256 bidInWei,uint256 lowestBid);\n  event LogEndOfROSCA();\n\n  // Escape hatch related events.\n  event LogEscapeHatchEnabled();\n  event LogEscapeHatchActivated();\n  event LogEmergencyWithdrawalPerformed(uint256 fundsDispersed);\n\n  \n  // STORAGE VARIABLES\n  \n\n  // ROSCA parameters\n  uint16 internal roundPeriodInDays;\n  uint16 internal serviceFeeInThousandths;\n  uint16 internal currentRound;  // set to 0 when ROSCA is created, becomes 1 when ROSCA starts\n  address internal foreperson;\n  uint128 internal contributionSize;\n  uint256 internal startTime;\n\n  // ROSCA state\n  bool internal endOfROSCA = false;\n  bool internal forepersonSurplusCollected = false;\n  // A discount is the difference between a winning bid and the pot value. totalDiscounts is the amount\n  // of discounts accumulated so far, divided by the number of ROSCA participants.\n  uint256 internal totalDiscounts = 0;\n\n  // Amount of fees reserved in the contract for fees.\n  uint256 internal totalFees = 0;\n\n  // Round state variables\n  uint256 internal lowestBid = 0;\n  address internal winnerAddress = 0;  // bidder who bid the lowest so far\n\n  mapping(address => User) internal members;\n  address[] internal membersAddresses;  // for iterating through members' addresses\n\n  // Other state\n  // An escape hatch is used in case a major vulnerability is discovered in the contract code.\n  // The following procedure is then put into action:\n  // 1. WeTrust sends a transaction to make escapeHatchEnabled true.\n  // 2. foreperson is notified and can decide to activate the escapeHatch.\n  // 3. If escape hatch is activated, no contributions and/or withdrawals are allowed. The foreperson\n  //    may call withdraw() to withdraw all of the contract's funds and then disperse them offline\n  //    among the participants.\n  bool internal escapeHatchEnabled = false;\n  bool internal escapeHatchActive = false;\n\n  struct User {\n    uint256 credit;  // amount of funds user has contributed - winnings (not including discounts) so far\n    bool debt; // true if user won the pot while not in good standing and is still not in good standing\n    bool paid; // yes if the member had won a Round\n    bool alive; // needed to check if a member is indeed a member\n  }\n\n  \n  // MODIFIERS\n  \n  modifier onlyFromMember {\n    if (!members[msg.sender].alive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromForeperson {\n    if (msg.sender != foreperson) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromFeeAddress {\n    if (msg.sender != FEE_ADDRESS) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaNotEnded {\n    if (endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier roscaEnded {\n    if (!endOfROSCA) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchActive {\n    if (!escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyIfEscapeHatchInactive {\n    if (escapeHatchActive) {\n      throw;\n    }\n    _;\n  }\n\n  modifier onlyFromEscapeHatchEnabler {\n    if (msg.sender != ESCAPE_HATCH_ENABLER) {\n      throw;\n    }\n    _;\n  }\n\n  \n  // FUNCTIONS\n  \n\n  /**\n    * @dev Creates a new ROSCA and initializes the necessary variables. ROSCA starts after startTime.\n    * Creator of the contract becomes foreperson and a participant.\n    */\n  function ROSCA (\n      uint16 roundPeriodInDays_,\n      uint128 contributionSize_,\n      uint256 startTime_,\n      address[] members_,\n      uint16 serviceFeeInThousandths_) {\n    if (roundPeriodInDays_ < MIN_ROUND_PERIOD_IN_DAYS || roundPeriodInDays_ > MAX_ROUND_PERIOD_IN_DAYS) {\n      throw;\n    }\n    roundPeriodInDays = roundPeriodInDays_;\n\n    if (contributionSize_ < MIN_CONTRIBUTION_SIZE || contributionSize_ > MAX_CONTRIBUTION_SIZE) {\n      throw;\n    }\n    contributionSize = contributionSize_;\n    //SWC-116-Block values as a proxy for time: L199\n    if (startTime_ < (now + MINIMUM_TIME_BEFORE_ROSCA_START)) {\n      throw;\n    }\n    startTime = startTime_;\n    if (serviceFeeInThousandths_ > MAX_FEE_IN_THOUSANDTHS) {\n      throw;\n    }\n    serviceFeeInThousandths = serviceFeeInThousandths_;\n\n    foreperson = msg.sender;\n    addMember(msg.sender);\n\n    for (uint16 i = 0; i < members_.length; i++) {\n      addMember(members_[i]);\n    }\n  }\n\n  function addMember(address newMember) internal {\n    if (members[newMember].alive) {  // already registered\n      throw;\n    }\n    members[newMember] = User({paid: false , credit: 0, alive: true, debt: false});\n    membersAddresses.push(newMember);\n  }\n\n  /**\n    * @dev Calculates the winner of the current round's pot, and credits her.\n    * If there were no bids during the round, winner is selected semi-randomly.\n    * Priority is given to non-delinquent participants.\n    */\n  function startRound() roscaNotEnded external {\n    uint256 roundStartTime = startTime + (uint(currentRound)  * roundPeriodInDays * 1 days);\n    if (now < roundStartTime ) {  // too early to start a new round.\n      throw;\n    }\n\n    if (currentRound != 0) {\n      cleanUpPreviousRound();\n    }\n    if (currentRound < membersAddresses.length) {\n      lowestBid = 0;\n      winnerAddress = 0;\n      currentRound++;\n      LogStartOfRound(currentRound);\n    } else {\n        endOfROSCA = true;\n        LogEndOfROSCA();\n    }\n  }\n\n  function cleanUpPreviousRound() internal {\n    address delinquentWinner = 0x0;\n    uint256 winnerIndex;\n    bool winnerSelectedThroughBid = (winnerAddress != 0);\n    uint16 numUnpaidParticipants = uint16(membersAddresses.length) - (currentRound - 1);\n    if (winnerAddress == 0) {\n      // There was no bid in this round. Find an unpaid address for this epoch.\n      // Give priority to members in good standing (not delinquent).\n      // Note this randomness does not require high security, that's why we feel ok with using the block's timestamp.\n      // Everyone will be paid out eventually.\n      uint256 semi_random = now % numUnpaidParticipants;\n      for (uint16 i = 0; i < numUnpaidParticipants; i++) {\n        uint256 index = (semi_random + i) % numUnpaidParticipants;\n        address candidate = membersAddresses[index];\n        if (!members[candidate].paid) {\n          winnerIndex = index;\n          if (members[candidate].credit + totalDiscounts >= (currentRound * contributionSize)) {\n            // We found a non-delinquent winner.\n            winnerAddress = candidate;\n            break;\n          }\n          delinquentWinner = candidate;\n        }\n      }\n      if (winnerAddress == 0) {  // we did not find any non-delinquent winner.\n        // Perform some basic sanity checks.\n        if (delinquentWinner == 0 || members[delinquentWinner].paid) throw;\n        winnerAddress = delinquentWinner;\n        // Set the flag to true so we know this user cannot withdraw until debt has been paid.\n        members[winnerAddress].debt = true;\n      }\n      // Set lowestBid to the right value since there was no winning bid.\n      lowestBid = contributionSize * membersAddresses.length;\n    }\n    // We keep the unpaid participants at positions [0..num_participants - current_round) so that we can uniformly select\n    // among them (if we didn't do that and there were a few consecutive paid participants, we'll be more likely to select the\n    // next unpaid member).\n    swapWinner(winnerIndex, winnerSelectedThroughBid, numUnpaidParticipants - 1);\n    //SWC-135-Code With No Effects: L288\n    uint256 currentRoundTotalDiscounts = removeFees(contributionSize * membersAddresses.length - lowestBid);\n    totalDiscounts += currentRoundTotalDiscounts / membersAddresses.length;\n    members[winnerAddress].credit += removeFees(lowestBid);\n    members[winnerAddress].paid = true;\n    LogRoundFundsReleased(winnerAddress, lowestBid);\n    recalculateTotalFees();\n  }\n\n  // Recalculates that total fees that should be allocated in the contract.\n  function recalculateTotalFees() {\n    // Start with the max theoretical fees if no one was delinquent, and\n    // reduce funds not actually contributed because of delinquencies.\n    uint256 requiredContributions = currentRound * contributionSize;\n    uint256 grossTotalFees = requiredContributions * membersAddresses.length;\n\n    for (uint16 j = 0; j < membersAddresses.length; j++) {\n      User member = members[membersAddresses[j]];\n      uint256 credit = member.credit;\n      uint256 debit = requiredContributions;\n      if (member.debt) {\n        // As a delinquent member won, we'll reduce the funds subject to fees by the default pot they must have won (since\n        // they could not bid), to correctly calculate their delinquency.\n        debit += removeFees(membersAddresses.length * contributionSize);\n      }\n      if (credit + totalDiscounts < debit) {\n        grossTotalFees -= debit - credit - totalDiscounts;\n      }\n    }\n    //SWC-135-Code With No Effects: L316\n    totalFees = grossTotalFees * serviceFeeInThousandths / 1000;\n  }\n\n  // Swaps membersAddresses[winnerIndex] with membersAddresses[indexToSwap]. However,\n  // if winner was selected through a bid, winnerIndex was not set, and we find it first.\n  function swapWinner(\n    uint256 winnerIndex, bool winnerSelectedThroughBid, uint256 indexToSwap) internal {\n    if (winnerSelectedThroughBid) {\n      // Since winner was selected through a bid, we were not able to set winnerIndex, so search\n      // for the winner among the unpaid participants.\n      for (uint16 i = 0; i <= indexToSwap; i++) {\n        if (membersAddresses[i] == winnerAddress) {\n          winnerIndex = i;\n          break;\n        }\n      }\n    }\n    // We now want to swap winnerIndex with indexToSwap, but we already know membersAddresses[winnerIndex] == winnerAddress.\n    membersAddresses[winnerIndex] = membersAddresses[indexToSwap];\n    membersAddresses[indexToSwap] = winnerAddress;\n  }\n\n  // Calculates the specified amount net amount after fees.\n  function removeFees(uint256 amount) internal returns (uint256) {\n    // First multiply to reduce roundoff errors.\n    //SWC-135-Code With No Effects: L342\n    return amount * (1000 - serviceFeeInThousandths) / 1000;\n  }\n\n  /**\n   * Processes a periodic contribution. msg.sender must be one of the participants and will thus\n   * identify the contributor.\n   *\n   * Any excess funds are withdrawable through withdraw() without fee.\n   */\n  function contribute() payable onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    User member = members[msg.sender];\n    member.credit += msg.value;\n    if (member.debt) {\n      // Check if user comes out of debt. We know they won an entire pot as they could not bid,\n      // so we check whether their credit w/o that winning is non-delinquent.\n      // check that credit must defaultPot (when debt is set to true, defaultPot was added to credit as winnings) +\n      // currentRound in order to be out of debt\n      uint256 requiredContributions = currentRound * contributionSize;\n      if (member.credit + totalDiscounts - removeFees(membersAddresses.length * contributionSize) >= requiredContributions) {\n          member.debt = false;\n      }\n    }\n\n    LogContributionMade(msg.sender, msg.value);\n  }\n\n  /**\n   * Registers a bid from msg.sender. Participant should call this method\n   * only if all of the following holds for her:\n   * + Never won a round.\n   * + Is in good standing (i.e. actual contributions, including this round's,\n   *   plus any past earned discounts are together greater than required contributions).\n   * + New bid is lower than the lowest bid so far.\n   */\n  function bid(uint256 bidInWei) onlyFromMember roscaNotEnded onlyIfEscapeHatchInactive external {\n    if (members[msg.sender].paid  ||\n        currentRound == 0 ||  // ROSCA hasn't started yet\n        // participant not in good standing\n        members[msg.sender].credit + totalDiscounts < (currentRound * contributionSize) ||\n        // bid is less than minimum allowed\n        //SWC-135-Code With No Effects: L384\n        bidInWei < contributionSize * membersAddresses.length * MIN_DISTRIBUTION_PERCENT / 100) {\n      throw;\n    }\n\n    // If winnerAddress is 0, this is the first bid, hence allow full pot.\n    // Otherwise, make sure bid is low enough compared to previous bid.\n    //SWC-135-Code With No Effects: L391\n    uint256 maxAllowedBid = winnerAddress == 0\n        ? contributionSize * membersAddresses.length\n        : lowestBid * MAX_NEXT_BID_RATIO / 100;\n    if (bidInWei > maxAllowedBid) {\n      // We don't throw as this may be hard for the frontend to predict on the\n      // one hand because someone else might have bid at the same time,\n      // and we'd like to avoid wasting the caller's gas.\n      LogUnsuccessfulBid(msg.sender, bidInWei, lowestBid);\n      return;\n    }\n    lowestBid = bidInWei;\n    winnerAddress = msg.sender;\n    LogNewLowestBid(lowestBid, winnerAddress);\n  }\n\n  /**\n   * Withdraws available funds for msg.sender.\n   */\n  function withdraw() onlyFromMember onlyIfEscapeHatchInactive external returns(bool success) {\n    if (members[msg.sender].debt && !endOfROSCA) {  // delinquent winners need to first pay their debt\n      throw;\n    }\n    uint256 totalCredit = members[msg.sender].credit + totalDiscounts;\n\n    uint256 totalDebit = members[msg.sender].debt\n        ? removeFees(membersAddresses.length * contributionSize)  // this must be end of rosca\n        : currentRound * contributionSize;\n    if (totalDebit >= totalCredit) {  // nothing to withdraw\n        throw;\n    }\n\n    uint256 amountToWithdraw = totalCredit - totalDebit;\n    uint256 amountAvailable = this.balance - totalFees;\n\n    if (amountAvailable < amountToWithdraw) {\n      // This may happen if some participants are delinquent.\n      LogCannotWithdrawFully(amountToWithdraw);\n      amountToWithdraw = amountAvailable;\n    }\n    members[msg.sender].credit -= amountToWithdraw;\n    if (!msg.sender.send(amountToWithdraw)) {   // if the send() fails, restore the allowance\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      members[msg.sender].credit += amountToWithdraw;\n      return false;\n    }\n    LogFundsWithdrawal(msg.sender, amountToWithdraw);\n    return true;\n  }\n\n  /**\n   * Returns how much a user can withdraw (positive return value),\n   * or how much they need to contribute to be in good standing (negative return value)\n   */\n  //SWC-135-Code With No Effects: L446-L456 \n  function getParticipantBalance(address user) onlyFromMember external constant returns(int256) {\n    int256 totalCredit = int256(members[user].credit + totalDiscounts);\n\n    // if rosca have ended, we don't need to subtract as totalDebit should equal to default winnings\n    if (members[user].debt && !endOfROSCA) {\n        totalCredit -= int256(removeFees(membersAddresses.length * contributionSize));\n    }\n    int256 totalDebit = int256(currentRound * contributionSize);\n\n    return totalCredit - totalDebit;\n  }\n  \n\n  /**\n   * Returns the amount of funds this contract holds excluding fees. This is\n   * the amount withdrawable by participants.\n   */\n  function getContractNetBalance() external constant returns(uint256) {\n    return this.balance - totalFees;\n  }\n\n  /**\n   * @dev Allows the foreperson to retrieve any surplus funds, one roundPeriodInDays after\n   * the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveSurplus() onlyFromForeperson roscaEnded external returns (bool) {\n    uint256 roscaCollectionTime = startTime + ((membersAddresses.length + 1) * roundPeriodInDays * 1 days);\n    if (now < roscaCollectionTime || forepersonSurplusCollected) {\n        throw;\n    }\n\n    forepersonSurplusCollected = true;\n    uint256 amountToCollect = this.balance - totalFees;\n    if (!foreperson.send(amountToCollect)) {   // if the send() fails, restore the flag\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      forepersonSurplusCollected = false;\n      return false;\n    } else {\n      LogForepersonSurplusWithdrawal(amountToCollect);\n    }\n  }\n\n  /**\n   * @dev Allows the fee collector to extract the fees in the contract. Can be called\n   * only ine roundPeriodInDays after the end of the ROSCA.\n   *\n   * Note that startRound() must be called first after the last round, as it\n   * does the bookeeping of that round.\n   */\n  function endOfROSCARetrieveFees() onlyFromFeeAddress roscaEnded external returns (bool) {\n    uint256 tempTotalFees = totalFees;  // prevent re-entry.\n    totalFees = 0;\n    if (!FEE_ADDRESS.send(tempTotalFees)) {   // if the send() fails, restore totalFees\n      // No need to call throw here, just reset the amount owing. This may happen\n      // for nonmalicious reasons, e.g. the receiving contract running out of gas.\n      totalFees = tempTotalFees;\n      return false;\n    } else {\n      //SWC-135-Code With No Effects: L507\n      LogFundsWithdrawal(FEE_ADDRESS, totalFees);\n    }\n  }\n\n  /**\n   * Allows the Escape Hatch Enabler (controlled by WeTrust) to enable the Escape Hatch in case of\n   * emergency (e.g. a major vulnerability found in the contract).\n   */\n  function enableEscapeHatch() onlyFromEscapeHatchEnabler external {\n    escapeHatchEnabled = true;\n    LogEscapeHatchEnabled();\n  }\n\n  /**\n   * Allows the foreperson to active the Escape Hatch after the Enabled enabled it. This will freeze all\n   * contributions and withdrawals, and allow the foreperson to retrieve all funds into their own account,\n   * to be dispersed offline to the other participants.\n   */\n  function activateEscapeHatch() onlyFromForeperson external {\n    if (!escapeHatchEnabled) {\n      throw;\n    }\n    escapeHatchActive = true;\n    LogEscapeHatchActivated();\n  }\n\n  /**\n   * Can only be called by the foreperson after an escape hatch is activated,\n   * this sends all the funds to the foreperson by selfdestructing this contract.\n   */\n  function emergencyWithdrawal() onlyFromForeperson onlyIfEscapeHatchActive {\n    LogEmergencyWithdrawalPerformed(this.balance);\n    // Send everything, including potential fees, to foreperson to disperse offline to participants.\n    selfdestruct(foreperson);\n  }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/openzeppelin-WeTrust_ROSCA_contract_code/rosca-contracts-2af29be97d529488f5488fe0592f9e6b3585254f/contracts/ROSCA.sol",
        "vulnerability": "Transaction-Ordering Dependence (TOD)",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `contribute()` and `bid()` are susceptible to Transaction-Ordering Dependence (TOD) as the state of the contract, particularly `lowestBid`, can be manipulated by the order of transactions, impacting the outcome for users."
    },
    {
        "code_segment": "contract FLUX is ERC20Interface, Owned {\n\tstring public constant symbol = \"FLX\";\n\tstring public constant name = \"FLUX\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 1000000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction FLUX() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-FLUX Token Smart Contract Audit/code/Etherscan-0x54735d716995071585A4f6ba341a6Ded79756F09.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The transfer and transferFrom functions perform arithmetic operations on balances without utilizing SafeMath, leading to potential integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Overflow",
        "check": "TP",
        "response": "Answer: Yes\nDescription: The code relies on checking for overflows using conditional statements and the \"throw\" keyword, which is deprecated. It should use SafeMath library to handle arithmetic operations securely."
    },
    {
        "code_segment": "contract StandardMintableToken is owned { \n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;                     // the token name \n    string public symbol;                   // the ticker symbol\n    uint8 public decimals;                  // amount of decimal places in the token\n    uint256 public totalSupply;             // total tokens\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    /* This creates an array with all frozen accounts */\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n    \n    /* This generates a public event on the blockchain that will notify clients */\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function StandardMintableToken(\n        string tokenName,               // the token name\n        uint8 decimalUnits,             // amount of decimal places in the token\n        string tokenSymbol,             // the token symbol\n        uint256 initialSupply            // the initial distro amount\n        ) {\n\n        balanceOf[msg.sender] = initialSupply;                   // Give the creator all initial tokens\n        totalSupply = initialSupply;                             // Update total supply\n        name = tokenName;                                        // Set the name for display purposes\n        symbol = tokenSymbol;                                    // Set the symbol for display purposes\n        decimals = decimalUnits;                                 // Amount of decimals for display purposes\n    }\n\n    /* Send tokens */\n    function transfer(address _to, uint256 _value) returns (bool success){\n        if (_value == 0) return false; \t\t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;    // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen\n        if (frozenAccount[_to]) throw;                       // Check if recipient frozen                 \n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        return true;\n    }\n\n    /* Allow another contract to spend some tokens on your behalf */\n    function approve(address _spender, uint256 _value)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;            // Update allowance first\n        Approval(msg.sender, _spender, _value);              // Notify of new Approval\n        return true;\n    }\n\n    /* Approve and then communicate the approved contract in a single tx */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }        \n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if sender frozen       \n        if (frozenAccount[_to]) throw;                          // Check if recipient frozen                 \n        if (balanceOf[_from] < _value) return false;          \t// Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;    // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;       // Check allowance\n        balanceOf[_from] -= _value;                             // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;                 // Update sender's allowance \n        Transfer(_from, _to, _value);                           // Perform the transfer\n        return true;\n    }\n    \n    /* A function to freeze or un-freeze accounts, to and from */\n    \n    function freezeAccount(address target, bool freeze ) onlyOwner {    \n        frozenAccount[target] = freeze;                       // set the array object to the value of bool freeze\n        FrozenFunds(target, freeze);                          // notify event\n    }\n    \n\n    /* A function to burn tokens and remove from supply */\n    \n    function burn(uint256 _value) returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                 // Check if sender frozen       \n        if (_value == 0) return false; \t\t\t\t          // Don't waste gas on zero-value transaction\n        if (balanceOf[msg.sender] < _value) return false;     // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;                      // Subtract from the sender\n        totalSupply -= _value;                                // Updates totalSupply\n        Transfer(msg.sender,0, _value);\t                      // Burn _value tokens\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) onlyOwner returns (bool success) {\n        if (frozenAccount[msg.sender]) throw;                // Check if sender frozen       \n        if (frozenAccount[_from]) throw;                     // Check if recipient frozen \n        if (_value == 0) return false; \t\t\t             // Don't waste gas on zero-value transaction\n        if (balanceOf[_from] < _value) return false;         // Check if the sender has enough\n        if (_value > allowance[_from][msg.sender]) throw;    // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        totalSupply -= _value;                               // Updates totalSupply\n        allowance[_from][msg.sender] -= _value;\t\t\t\t // Updates allowance\n        Transfer(_from, 0, _value);                          // Burn tokens by Transfer to incinerator\n        return true;\n    }\n    \n    /* A function to add more tokens to the total supply, accessible only to owner*/\n    // SWC-101-Integer Overflow and Underflow\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        if (balanceOf[target] + mintedAmount < balanceOf[target]) throw; // Check for overflows\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, target, mintedAmount);\n\n    }\n    \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Blockchain Labs NZ-Earth/Back-to-Earth-audit-master/contracts/GTKT_GoldTickets.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code contains checks to prevent integer underflows before performing subtraction operations."
    },
    {
        "code_segment": "contract CHAINSQUARE is ERC20Interface, Owned {\n\tstring public constant symbol = \"CHS\";\n\tstring public constant name = \"CHAINSQUARE\";\n\tuint8 public constant decimals = 18;\n\tuint256 public constant totalSupply = 100000000000000000000000000;\n\n\tbool public stopped;\n\n\tmapping (address => int8) public blackList;\n\n\tmapping (address => uint256) public balances;\n\tmapping (address => mapping (address => uint256)) public allowed;\n\n\n    event Blacklisted(address indexed target);\n    event DeleteFromBlacklist(address indexed target);\n    event RejectedPaymentToBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n    event RejectedPaymentFromBlacklistedAddr(address indexed from, address indexed to, uint256 value);\n\n\n\tmodifier notStopped {\n        require(!stopped);\n        _;\n    }\n\n// constructor\n\tfunction CHAINSQUARE() public {\n\t\tbalances[msg.sender] = totalSupply;\n\t}\n\t\n// function made for airdrop\n\tfunction airdrop(address[] _to, uint256[] _value) onlyOwner notStopped public {\n\t    for(uint256 i = 0; i < _to.length; i++){\n\t        if(balances[_to[i]] > 0){\n\t            continue;\n\t        }\n\t        transfer(_to[i], _value[i]);\n\t    }\n\t}\n\n// blacklist management\n    function blacklisting(address _addr) onlyOwner public {\n        blackList[_addr] = 1;\n        emit Blacklisted(_addr);\n    }\n    function deleteFromBlacklist(address _addr) onlyOwner public {\n        blackList[_addr] = -1;\n        emit DeleteFromBlacklist(_addr);\n    }\n\n// stop the contract\n// SWC-100-Function Default Visibility: L90\n\tfunction stop() onlyOwner {\n        stopped = true;\n    }\n// SWC-100-Function Default Visibility: L94\n    function start() onlyOwner {\n        stopped = false;\n    }\n\t\n// ERC20 functions\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance){\n\t\treturn balances[_owner];\n\t}\n\tfunction transfer(address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[msg.sender] >= _value);\n\n\t\tif(blackList[msg.sender] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(msg.sender, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\tfunction transferFrom(address _from, address _to, uint256 _value) notStopped public returns (bool success){\n\t\trequire(balances[_from] >= _value\n\t\t\t&& allowed[_from][msg.sender] >= _value);\n\n\t\tif(blackList[_from] > 0){\n\t\t\temit RejectedPaymentFromBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\t\tif(blackList[_to] > 0){\n\t\t\temit RejectedPaymentToBlacklistedAddr(_from, _to, _value);\n\t\t\treturn false;\n\t\t}\n\n\t\tbalances[_from] -= _value;\n\t\tallowed[_from][msg.sender] -= _value;\n\t\tbalances[_to] += _value;\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\tfunction approve(address _spender, uint256 _value) notStopped public returns (bool success){\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining){\n\t\treturn allowed[_owner][_spender];\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Iosiro-CHAINSQUARE Smart Contract Audit/code/Etherscan-0xb41380174d0B06181513A5677b60200b93b5Efb4.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The subtraction and addition operations on `balances` in the `transfer` and `transferFrom` functions are not checked for overflow, which can result in integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract BasicToken is ERC20Basic {\n\tusing SafeMath for uint256;\n\n\tmapping(address => uint256) balances;\n\n\tuint256 totalSupply_;\n\n\t/**\n\t* @dev total number of tokens in existence\n\t*/\n\tfunction totalSupply() public view returns (uint256) {\n\t\treturn totalSupply_;\n\t}\n\n\t/**\n\t* @dev transfer token for a specified address\n\t* @param _to The address to transfer to.\n\t* @param _value The amount to be transferred.\n\t*/\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[msg.sender]);\n\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\temit Transfer(msg.sender, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t* @dev Gets the balance of the specified address.\n\t* @param _owner The address to query the the balance of.\n\t* @return An uint256 representing the amount owned by the passed address.\n\t*/\n\tfunction balanceOf(address _owner) public view returns (uint256) {\n\t\treturn balances[_owner];\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath functions (add, sub) which protect against integer overflow and underflow."
    },
    {
        "code_segment": "contract FinToken is StandardToken {\n\taddress public owner;\n\t\n\tstring public constant name = \"FIN Token\"; \n\tstring public constant symbol = \"FIN\";\n\tuint8 public constant decimals = 18;\n\n\t// SWC-101-Integer Overflow and Underflow: L226\n\tuint256 public constant INITIAL_SUPPLY = 2623304 * (10 ** uint256(decimals));\n\t\n\tmapping (address => bool) internal verificatorAddresses;\n\tmapping (address => bool) internal verifiedAddresses;\n\t\n\tevent AddVerificator(address indexed verificator);\n\tevent RemoveVerificator(address indexed verificator);\n\t\n\tevent AddVerified(address indexed verificatorAddress, address indexed verified);\n\tevent RemoveVerified(address indexed verificatorAddress, address indexed verified);\n\t\n\tevent Mint(address indexed to, uint256 amount);\n\t\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner);\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerificator() {\n\t\trequire(isVerificator(msg.sender));\n\t\t_;\n\t}\n\t\n\tmodifier onlyVerified(address _from, address _to) {\n\t\trequire(isVerified(_from));\n\t\trequire(isVerified(_to));\n\t\t_;\n\t}\n\n\tfunction FinToken() public {\n\t\towner = msg.sender;\n\t\ttotalSupply_ = INITIAL_SUPPLY;\n\t\tbalances[msg.sender] = INITIAL_SUPPLY;\n\t\temit Transfer(0x0, msg.sender, INITIAL_SUPPLY);\n\t}\n\t\n\tfunction addVerificatorAddress(address addr) public onlyOwner {\n\t\tverificatorAddresses[addr] = true;\n\t\temit AddVerificator(addr);\n\t}\n\t\n\tfunction removeVerificatorAddress(address addr) public onlyOwner {\n\t\tdelete verificatorAddresses[addr];\n\t\temit RemoveVerificator(addr);\n\t}\n\t\n\tfunction isVerificator(address addr) public constant returns (bool) {\n\t\treturn verificatorAddresses[addr];\n\t}\n\t\t\n\tfunction addVerifiedAddress(address addr) public onlyVerificator {\n\t\tverifiedAddresses[addr] = true;\n\t\temit AddVerified(msg.sender, addr);\n\t}\n\t\n\tfunction removeVerifiedAddress(address addr) public onlyVerificator {\n\t\tdelete verifiedAddresses[addr];\n\t\temit RemoveVerified(msg.sender, addr);\n\t}\n\t\n\tfunction isVerified(address addr) public constant returns (bool) {\n\t\treturn verifiedAddresses[addr];\n\t}\n\t\n\tfunction transfer(address _to, uint256 _value) public onlyVerified(msg.sender, _to) returns (bool) {\n\t\tsuper.transfer(_to, _value);\n\t}\n\t\n\tfunction transferFrom(address _from, address _to, uint256 _value) public onlyVerified(_from, _to) returns (bool) {\n\t    super.transferFrom(_from, _to, _value);\n\t}\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses a constant value for `INITIAL_SUPPLY` which prevents integer overflow, and no other arithmetic operations are vulnerable to overflow."
    },
    {
        "code_segment": "contract StandardToken is ERC20, BasicToken {\n\n\tmapping (address => mapping (address => uint256)) internal allowed;\n\n\n\t/**\n\t * @dev Transfer tokens from one address to another\n\t * @param _from address The address which you want to send tokens from\n\t * @param _to address The address which you want to transfer to\n\t * @param _value uint256 the amount of tokens to be transferred\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n\t\trequire(_to != address(0));\n\t\trequire(_value <= balances[_from]);\n\t\trequire(_value <= allowed[_from][msg.sender]);\n\n\t\tbalances[_from] = balances[_from].sub(_value);\n\t\tbalances[_to] = balances[_to].add(_value);\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\temit Transfer(_from, _to, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n\t *\n\t * Beware that changing an allowance with this method brings the risk that someone may use both the old\n\t * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n\t * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t * @param _spender The address which will spend the funds.\n\t * @param _value The amount of tokens to be spent.\n\t */\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = _value;\n\t\temit Approval(msg.sender, _spender, _value);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Function to check the amount of tokens that an owner allowed to a spender.\n\t * @param _owner address The address which owns the funds.\n\t * @param _spender address The address which will spend the funds.\n\t * @return A uint256 specifying the amount of tokens still available for the spender.\n\t */\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\n\t\treturn allowed[_owner][_spender];\n\t}\n\n\t/**\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To increment\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _addedValue The amount of tokens to increase the allowance by.\n\t */\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\n\t\tallowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\n\t *\n\t * approve should be called when allowed[_spender] == 0. To decrement\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\n\t * the first transaction is mined)\n\t * From MonolithDAO Token.sol\n\t * @param _spender The address which will spend the funds.\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\n\t */\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\n\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\tif (_subtractedValue > oldValue) {\n\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t} else {\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n\t\t}\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\treturn true;\n\t}\n\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Chainsulting-NOM/FinToken/FinToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The code uses arithmetic operations (add, sub) without proper overflow checks.\n\nAnswer: Yes\nDescription: The code uses arithmetic operations (add, sub) without proper overflow checks.\n\nAnswer: Yes\nDescription: The code uses arithmetic operations (add, sub) without proper overflow checks.\n\nAnswer: Yes\nDescription: The code uses arithmetic operations (add, sub) without proper overflow checks.\n\nAnswer: Yes\nDescription: The code uses arithmetic operations (add, sub) without proper overflow checks."
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code contains checks to prevent both overflows and underflows, such as requiring that the balance of the recipient after a transfer is greater than before (`require(balanceOf[_to] + _value > balanceOf[_to])`)."
    },
    {
        "code_segment": "contract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    mapping (address => bool) public blacklist;\n    address admin;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n    /**\n     * Constructor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        admin = msg.sender;\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n// SWC-104-Unchecked Call Return Value: L76\n    function transfer(address _to, uint256 _value) public {\n        require(!blacklist[msg.sender]);\n        _transfer(msg.sender, _to, _value);\n    }\n\n    /**\n     * Ban address\n     * \n     * @param addr ban addr\n     */\n    function ban(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = true;\n    }\n\n    /**\n     * Enable address\n     * \n     *  @param addr enable addr\n     */\n    function enable(address addr) public {\n        require(msg.sender == admin);\n        blacklist[addr] = false;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` on behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n    public\n    returns (bool success) {\n        require(!blacklist[msg.sender]);\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(!blacklist[msg.sender]);\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Callisto_Network-MaxiMine Token (MXM) Security Audit/code/code.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code contains checks to ensure that sufficient balance exists before performing any subtraction operations, which prevents integer underflow."
    },
    {
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not involve addition or multiplication of user inputs without safeguards like SafeMath, and it ensures values stay within clearly defined bounds through validation and safe practices."
    },
    {
        "code_segment": "library ProPoolLib {    \n    using QuotaLib for QuotaLib.Storage;\n    // We could use SafeMath to catch errors in the logic, \n    // but if there are no such errors we can skip it.\n    // using SafeMath for uint;    \n\n    /**\n     * @dev Pool possible states.\n     */\n    enum State {\n        Open,\n        PaidToPresale,\n        Distribution,        \n        FullRefund,\n        Canceled\n    }\n\n    /**\n     * @dev Pool participation group structure. \n     * Every participation group of the pool is represented by a copy of this structure. \n     * This structure holds information about the group settings and its current state.\n     */\n    struct Group {\n\n        // Total contribution balance of the group. Every time participant \n        // contributes to the group the value of this field will be increased \n        // by the amount of participant contribution.\n        uint contribution;            \n\n        // Total remaining balance of the group. Group settings can be changed \n        // by pool administrator during the pooling period. For example, the max balance\n        // of the group or max contribution per address can be decreased. Because of this,\n        // the contribution amount of the participants that have made their contribution \n        // before this changes can be moved from the contribution balance of the group\n        // to remainig balance of the group, partially or completely.\n        uint remaining;                   \n\n        // The total contribution balance of the group cannot be greater than this value.\n        uint maxBalance;\n\n        // The min contribution per address must be equal or greater than this value.\n        uint minContribution; \n\n        // The max contribution per address must be equal or less than this value.\n        uint maxContribution;        \n\n        // Administrator's commission in terms of \"Fee per Ether\".\n        uint ctorFeePerEther;          \n\n        // Indicates when the group is public or private. Public group means that \n        // any address can contribute to it. In case of a private group, only \n        // whitelisted addresses can contribute to the group.\n        bool isRestricted;\n\n        // Group existence indicator.\n        bool exists;\n    }\n\n    /**\n     * @dev Pool participant structrure.\n     * Every participant in the pool is represented by a copy of this structure.\n     * This structure holds information about participant and his contributions.\n     */\n    struct Participant {\n\n        // Describes the participant's contribution balance in the each of the groups.\n        uint[8] contribution;\n\n        // Describes the participant's remaining balance in the each of the groups.\n        uint[8] remaining;\n\n        // Indicates when the participant is whitelisted in the certain group.\n        bool[8] whitelist;  \n\n        // Indicates when the participant is an administrator.\n        bool isAdmin;\n\n        // Participant existence indicator.\n        bool exists;\n    }    \n\n    /**\n     * @dev Pool structure.\n     * Every pool is represented by a copy of this structure. Holds information \n     * about current state of the pool, its participation groups and participants.\n     */\n    struct Pool {\n\n        // Current state of the pool.\n        State state;\n\n        // EasyPool commission in terms of \"Fee per Ether\".\n        // Is set only once, during pool creation transaction.\n        uint svcFeePerEther;\n\n        // Refund sender address. \n        // The pool refund transactions must be sent from this address.        \n        address refundAddress;\n\n        // Pool funds destionation address.\n        // If locked the pool funds can only be sent to this address. \n        // Can be set only once by pool admin and can't be changed later.\n        address presaleAddress;\n\n        // Presale address can be locked.\n        // SWC-114-Transaction Order Dependence: L120\n        bool lockPresale;\n\n        // FeeService contract interface.\n        IFeeService feeService;\n\n        // When paying to the presale \"Fee-to-Token\" mode can be chosen by admin. \n        // In this mode, the pool creator commission will be sent to the presale\n        // as a part of creator contribution. \n        address feeToTokenAddress;        \n        bool feeToTokenMode;\n                  \n        // Pool administrators array.\n        address[] admins;\n\n        // Pool participatnts array.\n        address[] participants;     \n\n        // Confirmed tokens array.\n        address[] tokenAddresses;\n\n        // Pool groups array.\n        Group[8] groups;         \n\n        // Mapping from participant address to the corresponding structure.\n        mapping(address => Participant) participantToData;   \n\n        // Mapping from token address to the corresponding quota storage.     \n        mapping(address => QuotaLib.Storage) tokenQuota;  \n\n        // Quota storage for pool refund balace.\n        QuotaLib.Storage refundQuota;\n    }                     \n\n    /**\n     * @dev Access modifier for admin-only functionality.\n     */\n    modifier onlyAdmin(Pool storage pool) {\n        require(pool.participantToData[msg.sender].isAdmin);\n        _;\n    }\n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInState(Pool storage pool, State state) {\n        require(pool.state == state);\n        _;\n    }      \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates2(Pool storage pool, State state1, State state2) {\n        require(pool.state == state1 || pool.state == state2);\n        _;\n    }  \n\n    /**\n     * @dev Access modifier for in-state-only functionality.\n     */\n    modifier onlyInStates3(Pool storage pool, State state1, State state2, State state3) {\n        require(pool.state == state1 || pool.state == state2 || pool.state == state3);\n        _;\n    }    \n\n    /**\n     * @dev Setting new pool instance. Called when new pool is created.     \n     */\n    function init(\n        Pool storage pool,           \n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,\n        bool isRestricted,                \n        address creatorAddress,        \n        address presaleAddress,        \n        address feeServiceAddr,\n        address[] whitelist,\n        address[] admins\n    )\n        public \n    {\n\n        // Set presale address.\n        if(presaleAddress != address(0)) {\n            require(presaleAddress != address(this)); \n            pool.presaleAddress = presaleAddress;           \n            emit PresaleAddressLocked(presaleAddress);            \n        }\n                \n        // Set fee service contract.\n        pool.feeService = IFeeService(feeServiceAddr);        \n        pool.svcFeePerEther = pool.feeService.getFeePerEther();\n        require(pool.svcFeePerEther <= (1 ether / 4));\n        emit FeeServiceAttached(\n            feeServiceAddr,\n            pool.svcFeePerEther\n        );  \n        \n        // Set pool administrators.\n        require(creatorAddress != address(0));\n        addAdmin(pool, creatorAddress);\n        for(uint i = 0; i < admins.length; i++) {\n            addAdmin(pool, admins[i]);\n        }\n        \n        // Create first group.\n        setGroupSettingsCore(\n            pool,\n            0,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n        \n        // Set whitelist.\n        if(whitelist.length > 0) {\n            require(isRestricted);\n            modifyWhitelistCore(pool, 0, whitelist, new address[](0));\n        }\n    }\n\n    /**\n     * @dev Creates new participation group in case it doesn't exist \n     * or updates participation group settings in case the group exists.\n     */\n    function setGroupSettings(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        public     \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)      \n    {\n        // Group existence state.\n        bool exists = pool.groups[idx].exists;\n\n        // Set or update group settings.\n        setGroupSettingsCore(\n            pool,\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted            \n        );\n                \n        if(exists) {            \n            // Execute rebalancing.\n            groupRebalance(pool, idx);\n        }\n    }\n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelist(Pool storage pool, uint idx, address[] include, address[] exclude)\n        public \n        onlyAdmin(pool)\n        onlyInState(pool, State.Open)\n    {\n        // Modify whitelist (without relabancing).\n        modifyWhitelistCore(pool, idx, include, exclude); \n        // Execute group rebalancing.\n        groupRebalance(pool, idx);\n    }     \n\n    /**\n     * @dev Lock presale address.\n     */\n    function lockPresaleAddress(Pool storage pool, address presaleAddress, bool lock)\n        public \n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {        \n        require(presaleAddress != address(0));\n        require(presaleAddress != address(this));\n        require(pool.presaleAddress == address(0));\n        require(!pool.lockPresale);\n\n        // Set presale address.\n        pool.presaleAddress = presaleAddress;\n\n        // Lock presale address.\n        if(lock) {\n            pool.lockPresale = true;\n        }\n\n        emit PresaleAddressLocked(presaleAddress);\n    }   \n\n    /**\n     * @dev Confirm token address.\n     */\n    function confirmTokenAddress(Pool storage pool, address tokenAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)         \n    {        \n        require(tokenAddress != address(0));\n        require(pool.tokenAddresses.length <= 4);\n        require(!contains(pool.tokenAddresses, tokenAddress));\n\n        // Get token balance for the pool address.\n        IERC20Base ERC20 = IERC20Base(tokenAddress);\n        uint balance = ERC20.balanceOf(address(this));  \n\n        // When confirming the token balance must be greater than zero.      \n        require(balance > 0);\n\n        // Change state of the pool if this is the first token confirmation.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.Distribution);            \n            sendFees(pool);\n        } \n                        \n        // Save token address.\n        pool.tokenAddresses.push(tokenAddress);\n\n        emit TokenAddressConfirmed(\n            tokenAddress,\n            balance\n        );\n    }\n\n    /**\n     * @dev Set refund sender address.\n     */\n    function setRefundAddress(Pool storage pool, address refundAddress)\n        public\n        onlyAdmin(pool)\n        onlyInStates3(pool, State.PaidToPresale, State.Distribution, State.FullRefund)\n    {        \n        require(refundAddress != address(0));\n        require(pool.refundAddress != refundAddress);\n\n        // Set refund sender address.\n        pool.refundAddress = refundAddress;\n        emit RefundAddressChanged(refundAddress);\n\n        // This is full refund scenario.\n        if(pool.state == State.PaidToPresale) {\n            changeState(pool, State.FullRefund);\n        }\n    }   \n\n    /**\n     * @dev Send pool balance to presale address.\n     */\n    function payToPresale(\n        Pool storage pool,\n        address presaleAddress,\n        uint minPoolBalance,\n        bool feeToToken,\n        bytes data\n    )\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open) \n    {\n        require(presaleAddress != address(0));\n                        \n        // Check if presale address is locked.\n        if(pool.presaleAddress == address(0)) {\n            pool.presaleAddress = presaleAddress;\n            emit PresaleAddressLocked(presaleAddress);\n        } else { \n            // If locked then destination address must be same.\n            require(pool.presaleAddress == presaleAddress);\n        }\n        \n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;      \n        // Calculate pool summaries.          \n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);        \n        require(poolContribution > 0 && poolContribution >= minPoolBalance);\n\n        // Set fee-to-token mode.\n        if(feeToToken) {\n            pool.feeToTokenMode = true;            \n            pool.feeToTokenAddress = msg.sender;\n            ctorFee = 0;\n        }\n\n        changeState(pool, State.PaidToPresale);\n\n        // Transafer funds.\n        addressCall(\n            pool.presaleAddress,\n            poolContribution - ctorFee - calcFee(poolContribution, pool.svcFeePerEther),\n            data\n        );        \n    }\n\n    /**\n     * @dev Cancel pool.\n     */\n    function cancel(Pool storage pool)\n        public\n        onlyAdmin(pool) \n        onlyInState(pool, State.Open)\n    {\n        changeState(pool, State.Canceled);\n    }  \n\n    /**\n     * @dev Contribute to the group.\n     */\n    function deposit(Pool storage pool, uint idx)\n        public        \n        onlyInState(pool, State.Open)  \n    {\n        require(msg.value > 0);\n        require(pool.groups.length > idx);\n        require(pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group = pool.groups[idx];        \n\n        // Calculate contribution and remaining balance.\n        uint remaining;\n        uint contribution;                \n        (contribution, remaining) = calcContribution(\n            idx, \n            msg.value, \n            group.maxBalance, \n            group.contribution - participant.contribution[idx], \n            group.minContribution, \n            group.maxContribution, \n            group.isRestricted,            \n            participant\n        );\n\n        // Remaining balance must be equal to zero.\n        require(remaining == 0);\n\n        // Set the participant existence state.\n        if (!participant.exists) {\n            participant.exists = true;   \n            pool.participants.push(msg.sender);\n        }        \n\n        // Mark participant as whitelisted.\n        if(!participant.whitelist[idx]) {\n            participant.whitelist[idx] = true;         \n        }\n\n        // Update contribution and remaining balance.\n        group.contribution = group.contribution - participant.contribution[idx] + contribution;\n        group.remaining = group.remaining - participant.remaining[idx] + remaining;\n        participant.contribution[idx] = contribution;\n        participant.remaining[idx] = remaining;\n\n        emit Contribution(\n            msg.sender,\n            idx,\n            msg.value,\n            contribution,\n            group.contribution\n        );        \n    }\n\n    /**\n     * @dev Withdraw from the group.\n     */     \n    function withdrawAmount(Pool storage pool, uint amount, uint idx)\n        public\n        onlyInState(pool, State.Open)\n    {\n        // Get participant instance.\n        Participant storage participant = pool.participantToData[msg.sender];                        \n        uint finalAmount;\n        \n        if(amount == 0) {\n            // If withdrawal amount is equal to zero then withdraw entire contribution.\n            finalAmount = participant.contribution[idx] + participant.remaining[idx];\n        } else {\n            // Requested withdrawal amount must be equal or greater than participant \n            // remaining balance, but less or equal than his total contribution.\n            require(amount >= participant.remaining[idx]);\n            require(amount <= participant.contribution[idx] + participant.remaining[idx]);\n            finalAmount = amount;\n        }\n\n        require(finalAmount > 0);\n        \n        // Get group instance.\n        Group storage group = pool.groups[idx];\n\n        // Update group remaining balance.\n        group.remaining -= participant.remaining[idx];        \n\n        // Check if withdrawal amount is greater than remaining balance.\n        uint extra = finalAmount - participant.remaining[idx];        \n\n        // Update participant remaining balance. At this point always zero.\n        participant.remaining[idx] = 0;        \n\n        if(extra > 0) {\n            // Update group and participant contribution balance.\n            participant.contribution[idx] -= extra;\n            group.contribution -= extra;            \n\n            if(!participant.isAdmin) {\n                // Make sure that requested withdrawal amount won't break group settings.\n                require(participant.contribution[idx] >= group.minContribution);\n            }\n        }\n\n        // Transfer funds.\n        addressTransfer(msg.sender, finalAmount);\n\n        emit Withdrawal(\n            msg.sender,\n            finalAmount,\n            participant.contribution[idx],\n            0,\n            group.contribution,\n            group.remaining,\n            idx\n        );                        \n    } \n\n    /**\n     * @dev Wihdraw 'All-in-One' function (public wrapper).     \n     */ \n    function withdrawAll(Pool storage pool) public {\n\n        // Withdraw refund share and tokens share.\n        if (pool.state == State.FullRefund || pool.state == State.Distribution) {\n            withdrawRefundAndTokens(pool);\n            return;\n        }\n        \n        // Withdraw entire contribution balance.\n        if(pool.state == State.Canceled || pool.state == State.Open) {\n            withdrawAllContribution(pool);\n            return;\n        }            \n        \n        // Withdraw remaining balance.\n        if (pool.state == State.PaidToPresale) {\n            withdrawAllRemaining1(pool);\n            return;\n        } \n\n        // Revert transaction.\n        revert();\n    }\n\n    /**\n     * @dev ERC223 fallback.\n     */\n    function tokenFallback(Pool storage pool, address from, uint value, bytes data)\n        public \n        onlyInStates2(pool, State.PaidToPresale, State.Distribution)\n    {\n        emit ERC223Fallback(\n            msg.sender,\n            from,\n            value,\n            data\n        );\n    }    \n\n    /**\n     * @dev Accept refund transfer.     \n     */\n    function acceptRefundTransfer(Pool storage pool)\n        public \n        onlyInStates2(pool, State.Distribution, State.FullRefund)  \n    {\n        require(msg.value > 0);\n        require(msg.sender == pool.refundAddress);\n\n        emit RefundReceived(\n            msg.sender, \n            msg.value\n        );\n    }  \n\n    /**\n     * @dev Returns pool details (part #1).\n     */\n    function getPoolDetails1(Pool storage pool) \n        public view \n        returns (     \n            uint libVersion,\n            uint groupsCount,\n            uint currentState,\n            uint svcFeePerEther,\n            bool feeToTokenMode,            \n            address presaleAddress,\n            address feeToTokenAddress,            \n            address[] participants,\n            address[] admins\n        )\n    {\n        libVersion = version();\n        currentState = uint(pool.state);\n        groupsCount = pool.groups.length;\n        svcFeePerEther = pool.svcFeePerEther;\n        feeToTokenMode = pool.feeToTokenMode;        \n        presaleAddress = pool.presaleAddress;\n        feeToTokenAddress = pool.feeToTokenAddress;        \n        participants = pool.participants;\n        admins = pool.admins;\n    }  \n\n    /**\n     * @dev Returns pool details (part #2).\n     */\n    function getPoolDetails2(Pool storage pool) \n        public view \n        returns (      \n            uint refundBalance,\n            address refundAddress,\n            address[] tokenAddresses,\n            uint[] tokenBalances\n        )\n    {                                                \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {                 \n            uint poolRemaining;\n            (,poolRemaining,) = calcPoolSummary(pool);\n            refundBalance = address(this).balance - poolRemaining;\n            refundAddress = pool.refundAddress;\n            \n            tokenAddresses = pool.tokenAddresses;\n            tokenBalances = new uint[](tokenAddresses.length);\n            for(uint i = 0; i < tokenAddresses.length; i++) {\n                tokenBalances[i] = IERC20Base(tokenAddresses[i]).balanceOf(address(this));\n            }\n        }\n    }\n\n    /**\n     * @dev Returns participant details.\n     */\n    function getParticipantDetails(Pool storage pool, address addr)\n        public view \n        returns (\n            uint[] contribution,\n            uint[] remaining,\n            bool[] whitelist,\n            bool isAdmin,\n            bool exists\n        ) \n    {\n        Participant storage part = pool.participantToData[addr];\n        isAdmin = part.isAdmin;                \n        exists = part.exists;\n\n        uint length = pool.groups.length;\n        contribution = new uint[](length);\n        remaining = new uint[](length);\n        whitelist = new bool[](length);        \n\n        for(uint i = 0; i < length; i++) {\n            contribution[i] = part.contribution[i];\n            remaining[i] = part.remaining[i];\n            whitelist[i] = part.whitelist[i];\n        }                      \n    }        \n\n    /**\n     * @dev Returns participant shares.\n     */\n    function getParticipantShares(Pool storage pool, address addr) public view returns (uint[] tokenShare, uint refundShare) {       \n        if(pool.state == State.Distribution || pool.state == State.FullRefund) {\n            uint netPoolContribution;\n            uint netPartContribution;\n            uint poolRemaining;\n            uint poolCtorFee;   \n\n            (netPoolContribution, netPartContribution, poolRemaining, poolCtorFee) = calcPoolSummary3(pool, addr);\n            tokenShare = new uint[](pool.tokenAddresses.length);\n\n            if(netPartContribution > 0) {\n                refundShare = pool.refundQuota.calcShare(\n                    addr, \n                    address(this).balance - poolRemaining,\n                    [netPartContribution, netPoolContribution]\n                );        \n            }     \n\n            if(pool.feeToTokenMode) {\n                netPoolContribution += poolCtorFee;\n                if(pool.feeToTokenAddress == addr) {\n                    netPartContribution += poolCtorFee;\n                }\n            }  \n\n            if(netPartContribution > 0) {\n                for(uint i = 0; i < pool.tokenAddresses.length; i++) {\n                    tokenShare[i] = pool.tokenQuota[pool.tokenAddresses[i]].calcShare(\n                        addr,\n                        IERC20Base(pool.tokenAddresses[i]).balanceOf(address(this)),\n                        [netPartContribution, netPoolContribution]\n                    );                \n                }      \n            }\n        }  \n    }    \n\n    /**\n     * @dev Returns group details.\n     */\n    function getGroupDetails(Pool storage pool, uint idx)\n        public view \n        returns (\n            uint contributionBalance,\n            uint remainingBalance,\n            uint maxBalance,\n            uint minContribution,                 \n            uint maxContribution,\n            uint ctorFeePerEther,\n            bool isRestricted,\n            bool exists\n        ) \n    {\n        Group storage group = pool.groups[idx];                                                \n        contributionBalance = group.contribution;\n        remainingBalance = group.remaining;\n        maxBalance = group.maxBalance;\n        minContribution = group.minContribution;\n        maxContribution = group.maxContribution;\n        ctorFeePerEther = group.ctorFeePerEther;\n        isRestricted = group.isRestricted;\n        exists = group.exists;\n    }       \n\n    /**\n     * @dev Returns library version.\n     */\n    function version() public pure returns (uint) {\n        // type: 100 \n        // major: 100\n        // minor: 100        \n        return 100100101;\n    }    \n\n    /**\n     * @dev Withdraw entire contribution balance.\n     */     \n    function withdrawAllContribution(Pool storage pool) private {        \n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint contribution;  \n        uint remaining;\n        uint amount;\n        uint sum;\n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {\n\n            // Read contribution and remaining balance.\n            contribution = participant.contribution[idx];\n            remaining = participant.remaining[idx];\n            sum = contribution + remaining;\n\n            if(sum > 0) {\n                amount += sum;\n                group = pool.groups[idx];\n\n                // Reset contribution balance.\n                if(contribution > 0) {                    \n                    group.contribution -= contribution;\n                    participant.contribution[idx] = 0;\n                }\n\n                // Reset remaining balance.\n                if(remaining > 0) {\n                    group.remaining -= remaining;\n                    participant.remaining[idx] = 0;\n                }\n                                       \n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    sum,\n                    0,\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance (simple).\n     */  \n    function withdrawAllRemaining1(Pool storage pool) private {\n        Participant storage participant = pool.participantToData[msg.sender];        \n        Group storage group;\n        uint remaining;\n        uint amount;\n        \n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {            \n            remaining = participant.remaining[idx];\n\n            // Reset remaining balance.\n            if(remaining > 0) {\n                amount += remaining;\n                group = pool.groups[idx];\n                group.remaining -= remaining;        \n                participant.remaining[idx] = 0;                                \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining\n                );\n            }\n        }\n\n        // Transfer funds.\n        require(amount > 0);\n        addressTransfer(\n            msg.sender, \n            amount\n        );\n    }\n\n    /**\n     * @dev Wihdraw remaining balance and calculate.\n     */  \n    function withdrawAllRemaining2(Pool storage pool) \n        private \n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Participant storage participant = pool.participantToData[msg.sender];\n        Group storage group;\n        uint sumRemaining; \n        uint remaining;     \n\n        // Iterate through the groups.\n        uint length = pool.groups.length;\n        for(uint idx = 0; idx < length; idx++) {                        \n            group = pool.groups[idx];\n\n            // Make required calculations.\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n            \n            // Make required calculations.\n            remaining = participant.remaining[idx];\n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n\n            // Reset remaining balance.\n            if(remaining > 0) {              \n                sumRemaining += remaining;                            \n                group.remaining -= remaining;\n                participant.remaining[idx] = 0;  \n\n                emit Withdrawal(\n                    msg.sender,\n                    idx,\n                    remaining,\n                    participant.contribution[idx],\n                    0,\n                    group.contribution,\n                    group.remaining                    \n                );\n            }\n        }\n\n        // Transfer funds.\n        if(sumRemaining > 0) {\n            poolRemaining -= sumRemaining;\n            addressTransfer(msg.sender, sumRemaining);\n        }\n    }    \n    \n    /**\n     * @dev Withdarw refund share and tokens share.\n     */  \n    function withdrawRefundAndTokens(Pool storage pool) private {\n        uint poolContribution;\n        uint poolRemaining;\n        uint poolCtorFee;\n        uint partContribution;        \n        uint partCtorFee;\n\n        // Withdraw remaining balance.\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = withdrawAllRemaining2(pool);\n\n        // Calculate net contribution values.        \n        uint netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        uint netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n        \n        if(netPartContribution > 0) {\n            // Withdraw refund share based on net contribution.\n            withdrawRefundShare(pool, poolRemaining, netPoolContribution, netPartContribution);\n        }\n\n        // 'Fee-to-Token' mode.\n        if(pool.feeToTokenMode) {\n            netPoolContribution += poolCtorFee;\n            if(pool.feeToTokenAddress == msg.sender) {\n                netPartContribution += poolCtorFee;\n            }\n        }\n\n        if(netPartContribution > 0) {\n            // Withdraw tokens share based on net contribution.\n            withdrawTokens(pool, netPoolContribution, netPartContribution);\n        }\n    }\n\n    /**\n     * @dev Withdarw refund share.\n     */\n    function withdrawRefundShare(\n        Pool storage pool, \n        uint poolRemaining,\n        uint netPoolContribution, \n        uint netPartContribution\n    )\n        private \n    {\n        if(address(this).balance > poolRemaining) {\n            // Calculate and claim refund share.\n            uint amount = pool.refundQuota.claimShare(\n                msg.sender, \n                address(this).balance - poolRemaining,\n                [netPartContribution, netPoolContribution]\n            );\n\n            if(amount > 0) {          \n                // Trunsfer funds.                      \n                addressTransfer(msg.sender, amount);\n                emit RefundWithdrawal(\n                    msg.sender,\n                    address(this).balance,\n                    poolRemaining,\n                    amount\n                );                \n            }\n        }\n    }\n\n    /**\n     * @dev Withdraw tokens share.\n     */\n    function withdrawTokens(\n        Pool storage pool,        \n        uint netPoolContribution,\n        uint netPartContribution\n    )\n        private \n    {\n        bool succeeded;\n        uint tokenAmount;\n        uint tokenBalance;\n        address tokenAddress;\n        IERC20Base tokenContract;\n        QuotaLib.Storage storage quota;\n\n        // Iterate through the token addresses.\n        uint length = pool.tokenAddresses.length;\n        for(uint i = 0; i < length; i++) {             \n\n            tokenAddress = pool.tokenAddresses[i];            \n            tokenContract = IERC20Base(tokenAddress); \n            // Get token balance for the pool address.\n            tokenBalance = tokenContract.balanceOf(address(this));\n\n            if(tokenBalance > 0) {    \n                // Calculate and claim the token share.                                    \n                quota = pool.tokenQuota[tokenAddress];\n                tokenAmount = quota.claimShare(\n                    msg.sender,\n                    tokenBalance, \n                    [netPartContribution, netPoolContribution]\n                ); \n\n                if(tokenAmount > 0) {\n                    // Try to transfer tokens.\n                    succeeded = tokenContract.transfer(msg.sender, tokenAmount);\n                    if (!succeeded) {                        \n                        quota.undoClaimShare(msg.sender, tokenAmount);\n                    }\n                    emit TokenWithdrawal(\n                        tokenAddress,\n                        msg.sender,\n                        tokenBalance,\n                        tokenAmount,\n                        succeeded\n                    );\n                }\n            }\n        } \n    }   \n\n    /**\n     * @dev Create new participation group in case it doesn't exist otherwise update its settings.     \n     */\n    function setGroupSettingsCore(\n        Pool storage pool,        \n        uint idx,\n        uint maxBalance,\n        uint minContribution,\n        uint maxContribution,\n        uint ctorFeePerEther,         \n        bool isRestricted\n    )\n        private             \n    {\n        require(pool.groups.length > idx);\n        Group storage group = pool.groups[idx];        \n        \n        if(!group.exists) {\n            // Create new group. Pool groups should be created one-by-one.\n            require(idx == 0 || pool.groups[idx - 1].exists);\n            group.exists = true;\n        }\n        \n        validateGroupSettings(\n            maxBalance, \n            minContribution, \n            maxContribution\n        );        \n        \n        if(group.maxBalance != maxBalance) {\n            group.maxBalance = maxBalance;  \n        }          \n        \n        if(group.minContribution != minContribution) {\n            group.minContribution = minContribution;\n        }\n\n        if(group.maxContribution != maxContribution) {\n            group.maxContribution = maxContribution;\n        }\n        \n        if(group.ctorFeePerEther != ctorFeePerEther) {\n            require(ctorFeePerEther <= (1 ether / 2));\n            group.ctorFeePerEther = ctorFeePerEther;\n        }\n        \n        if(group.isRestricted != isRestricted) {\n            group.isRestricted = isRestricted;  \n        }      \n\n        emit GroupSettingsChanged(\n            idx,\n            maxBalance,\n            minContribution,\n            maxContribution,\n            ctorFeePerEther,\n            isRestricted\n        );                             \n    }    \n\n    /**\n     * @dev Modify group whitelist.\n     */\n    function modifyWhitelistCore(Pool storage pool, uint idx, address[] include, address[] exclude) private {\n        require(include.length > 0 || exclude.length > 0);\n        require(pool.groups.length > idx && pool.groups[idx].exists);\n\n        // Get group and participant instances.\n        Group storage group = pool.groups[idx];\n        Participant storage participant;        \n        uint i;\n\n        // Mark group as restricted.\n        if(!group.isRestricted) {\n            group.isRestricted = true;\n            emit WhitelistEnabled(idx);\n        }    \n\n        // Exclude participants.\n        for(i = 0; i < exclude.length; i++) {\n            participant = pool.participantToData[exclude[i]];            \n            if(participant.whitelist[idx]) {\n                participant.whitelist[idx] = false;\n                emit ExcludedFromWhitelist(\n                    exclude[i],\n                    idx\n                );                \n            }\n        }\n\n        // Include participants.\n        for(i = 0; i < include.length; i++) {\n            participant = pool.participantToData[include[i]];  \n\n            if(!participant.whitelist[idx]) { \n                // Create new participant.\n                if (!participant.exists) {                    \n                    pool.participants.push(include[i]);\n                    participant.exists = true;                                        \n                }                        \n\n                // Set as whitelisted.\n                participant.whitelist[idx] = true;               \n                emit IncludedInWhitelist(\n                    include[i],\n                    idx\n                );\n            }                \n        }\n    }        \n\n    /**\n     * @dev Distribute fees. When calling this function, contract balance should\n     *  consist of participants remaining balance, creator commission and service commission.\n     */\n    function sendFees(Pool storage pool) private {\n        uint ctorFee;\n        uint poolRemaining;\n        uint poolContribution;\n        // Calculate and transfer creator fee.\n        (poolContribution, poolRemaining, ctorFee) = calcPoolSummary(pool);\n        if(ctorFee > 0 && !pool.feeToTokenMode) {\n            addressTransfer(msg.sender, ctorFee);            \n        }\n        \n        // Calculate and transfer service fee.\n        uint svcFee = address(this).balance - poolRemaining;        \n        if(svcFee > 0) {\n            address creator = getPoolCreator(pool);\n            pool.feeService.sendFee.value(svcFee)(creator);\n        }\n\n        emit FeesDistributed(\n            ctorFee,\n            svcFee\n        );\n    }   \n\n    /**\n     * @dev Rebalance group contributions.\n     */\n    function groupRebalance(Pool storage pool, uint idx) private {\n        Group storage group = pool.groups[idx];          \n        uint maxBalance = group.maxBalance;\n        uint minContribution = group.minContribution;    \n        uint maxContribution = group.maxContribution;            \n        bool isRestricted = group.isRestricted;        \n        Participant storage participant;         \n        uint groupContribution;\n        uint groupRemaining;\n        uint contribution;\n        uint remaining;     \n        uint x = idx;   \n\n        // TODO: Getting stack too deep here..\n        // uint length = pool.participants.length;\n        for(uint i = 0; i < pool.participants.length; i++) {           \n            participant = pool.participantToData[pool.participants[i]];                \n            \n            // Calculate contribution and remaining balance.\n            (contribution, remaining) = calcContribution(       \n                x,\n                0,\n                maxBalance,\n                groupContribution,\n                minContribution,\n                maxContribution,\n                isRestricted,\n                participant\n            );        \n\n            // Save changes if some available.\n            if(contribution != participant.contribution[x]) {\n                participant.contribution[x] = contribution;\n                participant.remaining[x] = remaining;\n            }            \n            \n            groupContribution += contribution;            \n            groupRemaining += remaining;\n\n            emit ContributionAdjusted(\n                pool.participants[i], \n                contribution,\n                remaining,\n                groupContribution,\n                groupRemaining,\n                x\n            );\n        }\n        \n        // Update group contribution and remaining balance.\n        if(group.contribution != groupContribution) {\n            group.contribution = groupContribution;             \n            group.remaining = groupRemaining;           \n        }  \n    } \n\n    /**\n     * @dev Change pool state.\n     */\n    function changeState(Pool storage pool, State state) private {\n        assert(pool.state != state);\n        emit StateChanged(\n            uint(pool.state), \n            uint(state)\n        );\n        pool.state = state;        \n    }\n\n    /**\n     * @dev Add pool admin.\n     */\n    function addAdmin(Pool storage pool, address admin) private {\n        require(admin != address(0));\n        Participant storage participant = pool.participantToData[admin];\n        require(!participant.exists && !participant.isAdmin);\n\n        participant.exists = true;\n        participant.isAdmin = true;\n        pool.participants.push(admin);\n        pool.admins.push(admin);             \n        \n        emit AdminAdded(admin);                  \n    }  \n\n    /**\n     * @dev Trusted transfer.\n     */\n    function addressTransfer(address destination, uint etherAmount) private {\n        emit AddressTransfer(\n            destination,\n            etherAmount\n        );\n        destination.transfer(etherAmount);        \n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint etherAmount, bytes data) private {\n        addressCall(destination, 0, etherAmount, data);\n    }\n\n    /**\n     * @dev Untrasted call.\n     */\n    function addressCall(address destination, uint gasAmount,  uint etherAmount, bytes data) private {\n        emit AddressCall(\n            destination,\n            etherAmount,\n            gasAmount > 0 ? gasAmount : gasleft(),\n            data\n        );\n        require(\n            destination.call\n            .gas(gasAmount > 0 ? gasAmount : gasleft())\n            .value(etherAmount)\n            (data)            \n        );\n    }\n\n    /**\n     * @dev Calculate participant contribution.\n     */\n    function calcContribution(\n        uint idx,\n        uint amount,\n        uint maxBalance,\n        uint currentBalance,\n        uint minContribution, \n        uint maxContribution,\n        bool isRestricted,        \n        Participant storage participant\n    )\n        private view \n        returns(uint contribution, uint remaining)\n    {\n        // Total contribution amount.\n        uint totalAmount = participant.contribution[idx]\n            + participant.remaining[idx]\n            + amount;\n\n        // There are no limitations for admins.\n        if(participant.isAdmin) {\n            contribution = totalAmount;\n            return;\n        }                \n\n        // Limitations on group max balance & whitelist.\n        if(currentBalance >= maxBalance || (isRestricted && !participant.whitelist[idx])) {\n            remaining = totalAmount;            \n            return;\n        }        \n                        \n        contribution = Math.min(maxContribution, totalAmount);        \n        contribution = Math.min(maxBalance - currentBalance, contribution);\n        \n        // Limitation on group min contribution.\n        if(contribution < minContribution) {\n            remaining = totalAmount;\n            contribution = 0;\n            return;\n        }\n                \n        remaining = totalAmount - contribution;\n    }\n\n    /**\n     * @dev Calculate pool summaries.\n     */\n    function calcPoolSummary(Pool storage pool) \n        private view \n        returns\n    (\n        uint poolContribution, \n        uint poolRemaining, \n        uint ctorFee\n    ) \n    {\n        Group storage group;\n        uint length = pool.groups.length;\n\n        for(uint idx = 0; idx < length; idx++) {\n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n            \n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;            \n            ctorFee += calcFee(group.contribution, group.ctorFeePerEther);\n        }\n    }  \n\n    /**\n     * @dev Calculate pool & participant summaries.\n     */  \n    function calcPoolSummary2(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint poolContribution,\n        uint poolRemaining,\n        uint poolCtorFee,\n        uint partContribution,        \n        uint partCtorFee\n    ) \n    {\n        Group storage group;\n        Participant storage participant = pool.participantToData[addr];        \n        uint length = pool.groups.length;\n        \n        for(uint idx = 0; idx < length; idx++) {            \n            group = pool.groups[idx];\n            if(!group.exists) {\n                break;\n            }\n\n            poolRemaining += group.remaining;\n            poolContribution += group.contribution;\n            poolCtorFee += calcFee(group.contribution, group.ctorFeePerEther);\n                        \n            partContribution += participant.contribution[idx];\n            partCtorFee += calcFee(participant.contribution[idx], group.ctorFeePerEther);\n        }\n    }     \n\n    /**\n     * @dev Calculate pool & participant net summaries.\n     */   \n    function calcPoolSummary3(Pool storage pool, address addr) \n        private view\n        returns\n    (\n        uint netPoolContribution,\n        uint netPartContribution,\n        uint poolRemaining,\n        uint poolCtorFee\n    ) \n    {\n        uint poolContribution;        \n        uint partContribution;\n        uint partCtorFee;\n\n        (poolContribution, \n            poolRemaining, \n            poolCtorFee, \n            partContribution,             \n            partCtorFee\n        ) = calcPoolSummary2(pool, addr);\n\n        netPoolContribution = poolContribution - poolCtorFee - calcFee(poolContribution, pool.svcFeePerEther);\n        netPartContribution = partContribution - partCtorFee - calcFee(partContribution, pool.svcFeePerEther);\n    }          \n  \n    /**\n     * @dev Function for validating group settings.\n     */\n    function validateGroupSettings(uint maxBalance, uint minContribution, uint maxContribution) private pure {\n        require(\n            minContribution > 0 &&\n            minContribution <= maxContribution &&\n            maxContribution <= maxBalance &&\n            maxBalance <= 1e9 ether            \n        );\n    }\n\n    /**\n     * @dev Check if an array contains provided value.\n     */\n    function contains(address[] storage array, address addr) private view returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == addr) {\n                return true;\n            }\n        }\n        return false;\n    } \n\n    /**\n     * @dev Returns pool creator address.\n     */\n    function getPoolCreator(Pool storage pool) private view returns(address) {\n        return pool.admins[0];\n    }     \n\n    /**\n     * @dev Fee calculator.\n     */\n    function calcFee(uint etherAmount, uint feePerEther) private pure returns(uint fee) {\n        fee = (etherAmount * feePerEther) / 1 ether;\n    }    \n\n\n    event StateChanged(\n        uint fromState,\n        uint toState\n    ); \n\n    event AdminAdded(\n        address adminAddress\n    );\n\n    event WhitelistEnabled(\n        uint groupIndex\n    );\n\n    event PresaleAddressLocked(\n        address presaleAddress\n    );  \n\n    event RefundAddressChanged(\n        address refundAddress\n    );    \n\n    event FeesDistributed(\n        uint creatorFeeAmount,\n        uint serviceFeeAmount\n    );\n\n    event IncludedInWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );\n\n    event ExcludedFromWhitelist(\n        address participantAddress,\n        uint groupIndex\n    );  \n\n    event FeeServiceAttached(\n        address serviceAddress,\n        uint feePerEther\n    );    \n\n    event TokenAddressConfirmed(\n        address tokenAddress,\n        uint tokenBalance\n    ); \n\n    event RefundReceived(\n        address senderAddress,\n        uint etherAmount\n    );    \n \n    event Contribution(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint groupContribution        \n    );\n\n    event Withdrawal(\n        address participantAddress,\n        uint groupIndex,\n        uint etherAmount,\n        uint participantContribution,\n        uint participantRemaining,        \n        uint groupContribution,\n        uint groupRemaining\n    );\n\n    event TokenWithdrawal(\n        address tokenAddress,\n        address participantAddress,\n        uint poolTokenBalance,\n        uint tokenAmount,\n        bool succeeded    \n    );   \n\n    event RefundWithdrawal(\n        address participantAddress,\n        uint contractBalance,\n        uint poolRemaining,\n        uint etherAmount\n    );  \n\n    event ContributionAdjusted(\n        address participantAddress,\n        uint participantContribution,\n        uint participantRemaining,\n        uint groupContribution,\n        uint groupRemaining,\n        uint groupIndex\n    );\n  \n    event GroupSettingsChanged(\n        uint index,\n        uint maxBalance,                               \n        uint minContribution,\n        uint maxContribution,                        \n        uint ctorFeePerEther,\n        bool isRestricted                            \n    );       \n\n    event AddressTransfer(\n        address destinationAddress,\n        uint etherValue\n    );\n\n    event AddressCall(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data      \n    );   \n\n    event TransactionForwarded(\n        address destinationAddress,\n        uint etherAmount,\n        uint gasAmount,\n        bytes data\n    );\n\n    event ERC223Fallback(\n        address tokenAddress,\n        address senderAddress,\n        uint tokenAmount,\n        bytes data\n    );   \n}",
        "filename": "Dapp_dataset/positive/DAppSCAN-source/contracts/Coinfabrik-EasyPool Smart Contract Security Audit v2/EasyPool-master/contracts/library/ProPoolLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `withdrawAmount` function decreases the group remaining balance before checking if the withdrawal amount is greater than the remaining balance, which can lead to an integer underflow."
    },
    {
        "code_segment": "contract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-GSPI Club-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Pausable.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses \"SafeMath\" library for all arithmetic operations on uint256, preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract ERC721Pausable is ERC721, Pausable {\n  function approve(\n    address to,\n    uint256 tokenId\n  )\n    public\n    whenNotPaused\n  {\n    super.approve(to, tokenId);\n  }\n\n  function setApprovalForAll(\n    address to,\n    bool approved\n  )\n    public\n    whenNotPaused\n  {\n    super.setApprovalForAll(to, approved);\n  }\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n    whenNotPaused\n  {\n    super.transferFrom(from, to, tokenId);\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-GSPI Club-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Pausable.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any arithmetic operations that could lead to an integer overflow."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses inline assembly to handle arithmetic operations and includes checks to detect and handle overflow or underflow conditions."
    },
    {
        "code_segment": "library BasicMathLib {\n  \n  \n  \n  \n  \n  \n  function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := mul(a,b)\n      switch or(iszero(b), eq(div(res,b), a))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) {\n    uint256 res;\n    assembly{\n      switch iszero(b)\n      case 0 {\n        res := div(a,b)\n        let loc := mload(0x40)\n        mstore(add(loc,0x20),res)\n        i := mload(add(loc,0x20))\n      }\n      default {\n        err := 1\n        i := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) {\n    assembly{\n      res := add(a,b)\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n\n  \n  \n  \n  \n  \n  \n  function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) {\n    assembly{\n      res := sub(a,b)\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\n      case 0 {\n        err := 1\n        res := 0\n      }\n    }\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `minus` function does not check if `b` is greater than `a` before performing the subtraction, leading to an integer underflow if `b` is larger than `a`."
    },
    {
        "code_segment": "library TokenLib {\n  using BasicMathLib for uint256;\n\n  struct TokenStorage {\n    bool initialized;\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    string name;\n    string symbol;\n    uint256 totalSupply;\n    uint256 initialSupply;\n    address owner;\n    uint8 decimals;\n    bool stillMinting;\n  }\n\n  event Transfer(address indexed from, address indexed to, uint256 value);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n  event OwnerChange(address from, address to);\n  event Burn(address indexed burner, uint256 value);\n  event MintingClosed(bool mintingClosed);\n\n  \n  \n  \n  \n  \n  \n  \n  function init(TokenStorage storage self,\n                address _owner,\n                string _name,\n                string _symbol,\n                uint8 _decimals,\n                uint256 _initial_supply,\n                bool _allowMinting)\n                public\n  {\n    require(!self.initialized);\n    self.initialized = true;\n    self.name = _name;\n    self.symbol = _symbol;\n    self.totalSupply = _initial_supply;\n    self.initialSupply = _initial_supply;\n    self.decimals = _decimals;\n    self.owner = _owner;\n    self.stillMinting = _allowMinting;\n    self.balances[_owner] = _initial_supply;\n  }\n\n  \n  \n  \n  \n  \n  function transfer(TokenStorage storage self, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    bool err;\n    uint256 balance;\n\n    (err,balance) = self.balances[msg.sender].minus(_value);\n    require(!err);\n    self.balances[msg.sender] = balance;\n    //It's not possible to overflow token supply\n    self.balances[_to] = self.balances[_to] + _value;\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  \n  function transferFrom(TokenStorage storage self,\n                        address _from,\n                        address _to,\n                        uint256 _value)\n                        public\n                        returns (bool)\n  {\n    var _allowance = self.allowed[_from][msg.sender];\n    bool err;\n    uint256 balanceOwner;\n    uint256 balanceSpender;\n\n    (err,balanceOwner) = self.balances[_from].minus(_value);\n    require(!err);\n\n    (err,balanceSpender) = _allowance.minus(_value);\n    require(!err);\n\n    self.balances[_from] = balanceOwner;\n    self.allowed[_from][msg.sender] = balanceSpender;\n    self.balances[_to] = self.balances[_to] + _value;\n\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  function balanceOf(TokenStorage storage self, address _owner) public view returns (uint256 balance) {\n    return self.balances[_owner];\n  }\n\n  \n  \n  \n  \n  \n  function approve(TokenStorage storage self, address _spender, uint256 _value) public returns (bool) {\n    // must set to zero before changing approval amount in accordance with spec\n    require((_value == 0) || (self.allowed[msg.sender][_spender] == 0));\n\n    self.allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  \n  \n  \n  \n  \n  function allowance(TokenStorage storage self, address _owner, address _spender)\n                     public\n                     view\n                     returns (uint256 remaining) {\n    return self.allowed[_owner][_spender];\n  }\n\n  \n  \n  \n  \n  \n  \n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\n                          public returns (bool)\n  {\n    uint256 _newAllowed;\n    bool err;\n\n    if(_increase) {\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\n      require(!err);\n\n      self.allowed[msg.sender][_spender] = _newAllowed;\n    } else {\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\n        self.allowed[msg.sender][_spender] = 0;\n      } else {\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\n        self.allowed[msg.sender][_spender] = _newAllowed;\n      }\n    }\n\n    Approval(msg.sender, _spender, _newAllowed);\n    return true;\n  }\n\n  \n  \n  \n  \n  function changeOwner(TokenStorage storage self, address _newOwner) public returns (bool) {\n    require((self.owner == msg.sender) && (_newOwner > 0));\n\n    self.owner = _newOwner;\n    OwnerChange(msg.sender, _newOwner);\n    return true;\n  }\n\n  \n  \n  \n  \n  function mintToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n    require((self.owner == msg.sender) && self.stillMinting);\n    uint256 _newAmount;\n    bool err;\n\n    (err, _newAmount) = self.totalSupply.plus(_amount);\n    require(!err);\n\n    self.totalSupply =  _newAmount;\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\n    Transfer(0x0, self.owner, _amount);\n    return true;\n  }\n\n  \n  \n  \n  function closeMint(TokenStorage storage self) public returns (bool) {\n    require(self.owner == msg.sender);\n\n    self.stillMinting = false;\n    MintingClosed(true);\n    return true;\n  }\n\n  \n  \n  \n  \n  function burnToken(TokenStorage storage self, uint256 _amount) public returns (bool) {\n      uint256 _newBalance;\n      bool err;\n\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\n      require(!err);\n\n      self.balances[msg.sender] = _newBalance;\n      self.totalSupply = self.totalSupply - _amount;\n      Burn(msg.sender, _amount);\n      Transfer(msg.sender, 0x0, _amount);\n      return true;\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-Modular_Interactive_Crowdsale/ethereum-libraries-73abc22623e0841b8ea67a5089002f4867102672/CrowdsaleLib/EvenDistroCrowdsale/truffle/contracts/TokenLib.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The operations `self.balances[_to] = self.balances[_to] + _value;` and `self.balances[_to] = self.balances[_to] + _value;` in the `transfer` and `transferFrom` functions respectively are vulnerable to integer overflow."
    },
    {
        "code_segment": "contract Lockable is Ownable {\n\t// Events\n\tevent Unlocked();\n\tevent Locked();\n\n\t// Modifiers\n\t/**\n\t* @dev Modifier that disables functions by default unless they are explicitly enabled\n\t*/\n\tmodifier whenUnlocked() {\n\t\trequire(!isLocked(), \"Contact is locked\");\n\t\t_;\n\t}\n\n\t// Methods\n\t/**\n\t* @dev called by the owner to enable method\n\t*/\n\tfunction unlock() public onlyOwner  {\n\t\tsetLock(false);\n\t\temit Unlocked();\n\t}\n\n\t/**\n\t* @dev called by the owner to disable method, back to normal state\n\t*/\n\tfunction lock() public  onlyOwner {\n\t\tsetLock(true);\n\t\temit Locked();\n\t}\n\n\tfunction setLock(bool value) internal {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v = value ? 1 : 0;\n        assembly {\n            sstore(slot, v)\n        }\n    }\n\n    function isLocked() public view returns (bool) {\n        bytes32 slot = keccak256(abi.encode(\"Lockable\", \"lock\"));\n        uint256 v;\n        assembly {\n            v := sload(slot)\n        }\n        return v != 0;\n    }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/QuillAudits-Akropolis-Vesting/AkropolisToken-28a415392489a1a88073c3d0fd22b141f4d3170e/contracts/helpers/Lockable.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided smart contract code does not perform any arithmetic operations that could result in an integer underflow."
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: There are no arithmetic operations in the provided code segment that could lead to an integer overflow."
    },
    {
        "code_segment": "contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken, FractionalERC20, LostAndFoundToken {\n\n  string public name = \"BurgerKoenig\";\n\n  string public symbol = \"BK\";\n\n  address public lost_and_found_master;\n\n  /**\n   * Construct the token.\n   *\n   * This token must be created through a team multisig wallet, so that it is owned by that wallet.\n   *\n   * @param initial_supply How many tokens we start with.\n   * @param token_decimals Number of decimal places.\n   * @param team_multisig Address of the multisig that receives the initial supply and is set as the upgrade master.\n   * @param mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends.\n   * @param token_retriever Address of the account that handles ERC20 tokens that were accidentally sent to this contract.\n   */\n  function CrowdsaleToken(uint initial_supply, uint8 token_decimals, address team_multisig, bool mintable, address token_retriever) public\n  UpgradeableToken(team_multisig) MintableToken(initial_supply, team_multisig, mintable) {\n    require(token_retriever != address(0));\n    decimals = token_decimals;\n    lost_and_found_master = token_retriever;\n  }\n\n  /**\n   * When token is released to be transferable, prohibit new token creation.\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    mintingFinished = true;\n    super.releaseTokenTransfer();\n  }\n\n  /**\n   * Allow upgrade agent functionality to kick in only if the crowdsale was a success.\n   */\n  function canUpgrade() public constant returns(bool) {\n    return released && super.canUpgrade();\n  }\n\n  function getLostAndFoundMaster() internal constant returns(address) {\n    return lost_and_found_master;\n  }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided contract code does not include any arithmetic operations that would be prone to integer underflow vulnerabilities."
    },
    {
        "code_segment": "contract ReleasableToken is StandardToken, Ownable {\n\n  /* The finalizer contract that allows lifting the transfer limits on this token */\n  address public releaseAgent;\n\n  /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/\n  bool public released = false;\n\n  /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */\n  mapping (address => bool) public transferAgents;\n\n  /**\n   * Set the contract that can call release and make the token transferable.\n   *\n   * Since the owner of this contract is (or should be) the crowdsale,\n   * it can only be called by a corresponding exposed API in the crowdsale contract in case of input error.\n   */\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\n    // We don't do interface check here as we might want to have a normal wallet address to act as a release agent.\n    releaseAgent = addr;\n  }\n\n  /**\n   * Owner can allow a particular address (e.g. a crowdsale contract) to transfer tokens despite the lock up period.\n   */\n  function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public {\n    transferAgents[addr] = state;\n  }\n\n  /**\n   * One way function to release the tokens into the wild.\n   *\n   * Can be called only from the release agent that should typically be the finalize agent ICO contract.\n   * In the scope of the crowdsale, it is only called if the crowdsale has been a success (first milestone reached).\n   */\n  function releaseTokenTransfer() public onlyReleaseAgent {\n    released = true;\n  }\n\n  /**\n   * Limit token transfer until the crowdsale is over.\n   */\n  modifier canTransfer(address sender) {\n    require(released || transferAgents[sender]);\n    _;\n  }\n\n  /** The function can be called only before or after the tokens have been released */\n  modifier inReleaseState(bool releaseState) {\n    require(releaseState == released);\n    _;\n  }\n\n  /** The function can be called only by a whitelisted release agent. */\n  modifier onlyReleaseAgent() {\n    require(msg.sender == releaseAgent);\n    _;\n  }\n\n  /** We restrict transfer by overriding it */\n  function transfer(address to, uint value) public canTransfer(msg.sender) returns (bool success) {\n    // Call StandardToken.transfer()\n   return super.transfer(to, value);\n  }\n\n  /** We restrict transferFrom by overriding it */\n  function transferFrom(address from, address to, uint value) public canTransfer(from) returns (bool success) {\n    // Call StandardToken.transferForm()\n    return super.transferFrom(from, to, value);\n  }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not contain any arithmetic operations or unchecked operations that could lead to an integer overflow."
    },
    {
        "code_segment": "contract StandardToken is BasicToken, ERC20 {\n\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address from, address to, uint value) public returns (bool success) {\n    uint allowance = allowed[from][msg.sender];\n\n    // Check is not needed because sub(allowance, value) will already throw if this condition is not met\n    // require(value <= allowance);\n    // SafeMath uses assert instead of require though, beware when using an analysis tool\n\n    balances[from] = balances[from].sub(value);\n    balances[to] = balances[to].add(value);\n    allowed[from][msg.sender] = allowance.sub(value);\n    Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint value) public returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses'\n    //  allowance to zero by calling `approve(spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require (value == 0 || allowed[msg.sender][spender] == 0);\n\n    allowed[msg.sender][spender] = value;\n    Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param account address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address account, address spender) public constant returns (uint remaining) {\n    return allowed[account][spender];\n  }\n\n  /**\n   * Atomic increment of approved spending\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   */\n  function addApproval(address spender, uint addedValue) public\n  returns (bool success) {\n      uint oldValue = allowed[msg.sender][spender];\n      allowed[msg.sender][spender] = oldValue.add(addedValue);\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n\n  /**\n   * Atomic decrement of approved spending.\n   *\n   * Works around https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   */\n  function subApproval(address spender, uint subtractedValue) public\n  returns (bool success) {\n\n      uint oldVal = allowed[msg.sender][spender];\n\n      if (subtractedValue > oldVal) {\n          allowed[msg.sender][spender] = 0;\n      } else {\n          allowed[msg.sender][spender] = oldVal.sub(subtractedValue);\n      }\n      Approval(msg.sender, spender, allowed[msg.sender][spender]);\n      return true;\n  }\n  \n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Worldbit Token Sale Smart Contract Audit/ico-445cc0c28894a85cb58f54631666deafdd35d859/contracts/CrowdsaleToken.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath's sub and add functions, which prevent integer overflows and underflows."
    },
    {
        "code_segment": "contract LibEIP712 {\n    // EIP191 header for EIP712 prefix\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\n\n    // EIP712 Domain Name value\n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\n\n    // EIP712 Domain Version value\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\n\n    // Hash of the EIP712 Domain Separator Schema\n    bytes32 public constant EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"EIP712Domain(\",\n        \"string name,\",\n        \"string version,\",\n        \"address verifyingContract\",\n        \")\"\n    ));\n\n    // Hash of the EIP712 Domain Separator data\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public EIP712_DOMAIN_HASH;\n\n    constructor ()\n        public\n    {\n        EIP712_DOMAIN_HASH = keccak256(abi.encode(\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\n            address(this)\n        ));\n    }\n\n    \n    \n    \n    function hashEIP712Message(bytes32 hashStruct)\n        internal\n        view\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(EIP191_HEADER, EIP712_DOMAIN_HASH, hashStruct));\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IExchangeCore.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code provided primarily deals with hashing and string constants without any arithmetic operations that could lead to an integer underflow vulnerability."
    },
    {
        "code_segment": "contract LibOrder is\n    LibEIP712 {\n\n    // Hash for the EIP712 Order Schema\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\n        \"Order(\",\n        \"address makerAddress,\",\n        \"address takerAddress,\",\n        \"address feeRecipientAddress,\",\n        \"address senderAddress,\",\n        \"uint256 makerAssetAmount,\",\n        \"uint256 takerAssetAmount,\",\n        \"uint256 makerFee,\",\n        \"uint256 takerFee,\",\n        \"uint256 expirationTimeSeconds,\",\n        \"uint256 salt,\",\n        \"bytes makerAssetData,\",\n        \"bytes takerAssetData\",\n        \")\"\n    ));\n\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\n    // An order's state is unaffected by external factors, like account balances.\n    enum OrderStatus {\n        INVALID,                     // Default value\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\n        FILLABLE,                    // Order is fillable\n        EXPIRED,                     // Order has already expired\n        FULLY_FILLED,                // Order is fully filled\n        CANCELLED                    // Order has been cancelled\n    }\n\n    // solhint-disable max-line-length\n    struct Order {\n        address makerAddress;           // Address that created the order.      \n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.          \n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.      \n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.        \n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.        \n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.          \n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.     \n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\n    }\n    // solhint-enable max-line-length\n\n    struct OrderInfo {\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\n    }\n\n    \n    \n    \n    function getOrderHash(Order memory order)\n        internal\n        view\n        returns (bytes32 orderHash)\n    {\n        orderHash = hashEIP712Message(hashOrder(order));\n        return orderHash;\n    }\n\n    \n    \n    \n    function hashOrder(Order memory order)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\n\n        // Assembly for more efficiently computing:\n        // keccak256(abi.encode(\n        //     order.makerAddress,\n        //     order.takerAddress,\n        //     order.feeRecipientAddress,\n        //     order.senderAddress,\n        //     order.makerAssetAmount,\n        //     order.takerAssetAmount,\n        //     order.makerFee,\n        //     order.takerFee,\n        //     order.expirationTimeSeconds,\n        //     order.salt,\n        //     keccak256(order.makerAssetData),\n        //     keccak256(order.takerAssetData)\n        // ));\n\n        assembly {\n            // Backup\n            // solhint-disable-next-line space-after-comma\n            let temp1 := mload(sub(order,  32))\n            let temp2 := mload(add(order, 320))\n            let temp3 := mload(add(order, 352))\n            \n            // Hash in place\n            // solhint-disable-next-line space-after-comma\n            mstore(sub(order,  32), schemaHash)\n            mstore(add(order, 320), makerAssetDataHash)\n            mstore(add(order, 352), takerAssetDataHash)\n            result := keccak256(sub(order, 32), 416)\n            \n            // Restore\n            // solhint-disable-next-line space-after-comma\n            mstore(sub(order,  32), temp1)\n            mstore(add(order, 320), temp2)\n            mstore(add(order, 352), temp3)\n        }\n        return result;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/protocol/Exchange/interfaces/IExchangeCore.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform any arithmetic operations that could lead to an integer underflow. It primarily deals with hashing and data storage."
    },
    {
        "code_segment": "contract TestLibBytes {\n    \n    using LibBytes for bytes;\n\n    \n    \n    \n    function publicPopLastByte(bytes memory b)\n        public\n        pure\n        returns (bytes memory, bytes1 result)\n    {\n        result = b.popLastByte();\n        return (b, result);\n    }\n\n    \n    \n    \n    function publicPopLast20Bytes(bytes memory b)\n        public\n        pure\n        returns (bytes memory, address result)\n    {\n        result = b.popLast20Bytes();\n        return (b, result);\n    }\n\n    \n    \n    \n    \n    function publicEquals(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n    \n    function publicEqualsPop1(bytes memory lhs, bytes memory rhs)\n        public\n        pure\n        returns (bool equal)\n    {\n        lhs.popLastByte();\n        rhs.popLastByte();\n        equal = lhs.equals(rhs);\n        return equal;\n    }\n\n    \n    \n    \n    function publicDeepCopyBytes(\n        bytes memory dest,\n        bytes memory source\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        LibBytes.deepCopyBytes(dest, source);\n        return dest;\n    }\n\n    \n    \n    \n    \n    function publicReadAddress(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (address result)\n    {\n        result = b.readAddress(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteAddress(\n        bytes memory b,\n        uint256 index,\n        address input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeAddress(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes32(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes32 result)\n    {\n        result = b.readBytes32(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteBytes32(\n        bytes memory b,\n        uint256 index,\n        bytes32 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytes32(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadUint256(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (uint256 result)\n    {\n        result = b.readUint256(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicWriteUint256(\n        bytes memory b,\n        uint256 index,\n        uint256 input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeUint256(index, input);\n        return b;\n    }\n\n    \n    \n    \n    \n    function publicReadBytes4(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes4 result)\n    {\n        result = b.readBytes4(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    function publicReadBytesWithLength(\n        bytes memory b,\n        uint256 index\n    )\n        public\n        pure\n        returns (bytes memory result)\n    {\n        result = b.readBytesWithLength(index);\n        return result;\n    }\n\n    \n    \n    \n    \n    \n    function publicWriteBytesWithLength(\n        bytes memory b,\n        uint256 index,\n        bytes memory input\n    )\n        public\n        pure\n        returns (bytes memory)\n    {\n        b.writeBytesWithLength(index, input);\n        return b;\n    }\n    \n    \n    \n    \n    \n    \n    \n    function testMemcpy(\n        bytes mem,\n        uint256 dest,\n        uint256 source,\n        uint256 length\n    )\n        public // not external, we need input in memory\n        pure\n        returns (bytes)\n    {\n        // Sanity check. Overflows are not checked.\n        require(source + length <= mem.length);\n        require(dest + length <= mem.length);\n\n        // Get pointer to memory contents\n        uint256 offset = mem.contentAddress();\n\n        // Execute memCopy adjusted for memory array location\n        LibBytes.memCopy(offset + dest, offset + source, length);\n\n        // Return modified memory contents\n        return mem;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/consensys-0x_Protocol_v2/0x-monorepo-a05b14e4d9659be1cc495ee33fd8962ce773f87f/packages/contracts/src/2.0.0/test/TestLibBytes/TestLibBytes.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `source + length` and `dest + length` calculations in the `testMemcpy` function are susceptible to integer overflow because the sum of two large integers can wrap around to a smaller value, bypassing the sanity checks."
    },
    {
        "code_segment": "library AddressArray {\n  function exists(address[] memory self, address addr) public pure returns(bool){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function index_of(address[] memory self, address addr) public pure returns(uint){\n    for (uint i = 0; i< self.length;i++){\n      if (self[i]==addr){\n        return i;\n      }\n    }\n    require(false, \"AddressArray:index_of, not exist\");\n  }\n\n  function remove(address[] storage self, address addr) public returns(bool){\n    uint index = index_of(self, addr);\n    self[index] = self[self.length - 1];\n\n    delete self[self.length-1];\n    self.length--;\n    return true;\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The `self.length--` operation can cause an integer underflow in versions of Solidity before 0.8, which by default does not check for underflows. In versions 0.8 and above, this would throw an error."
    },
    {
        "code_segment": "contract DummyDex {\n  using SafeMath for uint256;\n\n  function getAmountsOut(uint256 amountIn, address[] memory path) public view returns(uint256[] memory){\n    uint256[] memory k = new uint256[](path.length);\n    for(uint i = 0; i < path.length; i ++){\n      uint256 t = amountIn.safeMul(uint256(10)**ERC20Base(path[i]).decimals()).safeDiv(uint256(10) **ERC20Base(path[0]).decimals());\n      k[i] = t;\n    }\n    return k;\n  }\n  function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] memory path, address to, uint256 deadline) public returns (uint256[] memory amounts) {\n    uint256[] memory k = getAmountsOut(amountIn, path);\n    IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\n    TokenInterface(path[path.length - 1]).generateTokens(to, k[k.length - 1]);\n    return k;\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for uint256 operations, which protects against integer overflow."
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "```plaintext\nAnswer: No\nReason: Overflow checks are implemented using require statements for arithmetic operations.\n```"
    },
    {
        "code_segment": "contract ERC20Base {\n    string public name;                //The Token's name: e.g. GTToken\n    uint8 public decimals;             //Number of decimals of the smallest unit\n    string public symbol;              //An identifier: e.g. REP\n    string public version = \"AET_0.1\"; //An arbitrary versioning scheme\n\n    using AddressArray for address[];\n    address[] public transferListeners;\n\n\n// Events\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n        );\n\n    event NewTransferListener(address _addr);\n    event RemoveTransferListener(address _addr);\n\n    \n    \n    \n    struct Checkpoint {\n        // `fromBlock` is the block number that the value was generated from\n        uint128 fromBlock;\n        // `value` is the amount of tokens at a specific block number\n        uint128 value;\n    }\n\n    // `parentToken` is the Token address that was cloned to produce this token;\n    //  it will be 0x0 for a token that was not cloned\n    ERC20Base public parentToken;\n\n    // `parentSnapShotBlock` is the block number from the Parent Token that was\n    //  used to determine the initial distribution of the Clone Token\n    uint public parentSnapShotBlock;\n\n    // `creationBlock` is the block number that the Clone Token was created\n    uint public creationBlock;\n\n    // `balances` is the map that tracks the balance of each address, in this\n    //  contract when the balance changes the block number that the change\n    //  occurred is also included in the map\n    mapping (address => Checkpoint[]) balances;\n\n    // `allowed` tracks any extra transfer rights as in all ERC20 tokens\n    mapping (address => mapping (address => uint256)) allowed;\n\n    // Tracks the history of the `totalSupply` of the token\n    Checkpoint[] totalSupplyHistory;\n\n    // Flag that determines if the token is transferable or not.\n    bool public transfersEnabled;\n\n\n// Constructor\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    constructor(\n        ERC20Base _parentToken,\n        uint _parentSnapShotBlock,\n        string memory _tokenName,\n        uint8 _decimalUnits,\n        string memory _tokenSymbol,\n        bool _transfersEnabled\n    )  public\n    {\n        name = _tokenName;                                 // Set the name\n        decimals = _decimalUnits;                          // Set the decimals\n        symbol = _tokenSymbol;                             // Set the symbol\n        parentToken = _parentToken;\n        parentSnapShotBlock = _parentSnapShotBlock;\n        transfersEnabled = _transfersEnabled;\n        creationBlock = block.number;\n    }\n\n\n\n// ERC20 Methods\n\n\n    \n    \n    \n    \n    function transfer(address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n        return doTransfer(msg.sender, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // The standard ERC 20 transferFrom functionality\n        if (allowed[_from][msg.sender] < _amount)\n            return false;\n        allowed[_from][msg.sender] -= _amount;\n        return doTransfer(_from, _to, _amount);\n    }\n\n    \n    \n    \n    \n    \n    \n    function doTransfer(address _from, address _to, uint _amount) internal returns(bool) {\n        if (_amount == 0) {\n            return true;\n        }\n        require(parentSnapShotBlock < block.number);\n        // Do not allow transfer to 0x0 or the token contract itself\n        require((_to != address(0)) && (_to != address(this)));\n        // If the amount being transfered is more than the balance of the\n        //  account the transfer returns false\n        uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n        if (previousBalanceFrom < _amount) {\n            return false;\n        }\n        // First update the balance array with the new value for the address\n        //  sending the tokens\n        updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n        // Then update the balance array with the new value for the address\n        //  receiving the tokens\n        uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n        // An event to make the transfer easy to find on the blockchain\n        emit Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    \n    \n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balanceOfAt(_owner, block.number);\n    }\n\n    \n    \n    \n    \n    \n    \n    function approve(address _spender, uint256 _amount) public returns (bool success) {\n        require(transfersEnabled);\n\n        // To change the approve amount you first have to reduce the addresses`\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\n        //  already 0 to mitigate the race condition described here:\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _amount;\n        emit Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    \n    \n    \n    \n    \n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    function approveAndCall(ApproveAndCallFallBack _spender, uint256 _amount, bytes memory _extraData) public returns (bool success) {\n        require(approve(address(_spender), _amount));\n\n        _spender.receiveApproval(\n            msg.sender,\n            _amount,\n            address(this),\n            _extraData\n        );\n\n        return true;\n    }\n\n    \n    \n    function totalSupply() public view returns (uint) {\n        return totalSupplyAt(block.number);\n    }\n\n\n\n// Query balance and totalSupply in History\n\n\n    \n    \n    \n    \n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint) {\n\n        // These next few lines are used when the balance of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.balanceOfAt` be queried at the\n        //  genesis block for that token as this contains initial balance of\n        //  this token\n        if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n            } else {\n                // Has no parent\n                return 0;\n            }\n\n        // This will return the expected balance during normal situations\n        } else {\n            return getValueAt(balances[_owner], _blockNumber);\n        }\n    }\n\n    \n    \n    \n    function totalSupplyAt(uint _blockNumber) public view returns(uint) {\n\n        // These next few lines are used when the totalSupply of the token is\n        //  requested before a check point was ever created for this token, it\n        //  requires that the `parentToken.totalSupplyAt` be queried at the\n        //  genesis block for this token as that contains totalSupply of this\n        //  token at this block number.\n        if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n            if (address(parentToken) != address(0)) {\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n            } else {\n                return 0;\n            }\n\n        // This will return the expected totalSupply during normal situations\n        } else {\n            return getValueAt(totalSupplyHistory, _blockNumber);\n        }\n    }\n\n\n// Generate and destroy tokens\n\n\n    \n    \n    \n    \n    function _generateTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n        uint previousBalanceTo = balanceOf(_owner);\n        require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n        updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n        emit Transfer(address(0), _owner, _amount);\n        return true;\n    }\n\n\n    \n    \n    \n    \n    function _destroyTokens(address _owner, uint _amount) internal returns (bool) {\n        uint curTotalSupply = totalSupply();\n        require(curTotalSupply >= _amount);\n        uint previousBalanceFrom = balanceOf(_owner);\n        require(previousBalanceFrom >= _amount);\n        updateValueAtNow(totalSupplyHistory, curTotalSupply - _amount);\n        updateValueAtNow(balances[_owner], previousBalanceFrom - _amount);\n        emit Transfer(_owner, address(0), _amount);\n        return true;\n    }\n\n\n// Enable tokens transfers\n\n\n\n    \n    \n    function _enableTransfers(bool _transfersEnabled) internal {\n        transfersEnabled = _transfersEnabled;\n    }\n\n\n// Internal helper functions to query and set a value in a snapshot array\n\n\n    \n    \n    \n    \n    function getValueAt(Checkpoint[] storage checkpoints, uint _block) internal view returns (uint) {\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\n            return checkpoints[checkpoints.length-1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length-1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock<=_block) {\n                min = mid;\n            } else {\n                max = mid-1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    \n    \n    \n    \n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value) internal {\n        if ((checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)) {\n            Checkpoint storage newCheckPoint = checkpoints[checkpoints.length++];\n            newCheckPoint.fromBlock = uint128(block.number);\n            newCheckPoint.value = uint128(_value);\n        } else {\n            Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length - 1];\n            oldCheckPoint.value = uint128(_value);\n        }\n    }\n\n    function onTransferDone(address _from, address _to, uint256 _amount) internal {\n      for(uint i = 0; i < transferListeners.length; i++){\n        TransferEventCallBack t = TransferEventCallBack(transferListeners[i]);\n        t.onTransfer(_from, _to, _amount);\n      }\n    }\n\n    function _addTransferListener(address _addr) internal {\n      transferListeners.push(_addr);\n      emit NewTransferListener(_addr);\n    }\n    function _removeTransferListener(address _addr) internal{\n      transferListeners.remove(_addr);\n      emit RemoveTransferListener(_addr);\n    }\n\n    \n    function min(uint a, uint b) pure internal returns (uint) {\n        return a < b ? a : b;\n    }\n\n    //function () external payable {\n        //require(false, \"cannot transfer ether to this contract\");\n    //}\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The function `transferFrom` in line `allowed[_from][msg.sender] -= _amount;` can cause an integer underflow if `_amount` is greater than `allowed[_from][msg.sender]`."
    },
    {
        "code_segment": "library SafeMath {\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\n        c = a + b;\n        require(c >= a, \"add\");\n    }\n    function safeSubR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b <= a, s);\n        c = a - b;\n    }\n    function safeSub(uint a, uint b) public pure returns (uint c) {\n        require(b <= a, \"sub\");\n        c = a - b;\n    }\n    function safeMul(uint a, uint b) public pure returns (uint c) {\n        c = a * b;\n        require(a == 0 || c / a == b, \"mul\");\n    }\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\n        require(b > 0, \"div\");\n        c = a / b;\n    }\n    function safeDivR(uint a, uint b, string memory s) public pure returns (uint c) {\n        require(b > 0, s);\n        c = a / b;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/SlowMist-CFFv2 Smart Contract Security Audit Report/cff-contract-v2-c86bef3f13c7585f547f9cd0ca900f94664e96b7/contracts/test/DummyDex.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The SafeMath library in the provided code includes proper checks (require statements) for preventing integer overflows and underflows."
    },
    {
        "code_segment": "contract ReferenceCosigner is RpSafeMath, SimpleDelegable, Cosigner, BytesUtils {\n    Token public rcn = Token(0x2f45b6Fb2F28A73f110400386da31044b2e953D4);\n    \n    uint private constant INDEX_COST = 0;\n    uint private constant INDEX_COVERAGE = 1;\n    uint private constant INDEX_REQUIRED_ARREARS = 2;\n    uint private constant INDEX_EXPIRATION = 3;\n    uint private constant INDEX_V = 4;\n    uint private constant INDEX_R = 5;\n    uint private constant INDEX_S = 6;\n\n    mapping(address => mapping(uint256 => Liability)) public liabilities;\n    string private infoUrl;\n\n    function url() constant public returns (string) {\n        return infoUrl;\n    }\n\n    function setUrl(string _url) public onlyOwner returns (bool) {\n        infoUrl = _url;\n        return true;\n    }\n\n    struct Liability {\n        uint256 coverage;\n        uint256 requiredArrears;\n        bool claimed;\n    }\n\n    /**\n        @dev Retrieves the cost of using this cosigner, the cost is in RCN wei. This method does not validate the\n        signature of the data.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, including the cost.\n\n        @return the cost of the insurance in RCN wei.\n    */\n    function cost(address engine, uint256 index, bytes data, bytes) constant public returns (uint256) {\n        return uint256(readBytes32(data, INDEX_COST));\n    }\n\n    /**\n        @dev Cosigns a loan, the parameters of the insurance are in the data field, and should be signed by\n        an active delegate.\n\n        @param engine Address of the engine\n        @param index Index of the loan\n        @param data Data with the params of the insurance, this contains the signature that makes the params valid.\n\n        @return true If the cosign was done\n    */\n    function requestCosign(Engine engine, uint256 index, bytes data, bytes) public returns (bool) {\n        require(msg.sender == address(engine));\n        require(expiration < block.timestamp);\n        require(liabilities[engine][index].coverage == 0);\n\n        uint256 cost = uint256(readBytes32(data, INDEX_COST));\n        uint256 coverage = uint256(readBytes32(data, INDEX_COVERAGE));\n        uint256 requiredArrears = uint256(readBytes32(data, INDEX_REQUIRED_ARREARS));\n        uint256 expiration = uint256(readBytes32(data, INDEX_EXPIRATION));\n\n        require(coverage != 0);\n\n        bytes32 hash = keccak256(this, cost, engine, index, coverage, requiredArrears, expiration);\n        address signer = ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\",hash),uint8(readBytes32(data, INDEX_V)),\n            readBytes32(data, INDEX_R),readBytes32(data, INDEX_S));\n        require(isDelegate(signer));\n        \n        liabilities[engine][index] = Liability(coverage, requiredArrears, false);\n        require(engine.cosign(index, cost));\n\n        return true;\n    }\n\n    /**\n        @dev Defines a custom logic that determines if a loan is defaulted or not.\n\n        @param index Index of the loan\n\n        @return true if the loan is considered defaulted\n    */\n    function isDefaulted(Engine engine, uint256 index) constant returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        return engine.getStatus(index) == Engine.Status.lent &&\n            safeAdd(engine.getDueTime(index), liability.requiredArrears) <= block.timestamp;\n    }\n\n    /**\n        @dev Transfers the ownership of the debt to the cosigner and the cosigner pays the benefit of the insurance\n        to the current lender. The oracle is the same used by the loan.\n\n        @param engineAddress Address of the engine\n        @param index Index of the loan\n        @param oracleData Data required by the oracle\n\n        @return true if the insurance was claimed successfully\n    */\n    function claim(address engineAddress, uint256 index, bytes oracleData) public returns (bool) {\n        Liability storage liability = liabilities[engine][index];\n        Engine engine = Engine(engineAddress);\n\n        require(!liability.claimed);\n        require(msg.sender == engine.ownerOf(index));\n\n        liability.claimed = true;\n\n        require(isDefaulted(engine, index));\n        \n        uint256 premium = safeMult(engine.getPendingAmount(index), liability.coverage) / 100;\n        require(engine.takeOwnership(index));\n\n        Oracle oracle = engine.getOracle(index);\n        uint256 rate = 1;\n\n        if (oracle != address(0)) {\n            rate = oracle.getRate(engine.getCurrency(index), oracleData);\n        }\n\n        require(rcn.transfer(msg.sender, safeMult(rate, premium)));\n        return true;\n    }\n\n    /**\n        @dev Withdraws funds from a loan\n\n        @param index Index of the loan\n        @param to Destination of the withdrawed tokens\n        @param amount Amount to withdraw\n\n        @return true if the withdraw was done successfully\n    */\n    function withdrawalFromLoan(Engine engine, uint256 index, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        return engine.withdrawal(index, to, amount);\n    }\n\n    /**\n        @dev Transfers a loan to a new owner\n\n        @param index Index of the loan\n\n        @param index Index of the loan\n        @param to New owner of the loan\n\n        @return true if the loan was transfered\n    */\n    function transferLoan(Engine engine, uint256 index, address to) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(liabilities[engine][index].claimed || liabilities[engine][index].coverage == 0);\n        return engine.transfer(to, index);\n    }\n\n\n    /**\n        @dev Withdraws tokens from the smart contract.\n\n        @param _token Token contract address\n        @param to Destination address\n        @param amount Amount to send\n\n        @return true if the withdrawal was done successfully\n    */\n    function withdrawal(Token _token, address to, uint256 amount) public onlyOwner returns (bool) {\n        require(to != address(0));\n        require(_token.transfer(to, amount));\n        return true;\n    }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-RCN Network Smart Contract Audit/rcn-network-3ded36151ad55543d16c354e70161852de4061d0/contracts/examples/ReferenceCosigner.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code utilizes safe mathematical operations through a library (RpSafeMath) to prevent overflow and underflow vulnerabilities."
    },
    {
        "code_segment": "contract CockToken is PreapprovedToken, FloatingSupplyToken {\n    function CockToken(string _name, string _symbol, uint8 _decimals) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals; \n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not include any arithmetic operations on integers that could cause an underflow."
    },
    {
        "code_segment": "contract ERC20StandardToken is IERC20Token, SafeMath {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    //tokens already issued\n    uint256 tokensIssued;\n    //balances for each account\n    mapping (address => uint256) balances;\n    //one account approves the transfer of an amount to another account\n    mapping (address => mapping (address => uint256)) allowed;\n\n    function ERC20StandardToken() public {\n     \n    }    \n\n    //\n    //IERC20Token implementation\n    // \n\n    function totalSupply() public constant returns (uint total) {\n        total = tokensIssued;\n    }\n \n    function balanceOf(address _owner) public constant returns (uint balance) {\n        balance = balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        \n        // Check for allowance is not needed because sub(_allowance, _value) will throw if this condition is not met\n        allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);        \n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n        remaining = allowed[_owner][_spender];\n    }    \n\n    //\n    // Additional functions\n    //\n    /**@dev Gets real token amount in the smallest token units */\n    function getRealTokenAmount(uint256 tokens) public constant returns (uint256) {\n        return tokens * (uint256(10) ** decimals);\n    }\n\n    //\n    // Internal functions\n    //    \n    \n    function doTransfer(address _from, address _to, uint256 _value) internal {\n        balances[_from] = safeSub(balances[_from], _value);\n        balances[_to] = safeAdd(balances[_to], _value);\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses SafeMath methods such as safeSub and safeAdd to perform mathematical operations which protect against integer underflows."
    },
    {
        "code_segment": "contract FloatingSupplyToken is MintableToken, IBurnableToken {\n    \n    event Burn(address sender, uint256 value);\n\n    function burn(uint256 amount) public {\n        balances[msg.sender] = safeSub(balances[msg.sender], amount);\n        tokensIssued = safeSub(tokensIssued, amount);\n \n        Burn(msg.sender, amount);\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: This code uses safeSub, which is a safe math operation that prevents integer underflow."
    },
    {
        "code_segment": "contract MintableToken is Manageable, ERC20StandardToken {\n\n    /** List of minters */\n    mapping(address => bool) public minters;\n\n    /**@dev Allows execution by minters only */\n    modifier minterOnly {\n        require(minters[msg.sender]);\n        _;\n    }\n\n    function MintableToken() public {\n        minters[owner] = true;        \n    }\n\n    /**@dev Allow or disallow given address to mint new tokens */\n    function setMinter(address minter, bool state) public managerOnly {\n        minters[minter] = state;\n    }\n\n    /**@dev Creates given amount of tokens*/\n    function mint(address beneficiary, uint256 amount) public minterOnly {\n        balances[beneficiary] = safeAdd(balances[beneficiary], amount);\n        tokensIssued = safeAdd(tokensIssued, amount);\n        Transfer(0x0, beneficiary, amount);\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses safe mathematical operations in the `mint` function, preventing integer underflow."
    },
    {
        "code_segment": "contract PreapprovedToken is Owned, ERC20StandardToken {\n    event SpenderPreapproved(address spender, bool state);\n\n    mapping (address => bool) public preapproved;\n    \n    bool public transferAllowed;\n\n    function PreapprovedToken() {        \n    }\n\n    modifier canTransfer(address _to) {\n        require(_to != address(0));\n        require(preapproved[msg.sender] || transferAllowed);\n        _;\n    }\n\n    function preapprove(address spender, bool state) public ownerOnly {\n        preapproved[spender] = state;\n        SpenderPreapproved(spender, state);\n    }\n\n    function allowTransfer(bool state) public ownerOnly {\n        transferAllowed = state;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {        \n        //if msg.sender is not preapproved check the allowance\n        if(!preapproved[msg.sender]) {\n            // Check for allowance is not needed because 'safeSub' throws if result is negative\n            allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value);\n        }\n\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(_from, _to, _value);        \n        Transfer(_from, _to, _value);\n        return true;\n    }\n    \n    function transfer(address _to, uint256 _value) \n        public \n        canTransfer(_to)\n        returns (bool) \n    {\n        // safeSub inside doTransfer will throw if there is not enough balance.\n        doTransfer(msg.sender, _to, _value);        \n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-BCShop Smart Contracts Security Analysis/bcshop.io-3023172e3192b317e291a68bc191840e6b5e462c/contracts/token/CockToken.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses a safe subtraction method \"safeSub\" which throws an error if the result is negative, preventing integer underflow."
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Callstack Depth Attack Vulnerability",
        "check": "FP",
        "response": "Answer: No\nReason: The contract does not perform nested external calls in a way that would exploit call stack depth."
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: Yes\nDescription: The _keyHolderData.executionNonce is incremented without checking for potential overflow, which can lead to an integer overflow vulnerability."
    },
    {
        "code_segment": "library KeyHolderLibrary {\n    event KeyAdded(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event KeyRemoved(bytes32 indexed key, uint256 indexed purpose, uint256 indexed keyType);\n    event ExecutionRequested(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event ExecutionFailed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Executed(uint256 indexed executionId, address indexed to, uint256 indexed value, bytes data);\n    event Approved(uint256 indexed executionId, bool approved);\n\n    struct Key {\n        uint256[] purposes; //e.g., MANAGEMENT_KEY = 1, ACTION_KEY = 2, etc.\n        uint256 keyType; // e.g. 1 = ECDSA, 2 = RSA, etc.\n        bytes32 key;\n    }\n\n    struct KeyHolderData {\n        uint256 executionNonce;\n        mapping (bytes32 => Key) keys;\n        mapping (uint256 => bytes32[]) keysByPurpose;\n        mapping (uint256 => Execution) executions;\n    }\n\n    struct Execution {\n        address to;\n        uint256 value;\n        bytes data;\n        bool approved;\n        bool executed;\n    }\n\n    function init(KeyHolderData storage _keyHolderData)\n        public\n    {\n        bytes32 _key = keccak256(abi.encodePacked(msg.sender));\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(1);\n        _keyHolderData.keys[_key].keyType = 1;\n        _keyHolderData.keysByPurpose[1].push(_key);\n        emit KeyAdded(_key, 1, 1);\n    }\n\n    function getKey(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes, uint256 keyType, bytes32 key)\n    {\n        return (\n            _keyHolderData.keys[_key].purposes,\n            _keyHolderData.keys[_key].keyType,\n            _keyHolderData.keys[_key].key\n        );\n    }\n\n    function getKeyPurposes(KeyHolderData storage _keyHolderData, bytes32 _key)\n        public\n        view\n        returns(uint256[] purposes)\n    {\n        return (_keyHolderData.keys[_key].purposes);\n    }\n\n    function getKeysByPurpose(KeyHolderData storage _keyHolderData, uint256 _purpose)\n        public\n        view\n        returns(bytes32[] _keys)\n    {\n        return _keyHolderData.keysByPurpose[_purpose];\n    }\n\n    function addKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose, uint256 _type)\n        public\n        returns (bool success)\n    {\n        require(_keyHolderData.keys[_key].key != _key, \"Key already exists\"); // Key should not already exist\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        _keyHolderData.keys[_key].key = _key;\n        _keyHolderData.keys[_key].purposes.push(_purpose);\n        _keyHolderData.keys[_key].keyType = _type;\n\n        _keyHolderData.keysByPurpose[_purpose].push(_key);\n\n        emit KeyAdded(_key, _purpose, _type);\n\n        return true;\n    }\n\n    function approve(KeyHolderData storage _keyHolderData, uint256 _id, bool _approve)\n        public\n        returns (bool success)\n    {\n        require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 2), \"Sender does not have action key\");\n        require(!_keyHolderData.executions[_id].executed, \"Already executed\");\n\n        emit Approved(_id, _approve);\n\n        if (_approve == true) {\n            _keyHolderData.executions[_id].approved = true;\n            success = _keyHolderData.executions[_id].to.call(_keyHolderData.executions[_id].data, 0);\n            if (success) {\n                _keyHolderData.executions[_id].executed = true;\n                emit Executed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            } else {\n                emit ExecutionFailed(\n                    _id,\n                    _keyHolderData.executions[_id].to,\n                    _keyHolderData.executions[_id].value,\n                    _keyHolderData.executions[_id].data\n                );\n                return;\n            }\n        } else {\n            _keyHolderData.executions[_id].approved = false;\n        }\n        return true;\n    }\n\n    function execute(KeyHolderData storage _keyHolderData, address _to, uint256 _value, bytes _data)\n        public\n        returns (uint256 executionId)\n    {\n        require(!_keyHolderData.executions[_keyHolderData.executionNonce].executed, \"Already executed\");\n        _keyHolderData.executions[_keyHolderData.executionNonce].to = _to;\n        _keyHolderData.executions[_keyHolderData.executionNonce].value = _value;\n        _keyHolderData.executions[_keyHolderData.executionNonce].data = _data;\n\n        emit ExecutionRequested(_keyHolderData.executionNonce, _to, _value, _data);\n\n        if (keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),1) || keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)),2)) {\n            approve(_keyHolderData, _keyHolderData.executionNonce, true);\n        }\n\n        _keyHolderData.executionNonce++;\n        return _keyHolderData.executionNonce-1;\n    }\n\n    function removeKey(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        returns (bool success)\n    {\n        if (msg.sender != address(this)) {\n            require(keyHasPurpose(_keyHolderData, keccak256(abi.encodePacked(msg.sender)), 1), \"Sender does not have management key\"); // Sender has MANAGEMENT_KEY\n        }\n\n        require(_keyHolderData.keys[_key].key == _key, \"No such key\");\n        emit KeyRemoved(_key, _purpose, _keyHolderData.keys[_key].keyType);\n\n        // Remove purpose from key\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] == _purpose) {\n                purposes[i] = purposes[purposes.length - 1];\n                delete purposes[purposes.length - 1];\n                purposes.length--;\n                break;\n            }\n        }\n\n        // If no more purposes, delete key\n        if (purposes.length == 0) {\n            delete _keyHolderData.keys[_key];\n        }\n\n        // Remove key from keysByPurpose\n        bytes32[] storage keys = _keyHolderData.keysByPurpose[_purpose];\n        for (uint j = 0; j < keys.length; j++) {\n            if (keys[j] == _key) {\n                keys[j] = keys[keys.length - 1];\n                delete keys[keys.length - 1];\n                keys.length--;\n                break;\n            }\n        }\n\n        return true;\n    }\n\n    function keyHasPurpose(KeyHolderData storage _keyHolderData, bytes32 _key, uint256 _purpose)\n        public\n        view\n        returns(bool result)\n    {\n        bool isThere;\n        if (_keyHolderData.keys[_key].key == 0) {\n            return false;\n        }\n\n        uint256[] storage purposes = _keyHolderData.keys[_key].purposes;\n        for (uint i = 0; i < purposes.length; i++) {\n            if (purposes[i] <= _purpose) {\n                isThere = true;\n                break;\n            }\n        }\n        return isThere;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Trail_of_Bits-origin/origin-4b31657825523962434c6d4e4c61feb0bb1ee518/origin-contracts/contracts/identity/KeyHolderLibrary.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses Solidity version without unchecked keyword, and only operations that could cause underflow (like `purposes.length--` and `keys.length--`) occur in controlled contexts."
    },
    {
        "code_segment": "contract Escrow is IEscrow, Ownable {\n  using SafeMath for uint256;\n\n  ISendToken public token;\n\n  struct Lock {\n    address sender;\n    address recipient;\n    uint256 value;\n    uint256 fee;\n    uint256 expiration;\n    bool paid;\n  }\n\n  mapping(address => mapping(uint256 => Lock)) internal escrows;\n\n  function Escrow(address _token) public {\n    token = ISendToken(_token);\n  }\n\n  modifier tokenRestricted() {\n    require(msg.sender == address(token));\n    _;\n  }\n\n  function getStatus(address _arbitrator, uint256 _transactionId) \n      public view returns(address, address, uint256, uint256, uint256, bool) {\n    return(\n      escrows[_arbitrator][_transactionId].sender,\n      escrows[_arbitrator][_transactionId].recipient,\n      escrows[_arbitrator][_transactionId].value,\n      escrows[_arbitrator][_transactionId].fee,\n      escrows[_arbitrator][_transactionId].expiration,\n      escrows[_arbitrator][_transactionId].paid\n    );\n  }\n\n  function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) {\n    return escrows[_arbitrator][_transactionId].expiration == 1;\n  }\n\n  /**\n   * @dev Create a record for held tokens\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   * @param _expiration After this timestamp, user can claim tokens back.\n   */\n  function create(\n      address _sender,\n      address _recipient,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee,\n      uint256 _expiration\n  ) public tokenRestricted {\n\n    require(_tokens > 0);\n    require(_fee >= 0);\n    require(escrows[_arbitrator][_transactionId].value == 0);\n\n    escrows[_arbitrator][_transactionId].sender = _sender;\n    escrows[_arbitrator][_transactionId].recipient = _recipient;\n    escrows[_arbitrator][_transactionId].value = _tokens;\n    escrows[_arbitrator][_transactionId].fee = _fee;\n    escrows[_arbitrator][_transactionId].expiration = _expiration;\n\n    Created(_sender, _recipient, _arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Fund escrow record\n   * @param _arbitrator Address to be authorized to spend locked funds\n   * @param _transactionId Intenral ID for applications implementing this\n   * @param _tokens Amount of tokens to lock\n   * @param _fee A fee to be paid to arbitrator (may be 0)\n   */\n  function fund(\n      address _sender,\n      address _arbitrator,\n      uint256 _transactionId,\n      uint256 _tokens,\n      uint256 _fee\n  ) public tokenRestricted {\n\n    require(escrows[_arbitrator][_transactionId].sender == _sender);\n    require(escrows[_arbitrator][_transactionId].value == _tokens);\n    require(escrows[_arbitrator][_transactionId].fee == _fee);\n    require(escrows[_arbitrator][_transactionId].paid == false);\n\n    escrows[_arbitrator][_transactionId].paid = true;\n\n    Paid(_arbitrator, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function release(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration != 1);\n    require(lock.sender == _sender);\n    require(lock.recipient == _recipient || lock.sender == _recipient);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.recipient == _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Transfer a locked amount for timeless escrow\n   * @notice Only authorized address\n   * @notice Exchange rate has 18 decimal places\n   * @param _sender Address with locked amount\n   * @param _recipient Address to send funds to\n   * @param _transactionId App/user internal associated ID\n   * @param _exchangeRate Rate to be reported to the blockchain\n   */\n  function releaseUnlocked(\n      address _sender,\n      address _recipient,\n      uint256 _transactionId,\n      uint256 _exchangeRate\n  ) public {\n\n    Lock memory lock = escrows[msg.sender][_transactionId];\n\n    require(lock.expiration == 1);\n    require(lock.sender == _sender);\n    require(lock.paid);\n\n    if (lock.fee > 0 && lock.sender != _recipient) {\n      token.transfer(_recipient, lock.value);\n      token.transfer(msg.sender, lock.fee);\n    } else {\n      token.transfer(_recipient, lock.value.add(lock.fee));\n    }\n\n    delete escrows[msg.sender][_transactionId];\n\n    token.issueExchangeRate(\n      _sender,\n      _recipient,\n      msg.sender,\n      lock.value,\n      _transactionId,\n      _exchangeRate\n    );\n    Released(msg.sender, _recipient, _transactionId);\n  }\n\n  /**\n   * @dev Claim back locked amount after expiration time\n   * @dev Cannot be claimed if expiration == 0 or expiration == 1\n   * @notice Only works after lock expired\n   * @param _arbitrator Authorized lock address\n   * @param _transactionId transactionId ID from App/user\n   */\n  function claim(\n      address _arbitrator,\n      uint256 _transactionId\n  ) public {\n    Lock memory lock = escrows[_arbitrator][_transactionId];\n\n    require(lock.sender == msg.sender);\n    require(lock.paid);\n    require(lock.expiration < block.timestamp);\n    require(lock.expiration != 0);\n    require(lock.expiration != 1);\n\n    delete escrows[_arbitrator][_transactionId];\n\n    token.transfer(msg.sender, lock.value.add(lock.fee));\n\n    Released(\n      _arbitrator,\n      msg.sender,\n      _transactionId\n    );\n  }\n\n  /**\n   * @dev Remove expiration time on a lock\n   * @notice User wont be able to claim tokens back after this is called by arbitrator address\n   * @notice Only authorized address\n   * @param _transactionId App/user internal associated ID\n   */\n  function mediate(\n      uint256 _transactionId\n  ) public {\n    require(escrows[msg.sender][_transactionId].paid);\n    require(escrows[msg.sender][_transactionId].expiration != 0);\n    require(escrows[msg.sender][_transactionId].expiration != 1);\n\n    escrows[msg.sender][_transactionId].expiration = 0;\n\n    Dispute(msg.sender, _transactionId);\n  }\n\n  /**\n   This function is a way to get other ETC20 tokens\n   back to their rightful owner if sent by mistake\n   */\n  function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner {\n    require(_tokenAddress != address(token));\n\n    ISendToken erc20Token = ISendToken(_tokenAddress);\n    erc20Token.transfer(_transferTo, _value);\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Coinfabrik-Security Audit – Send (SDT) Token Sale ICO Smart Contract/sdt-contracts-master/flattened-contracts/Escrow.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses the SafeMath library for all arithmetic operations, ensuring no integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract IxoERC20Token is ERC20, Ownable {\n    using SafeMath for uint256;\n\n    address public minter;\n\n    event Mint(address indexed to, uint256 amount);\n\n    mapping(address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) internal allowed;\n\n    string public name = \"IXO Token\"; \n    string public symbol = \"IXO\";\n    uint public decimals = 8;\n    uint public CAP = 10000000000 * (10 ** decimals); // 10,000,000,000\n\n    uint256 totalSupply_;\n\n    modifier hasMintPermission() {\n        require(msg.sender == minter, \"Permission denied\");\n        _;\n    }\n\n    /**\n    * @dev Changes the current minter to a newMinter.\n    * @param _newMinter The address to grant minting permission.\n    */\n    function setMinter(address _newMinter) public onlyOwner {\n        _setMinter(_newMinter);\n    }\n\n    /**\n    * @dev Transfers control of minting tokens to a newMinter.\n    * @param _newMinter The address to transfer minting permission.\n    */\n    function _setMinter(address _newMinter) internal {\n        minter = _newMinter;\n    }\n\n    /**\n    * @dev Function to mint tokens\n    * @param _to The address that will receive the minted tokens.\n    * @param _amount The amount of tokens to mint.\n    * @return A boolean that indicates if the operation was successful.\n    */\n    function mint(\n        address _to,\n        uint256 _amount\n        )\n    public hasMintPermission returns (bool)\n    {\n        require(totalSupply_.add(_amount) <= CAP, \"Exceeds cap\");\n\n        totalSupply_ = totalSupply_.add(_amount);\n        balances[_to] = balances[_to].add(_amount);\n\n        emit Mint(_to, _amount);\n        emit Transfer(address(0), _to, _amount);\n\t\t\t\t\n        return true;\n    }\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n    function allowance(\n        address _owner,\n        address _spender\n    )\n    public view returns (uint256)\n    {\n        return allowed[_owner][_spender];\n    }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_value <= balances[msg.sender], \"Not enough funds\");\n        require(_to != address(0), \"Can't transfer to 0x0\");\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n    public returns (bool)\n    {\n        require(_value <= balances[_from], \"Not enough funds\");\n        require(_value <= allowed[_from][msg.sender], \"Not approved\");\n        require(_to != address(0), \"Can't transfer to 0x0\");\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _addedValue The amount of tokens to increase the allowance by.\n   */\n    function increaseApproval(\n        address _spender,\n        uint256 _addedValue\n    )\n    public\n    returns (bool)\n    {\n        allowed[msg.sender][_spender] = (\n            allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param _spender The address which will spend the funds.\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\n   */\n    function decreaseApproval(\n        address _spender,\n        uint256 _subtractedValue\n    )\n    public\n    returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue >= oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-ixo Smart Contract Audit/ixo-solidity-417c40f1bd6600e5d1d8b49d136f2b97a098591c/contracts/token/IxoERC20Token.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The use of SafeMath library ensures that arithmetic operations will revert on underflow and overflow, preventing integer underflow vulnerabilities."
    },
    {
        "code_segment": "contract ExchangeState is State {\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    mapping(address => mapping(bytes32 => ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-3b03563c0808adf13227bf729df42d8b7869c55a/legacy/contracts/ExchangeState.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code has appropriate controls such as bounds checking and appropriate data types (uint) for arithmetic operations, preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract EternalStorage is State {\n    constructor(address _owner, address _associatedContract) public State(_owner, _associatedContract) {}\n\n    /* ========== DATA TYPES ========== */\n    mapping(bytes32 => uint) UIntStorage;\n    mapping(bytes32 => string) StringStorage;\n    mapping(bytes32 => address) AddressStorage;\n    mapping(bytes32 => bytes) BytesStorage;\n    mapping(bytes32 => bytes32) Bytes32Storage;\n    mapping(bytes32 => bool) BooleanStorage;\n    mapping(bytes32 => int) IntStorage;\n\n    // UIntStorage;\n    function getUIntValue(bytes32 record) external view returns (uint) {\n        return UIntStorage[record];\n    }\n\n    function setUIntValue(bytes32 record, uint value) external onlyAssociatedContract {\n        UIntStorage[record] = value;\n    }\n\n    function deleteUIntValue(bytes32 record) external onlyAssociatedContract {\n        delete UIntStorage[record];\n    }\n\n    // StringStorage\n    function getStringValue(bytes32 record) external view returns (string memory) {\n        return StringStorage[record];\n    }\n\n    function setStringValue(bytes32 record, string value) external onlyAssociatedContract {\n        StringStorage[record] = value;\n    }\n\n    function deleteStringValue(bytes32 record) external onlyAssociatedContract {\n        delete StringStorage[record];\n    }\n\n    // AddressStorage\n    function getAddressValue(bytes32 record) external view returns (address) {\n        return AddressStorage[record];\n    }\n\n    function setAddressValue(bytes32 record, address value) external onlyAssociatedContract {\n        AddressStorage[record] = value;\n    }\n\n    function deleteAddressValue(bytes32 record) external onlyAssociatedContract {\n        delete AddressStorage[record];\n    }\n\n    // BytesStorage\n    function getBytesValue(bytes32 record) external view returns (bytes memory) {\n        return BytesStorage[record];\n    }\n\n    function setBytesValue(bytes32 record, bytes value) external onlyAssociatedContract {\n        BytesStorage[record] = value;\n    }\n\n    function deleteBytesValue(bytes32 record) external onlyAssociatedContract {\n        delete BytesStorage[record];\n    }\n\n    // Bytes32Storage\n    function getBytes32Value(bytes32 record) external view returns (bytes32) {\n        return Bytes32Storage[record];\n    }\n\n    function setBytes32Value(bytes32 record, bytes32 value) external onlyAssociatedContract {\n        Bytes32Storage[record] = value;\n    }\n\n    function deleteBytes32Value(bytes32 record) external onlyAssociatedContract {\n        delete Bytes32Storage[record];\n    }\n\n    // BooleanStorage\n    function getBooleanValue(bytes32 record) external view returns (bool) {\n        return BooleanStorage[record];\n    }\n\n    function setBooleanValue(bytes32 record, bool value) external onlyAssociatedContract {\n        BooleanStorage[record] = value;\n    }\n\n    function deleteBooleanValue(bytes32 record) external onlyAssociatedContract {\n        delete BooleanStorage[record];\n    }\n\n    // IntStorage\n    function getIntValue(bytes32 record) external view returns (int) {\n        return IntStorage[record];\n    }\n\n    function setIntValue(bytes32 record, int value) external onlyAssociatedContract {\n        IntStorage[record] = value;\n    }\n\n    function deleteIntValue(bytes32 record) external onlyAssociatedContract {\n        delete IntStorage[record];\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/FeePoolEternalStorage.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform any arithmetic operations on the unsigned integers stored in 'UIntStorage', thus there is no risk of integer underflow."
    },
    {
        "code_segment": "contract FeePoolEternalStorage is EternalStorage, LimitedSetup {\n    bytes32 constant LAST_FEE_WITHDRAWAL = \"last_fee_withdrawal\";\n\n    /**\n     * @dev Constructor.\n     * @param _owner The owner of this contract.\n     */\n    constructor(address _owner, address _feePool) public EternalStorage(_owner, _feePool) LimitedSetup(6 weeks) {}\n\n    /**\n     * @notice Import data from FeePool.lastFeeWithdrawal\n     * @dev Only callable by the contract owner, and only for 6 weeks after deployment.\n     * @param accounts Array of addresses that have claimed\n     * @param feePeriodIDs Array feePeriodIDs with the accounts last claim\n     */\n    function importFeeWithdrawalData(address[] accounts, uint[] feePeriodIDs) external onlyOwner onlyDuringSetup {\n        require(accounts.length == feePeriodIDs.length, \"Length mismatch\");\n\n        for (uint8 i = 0; i < accounts.length; i++) {\n            this.setUIntValue(keccak256(abi.encodePacked(LAST_FEE_WITHDRAWAL, accounts[i])), feePeriodIDs[i]);\n        }\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/FeePoolEternalStorage.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: There is no arithmetic operation in the provided code that could lead to an integer underflow."
    },
    {
        "code_segment": "contract RewardEscrow is Owned {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint constant TIME_INDEX = 0;\n    uint constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(_feePool);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2]) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2]) {\n        uint index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520]) {\n        uint[520] memory _result;\n        uint schedules = numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) public onlyFeePool {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= synthetix.balanceOf(this),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            synthetix.transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-83191da45aa03ef73fcc9715d777516ecc7c952f/legacy/contracts/RewardEscrow.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath for all arithmetic operations, preventing integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Callstack Depth Attack Vulnerability",
        "check": "FP",
        "response": "Answer: No\nReason: Callstack depth attack vulnerability typically requires multiple nested external calls, especially within the same transaction, causing the call stack to exceed a certain depth. The provided smart contract does not have any external calls in a nested manner that would meet this condition."
    },
    {
        "code_segment": "contract RewardsDistribution is Owned {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    /**\n     * @notice Authorised address able to call distributeRewards\n     */\n    address public authority;\n\n    /**\n     * @notice Address of the Synthetix ProxyERC20\n     */\n    address public synthetixProxy;\n\n    /**\n     * @notice Address of the RewardEscrow contract\n     */\n    address public rewardEscrow;\n\n    /**\n     * @notice Address of the FeePoolProxy\n     */\n    address public feePoolProxy;\n\n    /**\n     * @notice Stores an address and amount\n     * of the inflationary supply to sent to the address.\n     */\n    struct DistributionData {\n        address destination;\n        uint amount;\n    }\n\n    /**\n     * @notice An array of addresses and amounts to send\n     */\n    DistributionData[] public distributions;\n\n    /**\n     * @dev _authority maybe the underlying synthetix contract.\n     * Remember to set the autority on a synthetix upgrade\n     */\n    constructor(\n        address _owner,\n        address _authority,\n        address _synthetixProxy,\n        address _rewardEscrow,\n        address _feePoolProxy\n    ) public Owned(_owner) {\n        authority = _authority;\n        synthetixProxy = _synthetixProxy;\n        rewardEscrow = _rewardEscrow;\n        feePoolProxy = _feePoolProxy;\n    }\n\n    // ========== EXTERNAL SETTERS ==========\n\n    function setSynthetixProxy(address _synthetixProxy) external onlyOwner {\n        synthetixProxy = _synthetixProxy;\n    }\n\n    function setRewardEscrow(address _rewardEscrow) external onlyOwner {\n        rewardEscrow = _rewardEscrow;\n    }\n\n    function setFeePoolProxy(address _feePoolProxy) external onlyOwner {\n        feePoolProxy = _feePoolProxy;\n    }\n\n    /**\n     * @notice Set the address of the contract authorised to call distributeRewards()\n     * @param _authority Address of the authorised calling contract.\n     */\n    function setAuthority(address _authority) external onlyOwner {\n        authority = _authority;\n    }\n\n    // ========== EXTERNAL FUNCTIONS ==========\n\n    /**\n     * @notice Adds a Rewards DistributionData struct to the distributions\n     * array. Any entries here will be iterated and rewards distributed to\n     * each address when tokens are sent to this contract and distributeRewards()\n     * is called by the autority.\n     * @param destination An address to send rewards tokens too\n     * @param amount The amount of rewards tokens to send\n     */\n    function addRewardDistribution(address destination, uint amount) external onlyOwner returns (bool) {\n        require(destination != address(0), \"Cant add a zero address\");\n        require(amount != 0, \"Cant add a zero amount\");\n\n        DistributionData memory rewardsDistribution = DistributionData(destination, amount);\n        distributions.push(rewardsDistribution);\n\n        emit RewardDistributionAdded(distributions.length - 1, destination, amount);\n        return true;\n    }\n\n    /**\n     * @notice Deletes a RewardDistribution from the distributions\n     * so it will no longer be included in the call to distributeRewards()\n     * @param index The index of the DistributionData to delete\n     */\n    function removeRewardDistribution(uint index) external onlyOwner {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        // shift distributions indexes across\n        for (uint i = index; i < distributions.length - 1; i++) {\n            distributions[i] = distributions[i + 1];\n        }\n        distributions.length--;\n\n        // Since this function must shift all later entries down to fill the\n        // gap from the one it removed, it could in principle consume an\n        // unbounded amount of gas. However, the number of entries will\n        // presumably always be very low.\n    }\n\n    /**\n     * @notice Edits a RewardDistribution in the distributions array.\n     * @param index The index of the DistributionData to edit\n     * @param destination The destination address. Send the same address to keep or different address to change it.\n     * @param amount The amount of tokens to edit. Send the same number to keep or change the amount of tokens to send.\n     */\n    function editRewardDistribution(\n        uint index,\n        address destination,\n        uint amount\n    ) external onlyOwner returns (bool) {\n        require(index <= distributions.length - 1, \"index out of bounds\");\n\n        distributions[index].destination = destination;\n        distributions[index].amount = amount;\n\n        return true;\n    }\n\n    /**\n     * @notice Iterates the distributions sending set out amounts of\n     * tokens to the specified address. The remainder is then sent to the RewardEscrow Contract\n     * and applied to the FeePools staking rewards.\n     * @param amount The total number of tokens being distributed\n     */\n    function distributeRewards(uint amount) external returns (bool) {\n        require(msg.sender == authority, \"Caller is not authorised\");\n        require(rewardEscrow != address(0), \"RewardEscrow is not set\");\n        require(synthetixProxy != address(0), \"SynthetixProxy is not set\");\n        require(feePoolProxy != address(0), \"FeePoolProxy is not set\");\n        require(amount > 0, \"Nothing to distribute\");\n        require(\n            IERC20(synthetixProxy).balanceOf(this) >= amount,\n            \"RewardsDistribution contract does not have enough tokens to distribute\"\n        );\n\n        uint remainder = amount;\n\n        // Iterate the array of distributions sending the configured amounts\n        for (uint i = 0; i < distributions.length; i++) {\n            if (distributions[i].destination != address(0) || distributions[i].amount != 0) {\n                remainder = remainder.sub(distributions[i].amount);\n\n                // Transfer the SNX\n                IERC20(synthetixProxy).transfer(distributions[i].destination, distributions[i].amount);\n\n                // If the contract implements RewardsDistributionRecipient.sol, inform it how many SNX its received.\n                bytes memory payload = abi.encodeWithSignature(\"notifyRewardAmount(uint256)\", distributions[i].amount);\n                distributions[i].destination.call(payload);\n                // Note: we're ignoring the return value as it will fail for contracts that do not implement RewardsDistributionRecipient.sol\n            }\n        }\n\n        // After all ditributions have been sent, send the remainder to the RewardsEscrow contract\n        IERC20(synthetixProxy).transfer(rewardEscrow, remainder);\n\n        // Tell the FeePool how much it has to distribute to the stakers\n        IFeePool(feePoolProxy).setRewardsToDistribute(remainder);\n\n        emit RewardsDistributed(amount);\n        return true;\n    }\n\n    /* ========== VIEWS ========== */\n\n    /**\n     * @notice Retrieve the length of the distributions array\n     */\n    function distributionsLength() external view returns (uint) {\n        return distributions.length;\n    }\n\n    /* ========== Events ========== */\n\n    event RewardDistributionAdded(uint index, address destination, uint amount);\n    event RewardsDistributed(uint amount);\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardsDistribution.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract utilizes the SafeMath library for uint operations, which ensures safe arithmetic operations, preventing integer overflow."
    },
    {
        "code_segment": "contract RewardEscrow is Owned {\n    using SafeMath for uint;\n\n    /* The corresponding Synthetix contract. */\n    ISynthetix public synthetix;\n\n    IFeePool public feePool;\n\n    /* Lists of (timestamp, quantity) pairs per account, sorted in ascending time order.\n     * These are the times at which each given quantity of SNX vests. */\n    mapping(address => uint[2][]) public vestingSchedules;\n\n    /* An account's total escrowed synthetix balance to save recomputing this for fee extraction purposes. */\n    mapping(address => uint) public totalEscrowedAccountBalance;\n\n    /* An account's total vested reward synthetix. */\n    mapping(address => uint) public totalVestedAccountBalance;\n\n    /* The total remaining escrowed balance, for verifying the actual synthetix balance of this contract against. */\n    uint public totalEscrowedBalance;\n\n    uint constant TIME_INDEX = 0;\n    uint constant QUANTITY_INDEX = 1;\n\n    /* Limit vesting entries to disallow unbounded iteration over vesting schedules.\n     * There are 5 years of the supply schedule */\n    uint public constant MAX_VESTING_ENTRIES = 52 * 5;\n\n    /* ========== CONSTRUCTOR ========== */\n\n    constructor(\n        address _owner,\n        ISynthetix _synthetix,\n        IFeePool _feePool\n    ) public Owned(_owner) {\n        synthetix = _synthetix;\n        feePool = _feePool;\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * @notice set the synthetix contract address as we need to transfer SNX when the user vests\n     */\n    function setSynthetix(ISynthetix _synthetix) external onlyOwner {\n        synthetix = _synthetix;\n        emit SynthetixUpdated(_synthetix);\n    }\n\n    /**\n     * @notice set the FeePool contract as it is the only authority to be able to call\n     * appendVestingEntry with the onlyFeePool modifer\n     */\n    function setFeePool(IFeePool _feePool) external onlyOwner {\n        feePool = _feePool;\n        emit FeePoolUpdated(_feePool);\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * @notice A simple alias to totalEscrowedAccountBalance: provides ERC20 balance integration.\n     */\n    function balanceOf(address account) public view returns (uint) {\n        return totalEscrowedAccountBalance[account];\n    }\n\n    /**\n     * @notice The number of vesting dates in an account's schedule.\n     */\n    function numVestingEntries(address account) public view returns (uint) {\n        return vestingSchedules[account].length;\n    }\n\n    /**\n     * @notice Get a particular schedule entry for an account.\n     * @return A pair of uints: (timestamp, synthetix quantity).\n     */\n    function getVestingScheduleEntry(address account, uint index) public view returns (uint[2]) {\n        return vestingSchedules[account][index];\n    }\n\n    /**\n     * @notice Get the time at which a given schedule entry will vest.\n     */\n    function getVestingTime(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Get the quantity of SNX associated with a given schedule entry.\n     */\n    function getVestingQuantity(address account, uint index) public view returns (uint) {\n        return getVestingScheduleEntry(account, index)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice Obtain the index of the next schedule entry that will vest for a given user.\n     */\n    function getNextVestingIndex(address account) public view returns (uint) {\n        uint len = numVestingEntries(account);\n        for (uint i = 0; i < len; i++) {\n            if (getVestingTime(account, i) != 0) {\n                return i;\n            }\n        }\n        return len;\n    }\n\n    /**\n     * @notice Obtain the next schedule entry that will vest for a given user.\n     * @return A pair of uints: (timestamp, synthetix quantity). */\n    function getNextVestingEntry(address account) public view returns (uint[2]) {\n        uint index = getNextVestingIndex(account);\n        if (index == numVestingEntries(account)) {\n            return [uint(0), 0];\n        }\n        return getVestingScheduleEntry(account, index);\n    }\n\n    /**\n     * @notice Obtain the time at which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingTime(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[TIME_INDEX];\n    }\n\n    /**\n     * @notice Obtain the quantity which the next schedule entry will vest for a given user.\n     */\n    function getNextVestingQuantity(address account) external view returns (uint) {\n        return getNextVestingEntry(account)[QUANTITY_INDEX];\n    }\n\n    /**\n     * @notice return the full vesting schedule entries vest for a given user.\n     * @dev For DApps to display the vesting schedule for the\n     * inflationary supply over 5 years. Solidity cant return variable length arrays\n     * so this is returning pairs of data. Vesting Time at [0] and quantity at [1] and so on\n     */\n    function checkAccountSchedule(address account) public view returns (uint[520]) {\n        uint[520] memory _result;\n        uint schedules = numVestingEntries(account);\n        for (uint i = 0; i < schedules; i++) {\n            uint[2] memory pair = getVestingScheduleEntry(account, i);\n            _result[i * 2] = pair[0];\n            _result[i * 2 + 1] = pair[1];\n        }\n        return _result;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * @notice Add a new vesting entry at a given time and quantity to an account's schedule.\n     * @dev A call to this should accompany a previous successful call to synthetix.transfer(rewardEscrow, amount),\n     * to ensure that when the funds are withdrawn, there is enough balance.\n     * Note; although this function could technically be used to produce unbounded\n     * arrays, it's only withinn the 4 year period of the weekly inflation schedule.\n     * @param account The account to append a new vesting entry to.\n     * @param quantity The quantity of SNX that will be escrowed.\n     */\n    function appendVestingEntry(address account, uint quantity) public onlyFeePool {\n        /* No empty or already-passed vesting entries allowed. */\n        require(quantity != 0, \"Quantity cannot be zero\");\n\n        /* There must be enough balance in the contract to provide for the vesting entry. */\n        totalEscrowedBalance = totalEscrowedBalance.add(quantity);\n        require(\n            totalEscrowedBalance <= synthetix.balanceOf(this),\n            \"Must be enough balance in the contract to provide for the vesting entry\"\n        );\n\n        /* Disallow arbitrarily long vesting schedules in light of the gas limit. */\n        uint scheduleLength = vestingSchedules[account].length;\n        require(scheduleLength <= MAX_VESTING_ENTRIES, \"Vesting schedule is too long\");\n\n        /* Escrow the tokens for 1 year. */\n        uint time = now + 52 weeks;\n\n        if (scheduleLength == 0) {\n            totalEscrowedAccountBalance[account] = quantity;\n        } else {\n            /* Disallow adding new vested SNX earlier than the last one.\n             * Since entries are only appended, this means that no vesting date can be repeated. */\n            require(\n                getVestingTime(account, scheduleLength - 1) < time,\n                \"Cannot add new vested entries earlier than the last one\"\n            );\n            totalEscrowedAccountBalance[account] = totalEscrowedAccountBalance[account].add(quantity);\n        }\n\n        vestingSchedules[account].push([time, quantity]);\n\n        emit VestingEntryCreated(account, now, quantity);\n    }\n\n    /**\n     * @notice Allow a user to withdraw any SNX in their schedule that have vested.\n     */\n    function vest() external {\n        uint numEntries = numVestingEntries(msg.sender);\n        uint total;\n        for (uint i = 0; i < numEntries; i++) {\n            uint time = getVestingTime(msg.sender, i);\n            /* The list is sorted; when we reach the first future time, bail out. */\n            if (time > now) {\n                break;\n            }\n            uint qty = getVestingQuantity(msg.sender, i);\n            if (qty == 0) {\n                continue;\n            }\n\n            vestingSchedules[msg.sender][i] = [0, 0];\n            total = total.add(qty);\n        }\n\n        if (total != 0) {\n            totalEscrowedBalance = totalEscrowedBalance.sub(total);\n            totalEscrowedAccountBalance[msg.sender] = totalEscrowedAccountBalance[msg.sender].sub(total);\n            totalVestedAccountBalance[msg.sender] = totalVestedAccountBalance[msg.sender].add(total);\n            synthetix.transfer(msg.sender, total);\n            emit Vested(msg.sender, now, total);\n        }\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyFeePool() {\n        bool isFeePool = msg.sender == address(feePool);\n\n        require(isFeePool, \"Only the FeePool contracts can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SynthetixUpdated(address newSynthetix);\n\n    event FeePoolUpdated(address newFeePool);\n\n    event Vested(address indexed beneficiary, uint time, uint value);\n\n    event VestingEntryCreated(address indexed beneficiary, uint time, uint value);\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Iosiro-Synthetix Shaula Release Smart Contract Audit/synthetix-d7671c94a22130f19e8aa19f6a1974a257dde9e6/legacy/contracts/RewardEscrow.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The contract uses SafeMath library for mathematical operations, which prevents integer overflow and underflow issues."
    },
    {
        "code_segment": "contract ERC721 is ERC165, IERC721 {\n\n  using SafeMath for uint256;\n  using Address for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n  // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n  bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n  // Mapping from token ID to owner\n  mapping (uint256 => address) private _tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 => address) private _tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address => uint256) private _ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n  bytes4 private constant _InterfaceId_ERC721 = 0x80ac58cd;\n  /*\n   * 0x80ac58cd ===\n   *   bytes4(keccak256('balanceOf(address)')) ^\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\n   *   bytes4(keccak256('approve(address,uint256)')) ^\n   *   bytes4(keccak256('getApproved(uint256)')) ^\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\n   */\n\n  constructor()\n    public\n  {\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(_InterfaceId_ERC721);\n  }\n\n  /**\n   * @dev Gets the balance of the specified address\n   * @param owner address to query the balance of\n   * @return uint256 representing the amount owned by the passed address\n   */\n  function balanceOf(address owner) public view returns (uint256) {\n    require(owner != address(0));\n    return _ownedTokensCount[owner];\n  }\n\n  /**\n   * @dev Gets the owner of the specified token ID\n   * @param tokenId uint256 ID of the token to query the owner of\n   * @return owner address currently marked as the owner of the given token ID\n   */\n  function ownerOf(uint256 tokenId) public view returns (address) {\n    address owner = _tokenOwner[tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n   * @dev Approves another address to transfer the given token ID\n   * The zero address indicates there is no approved address.\n   * There can only be one approved address per token at a given time.\n   * Can only be called by the token owner or an approved operator.\n   * @param to address to be approved for the given token ID\n   * @param tokenId uint256 ID of the token to be approved\n   */\n  function approve(address to, uint256 tokenId) public {\n    address owner = ownerOf(tokenId);\n    require(to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    _tokenApprovals[tokenId] = to;\n    emit Approval(owner, to, tokenId);\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * Reverts if the token ID does not exist.\n   * @param tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for the given token ID\n   */\n  function getApproved(uint256 tokenId) public view returns (address) {\n    require(_exists(tokenId));\n    return _tokenApprovals[tokenId];\n  }\n\n  /**\n   * @dev Sets or unsets the approval of a given operator\n   * An operator is allowed to transfer all tokens of the sender on their behalf\n   * @param to operator address to set the approval\n   * @param approved representing the status of the approval to be set\n   */\n  function setApprovalForAll(address to, bool approved) public {\n    require(to != msg.sender);\n    _operatorApprovals[msg.sender][to] = approved;\n    emit ApprovalForAll(msg.sender, to, approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param owner owner address which you want to query the approval of\n   * @param operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(\n    address owner,\n    address operator\n  )\n    public\n    view\n    returns (bool)\n  {\n    return _operatorApprovals[owner][operator];\n  }\n\n  /**\n   * @dev Transfers the ownership of a given token ID to another address\n   * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    require(_isApprovedOrOwner(msg.sender, tokenId));\n    require(to != address(0));\n\n    _clearApproval(from, tokenId);\n    _removeTokenFrom(from, tokenId);\n    _addTokenTo(to, tokenId);\n\n    emit Transfer(from, to, tokenId);\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   *\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  )\n    public\n  {\n    // solium-disable-next-line arg-overflow\n    safeTransferFrom(from, to, tokenId, \"\");\n  }\n\n  /**\n   * @dev Safely transfers the ownership of a given token ID to another address\n   * If the target address is a contract, it must implement `onERC721Received`,\n   * which is called upon a safe transfer, and return the magic value\n   * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n   * the transfer is reverted.\n   * Requires the msg sender to be the owner, approved, or operator\n   * @param from current owner of the token\n   * @param to address to receive the ownership of the given token ID\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes data to send along with a safe transfer check\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    public\n  {\n    transferFrom(from, to, tokenId);\n    // solium-disable-next-line arg-overflow\n    require(_checkOnERC721Received(from, to, tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the specified token exists\n   * @param tokenId uint256 ID of the token to query the existence of\n   * @return whether the token exists\n   */\n  function _exists(uint256 tokenId) internal view returns (bool) {\n    address owner = _tokenOwner[tokenId];\n    return owner != address(0);\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param spender address of the spender to query\n   * @param tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function _isApprovedOrOwner(\n    address spender,\n    uint256 tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    address owner = ownerOf(tokenId);\n    // Disable solium check because of\n    // https://github.com/duaraghav8/Solium/issues/175\n    // solium-disable-next-line operator-whitespace\n    return (\n      spender == owner ||\n      getApproved(tokenId) == spender ||\n      isApprovedForAll(owner, spender)\n    );\n  }\n\n  /**\n   * @dev Internal function to mint a new token\n   * Reverts if the given token ID already exists\n   * @param to The address that will own the minted token\n   * @param tokenId uint256 ID of the token to be minted by the msg.sender\n   */\n  function _mint(address to, uint256 tokenId) internal {\n    require(to != address(0));\n    _addTokenTo(to, tokenId);\n    emit Transfer(address(0), to, tokenId);\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    _clearApproval(owner, tokenId);\n    _removeTokenFrom(owner, tokenId);\n    emit Transfer(owner, address(0), tokenId);\n  }\n\n  /**\n   * @dev Internal function to add a token ID to the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event.\n   * @param to address representing the new owner of the given token ID\n   * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n   */\n  function _addTokenTo(address to, uint256 tokenId) internal {\n    require(_tokenOwner[tokenId] == address(0));\n    _tokenOwner[tokenId] = to;\n    _ownedTokensCount[to] = _ownedTokensCount[to].add(1);\n  }\n\n  /**\n   * @dev Internal function to remove a token ID from the list of a given address\n   * Note that this function is left internal to make ERC721Enumerable possible, but is not\n   * intended to be called by custom derived contracts: in particular, it emits no Transfer event,\n   * and doesn't clear approvals.\n   * @param from address representing the previous owner of the given token ID\n   * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n   */\n  function _removeTokenFrom(address from, uint256 tokenId) internal {\n    require(ownerOf(tokenId) == from);\n    _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);\n    _tokenOwner[tokenId] = address(0);\n  }\n\n  /**\n   * @dev Internal function to invoke `onERC721Received` on a target address\n   * The call is not executed if the target address is not a contract\n   * @param from address representing the previous owner of the given token ID\n   * @param to target address that will receive the tokens\n   * @param tokenId uint256 ID of the token to be transferred\n   * @param _data bytes optional data to send along with the call\n   * @return whether the call correctly returned the expected magic value\n   */\n  function _checkOnERC721Received(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes _data\n  )\n    internal\n    returns (bool)\n  {\n    if (!to.isContract()) {\n      return true;\n    }\n    bytes4 retval = IERC721Receiver(to).onERC721Received(\n      msg.sender, from, tokenId, _data);\n    return (retval == _ERC721_RECEIVED);\n  }\n\n  /**\n   * @dev Private function to clear current approval of a given token ID\n   * Reverts if the given address is not indeed the owner of the token\n   * @param owner owner of the token\n   * @param tokenId uint256 ID of the token to be transferred\n   */\n  function _clearApproval(address owner, uint256 tokenId) private {\n    require(ownerOf(tokenId) == owner);\n    if (_tokenApprovals[tokenId] != address(0)) {\n      _tokenApprovals[tokenId] = address(0);\n    }\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses the SafeMath library for arithmetic operations on uint256, which prevents integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code does not perform arithmetic operations on uint256 variables, so there is no risk of integer overflow."
    },
    {
        "code_segment": "contract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n  // Token name\n  string private _name;\n\n  // Token symbol\n  string private _symbol;\n\n  // Optional mapping for token URIs\n  mapping(uint256 => string) private _tokenURIs;\n\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\n  /**\n   * 0x5b5e139f ===\n   *   bytes4(keccak256('name()')) ^\n   *   bytes4(keccak256('symbol()')) ^\n   *   bytes4(keccak256('tokenURI(uint256)'))\n   */\n\n  /**\n   * @dev Constructor function\n   */\n  constructor(string name, string symbol) public {\n    _name = name;\n    _symbol = symbol;\n\n    // register the supported interfaces to conform to ERC721 via ERC165\n    _registerInterface(InterfaceId_ERC721Metadata);\n  }\n\n  /**\n   * @dev Gets the token name\n   * @return string representing the token name\n   */\n  function name() external view returns (string) {\n    return _name;\n  }\n\n  /**\n   * @dev Gets the token symbol\n   * @return string representing the token symbol\n   */\n  function symbol() external view returns (string) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns an URI for a given token ID\n   * Throws if the token ID does not exist. May return an empty string.\n   * @param tokenId uint256 ID of the token to query\n   */\n  function tokenURI(uint256 tokenId) external view returns (string) {\n    require(_exists(tokenId));\n    return _tokenURIs[tokenId];\n  }\n\n  /**\n   * @dev Internal function to set the token URI for a given token\n   * Reverts if the token ID does not exist\n   * @param tokenId uint256 ID of the token to set its URI\n   * @param uri string URI to assign\n   */\n  function _setTokenURI(uint256 tokenId, string uri) internal {\n    require(_exists(tokenId));\n    _tokenURIs[tokenId] = uri;\n  }\n\n  /**\n   * @dev Internal function to burn a specific token\n   * Reverts if the token does not exist\n   * @param owner owner of the token to burn\n   * @param tokenId uint256 ID of the token being burned by the msg.sender\n   */\n  function _burn(address owner, uint256 tokenId) internal {\n    super._burn(owner, tokenId);\n\n    // Clear metadata (if any)\n    if (bytes(_tokenURIs[tokenId]).length != 0) {\n      delete _tokenURIs[tokenId];\n    }\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/token/ERC721/ERC721Metadata.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform any arithmetic operations that could lead to an integer underflow."
    },
    {
        "code_segment": "contract ReentrancyAttack {\n\n  function callSender(bytes4 data) public {\n    // solium-disable-next-line security/no-low-level-calls\n    require(msg.sender.call(abi.encodeWithSelector(data)));\n  }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform arithmetic operations that could cause an integer overflow."
    },
    {
        "code_segment": "contract ReentrancyAttack {\n\n  function callSender(bytes4 data) public {\n    // solium-disable-next-line security/no-low-level-calls\n    require(msg.sender.call(abi.encodeWithSelector(data)));\n  }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not perform arithmetic operations that could result in an integer underflow."
    },
    {
        "code_segment": "contract ReentrancyMock is ReentrancyGuard {\n\n  uint256 public counter;\n\n  constructor() public {\n    counter = 0;\n  }\n\n  function callback() external nonReentrant {\n    count();\n  }\n\n  function countLocalRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      countLocalRecursive(n - 1);\n    }\n  }\n\n  function countThisRecursive(uint256 n) public nonReentrant {\n    if (n > 0) {\n      count();\n      // solium-disable-next-line security/no-low-level-calls\n      bool result = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));\n      require(result == true);\n    }\n  }\n\n  function countAndCall(ReentrancyAttack attacker) public nonReentrant {\n    count();\n    bytes4 func = bytes4(keccak256(\"callback()\"));\n    attacker.callSender(func);\n  }\n\n  function count() private {\n    counter += 1;\n  }\n\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ReentrancyMock.sol",
        "vulnerability": "Callstack Depth Attack Vulnerability",
        "check": "FP",
        "response": "Answer: No\nReason: The ReentrancyGuard is used to prevent re-entrancy attacks, and there is no evidence of untrusted external contract calls that could lead to a call stack depth attack."
    },
    {
        "code_segment": "contract ERC165CheckerMock {\n  using ERC165Checker for address;\n\n  function supportsERC165(address account)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsERC165();\n  }\n\n  function supportsInterface(address account, bytes4 interfaceId)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsInterface(interfaceId);\n  }\n\n  function supportsAllInterfaces(address account, bytes4[] interfaceIds)\n    public\n    view\n    returns (bool)\n  {\n    return account._supportsAllInterfaces(interfaceIds);\n  }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Chainsulting-Shopping-project1/openzeppelin-contracts-2.0.1/contracts/mocks/ERC165CheckerMock.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No  \nReason: The code provided does not involve any arithmetic operations, hence there is no risk of integer overflow."
    },
    {
        "code_segment": "contract ENS is AbstractENS {\n    struct Record {\n        address owner;\n        address resolver;\n        uint64 ttl;\n    }\n\n    mapping(bytes32=>Record) records;\n\n    // Permits modifications only by the owner of the specified node.\n    modifier only_owner(bytes32 node) {\n        if (records[node].owner != msg.sender) throw;\n        _;\n    }\n\n    /**\n     * Constructs a new ENS registrar.\n     */\n    function ENS() {\n        records[0].owner = msg.sender;\n    }\n\n    /**\n     * Returns the address that owns the specified node.\n     */\n    function owner(bytes32 node) constant returns (address) {\n        return records[node].owner;\n    }\n\n    /**\n     * Returns the address of the resolver for the specified node.\n     */\n    function resolver(bytes32 node) constant returns (address) {\n        return records[node].resolver;\n    }\n\n    /**\n     * Returns the TTL of a node, and any records associated with it.\n     */\n    function ttl(bytes32 node) constant returns (uint64) {\n        return records[node].ttl;\n    }\n\n    /**\n     * Transfers ownership of a node to a new address. May only be called by the current\n     * owner of the node.\n     * @param node The node to transfer ownership of.\n     * @param owner The address of the new owner.\n     */\n    function setOwner(bytes32 node, address owner) only_owner(node) {\n        Transfer(node, owner);\n        records[node].owner = owner;\n    }\n\n    /**\n     * Transfers ownership of a subnode sha3(node, label) to a new address. May only be\n     * called by the owner of the parent node.\n     * @param node The parent node.\n     * @param label The hash of the label specifying the subnode.\n     * @param owner The address of the new owner.\n     */\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) only_owner(node) {\n        var subnode = sha3(node, label);\n        NewOwner(node, label, owner);\n        records[subnode].owner = owner;\n    }\n\n    /**\n     * Sets the resolver address for the specified node.\n     * @param node The node to update.\n     * @param resolver The address of the resolver.\n     */\n    function setResolver(bytes32 node, address resolver) only_owner(node) {\n        NewResolver(node, resolver);\n        records[node].resolver = resolver;\n    }\n\n    /**\n     * Sets the TTL for the specified node.\n     * @param node The node to update.\n     * @param ttl The TTL in seconds.\n     */\n    function setTTL(bytes32 node, uint64 ttl) only_owner(node) {\n        NewTTL(node, ttl);\n        records[node].ttl = ttl;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-SONM Smart Contracts Security Analysis/core-8b349d25214c6c600f4724e3e9ed3dbc57f9ae63/vendor/github.com/ethereum/go-ethereum/contracts/ens/contract/ens.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The code uses `uint64` for the TTL, which is a fixed-size integer type and does not involve arithmetic operations that could cause an overflow."
    },
    {
        "code_segment": "contract Ownable is EternalStorage {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-TokenBridge (by POA Network) Smart Contracts Security Analysis/tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/Ownable.sol",
        "vulnerability": "Integer Overflow",
        "check": "FP",
        "response": "Answer: No\nReason: The provided code does not include any arithmetic operations, which are typically involved in integer overflow vulnerabilities."
    },
    {
        "code_segment": "contract Ownable is EternalStorage {\n    /**\n    * @dev Event to show ownership has been transferred\n    * @param previousOwner representing the address of the previous owner\n    * @param newOwner representing the address of the new owner\n    */\n    event OwnershipTransferred(address previousOwner, address newOwner);\n\n    /**\n    * @dev Throws if called by any account other than the owner.\n    */\n    modifier onlyOwner() {\n        require(msg.sender == owner());\n        _;\n    }\n\n    /**\n    * @dev Tells the address of the owner\n    * @return the address of the owner\n    */\n    function owner() public view returns (address) {\n        return addressStorage[keccak256(abi.encodePacked(\"owner\"))];\n    }\n\n    /**\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\n    * @param newOwner the address to transfer ownership to.\n    */\n    function transferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        setOwner(newOwner);\n    }\n\n    /**\n    * @dev Sets a new owner address\n    */\n    function setOwner(address newOwner) internal {\n        emit OwnershipTransferred(owner(), newOwner);\n        addressStorage[keccak256(abi.encodePacked(\"owner\"))] = newOwner;\n    }\n}",
        "filename": "Dapp_dataset/negative/DAppSCAN-source/contracts/Smartdec-TokenBridge (by POA Network) Smart Contracts Security Analysis/tokenbridge-contracts-bbb97a63c900f03a902d0e82358abac3b294e4d9/contracts/upgradeable_contracts/Ownable.sol",
        "vulnerability": "Integer Underflow",
        "check": "FP",
        "response": "Answer: No\nReason: The presented code does not perform any arithmetic operations that could lead to an integer underflow."
    }
]