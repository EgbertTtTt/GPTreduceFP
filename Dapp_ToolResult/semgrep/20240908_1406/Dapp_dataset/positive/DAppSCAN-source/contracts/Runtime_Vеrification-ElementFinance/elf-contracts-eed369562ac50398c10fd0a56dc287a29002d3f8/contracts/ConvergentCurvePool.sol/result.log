METRICS: Using configs from the Registry (like --config=p/ci) reports pseudonymous rule metrics to semgrep.dev.
To disable Registry rule metrics, use "--metrics=off".
Using configs only from local files (like --config=xyz.yml) does not enable metrics.

More information: https://semgrep.dev/docs/metrics

               
               
┌─────────────┐
│ Scan Status │
└─────────────┘
  Scanning 1 file tracked by git with 48 Code rules:
  Scanning 1 file with 48 solidity rules.
                    
                    
┌──────────────────┐
│ 57 Code Findings │
└──────────────────┘
                                
    /sb/ConvergentCurvePool.sol 
       solidity.performance.inefficient-state-variable-increment             
          <x> += <y> costs more gas than <x> = <x> + <y> for state variables.
                                                                             
         2149┆ feesUnderlying += uint128(
         2150┆     _fixedToToken(impliedYieldFee, underlying)
            ⋮┆----------------------------------------
         2160┆ feesBond += uint128(_fixedToToken(impliedYieldFee, bond));
            ⋮┆----------------------------------------
         2171┆ feesBond += uint128(_fixedToToken(impliedYieldFee, bond));
            ⋮┆----------------------------------------
         2180┆ feesUnderlying += uint128(
         2181┆     _fixedToToken(impliedYieldFee, underlying)
            ⋮┆----------------------------------------
       solidity.performance.non-payable-constructor      
          Consider making costructor payable to save gas.
                                                         
         1600┆ constructor(string memory tokenName, string memory tokenSymbol) {
         1601┆     _name = tokenName;
         1602┆     _symbol = tokenSymbol;
         1603┆ }
            ⋮┆----------------------------------------
         1765┆ constructor(
         1766┆     IERC20 _underlying,
         1767┆     IERC20 _bond,
         1768┆     uint256 _expiration,
         1769┆     uint256 _unitSeconds,
         1770┆     IVault vault,
         1771┆     uint256 _percentFee,
         1772┆     uint256 _percentFeeGov,
         1773┆     address _governance,
         1774┆     string memory name,
             [hid 34 additional lines, adjust with --max-lines-per-finding] 
       solidity.performance.use-custom-error-not-require                        
          Consider using custom errors as they are more gas efficient while     
  allowing developers  to                                                       
          describe the error in detail using NatSpec.                           
                                                                                
          148┆ require(x >= EXPONENT_LB && x <= EXPONENT_UB, "OUT_OF_BOUNDS");
            ⋮┆----------------------------------------
          228┆ require(a > 0, "OUT_OF_BOUNDS");
            ⋮┆----------------------------------------
          313┆ require(x < 2**255, "X_OUT_OF_BOUNDS"); // uint256 can be casted 
  to a positive int256                                                          
            ⋮┆----------------------------------------
          314┆ require(y < MILD_EXPONENT_BOUND, "Y_OUT_OF_BOUNDS");
            ⋮┆----------------------------------------
          324┆ require(
          325┆     EXPONENT_LB * DECIMALS <= logx_times_y && logx_times_y <=    
  EXPONENT_UB * DECIMALS,                                                       
          326┆     "PRODUCT_OUT_OF_BOUNDS"
          327┆ );
            ⋮┆----------------------------------------
          402┆ require(c >= a, "ADD_OVERFLOW");
            ⋮┆----------------------------------------
          409┆ require(b <= a, "SUB_OVERFLOW");
            ⋮┆----------------------------------------
          416┆ require(a == 0 || c0 / a == b, "MUL_OVERFLOW");
            ⋮┆----------------------------------------
          418┆ require(c1 >= c0, "MUL_OVERFLOW");
            ⋮┆----------------------------------------
          425┆ require(a == 0 || product / a == b, "MUL_OVERFLOW");
            ⋮┆----------------------------------------
          432┆ require(a == 0 || product / a == b, "MUL_OVERFLOW");
            ⋮┆----------------------------------------
          448┆ require(b != 0, "ZERO_DIVISION");
            ⋮┆----------------------------------------
          450┆ require(a == 0 || c0 / a == ONE, "DIV_INTERNAL"); // mul overflow
            ⋮┆----------------------------------------
          452┆ require(c1 >= c0, "DIV_INTERNAL"); // add require
            ⋮┆----------------------------------------
          458┆ require(b != 0, "ZERO_DIVISION");
            ⋮┆----------------------------------------
          464┆ require(aInflated / a == ONE, "DIV_INTERNAL"); // mul overflow
            ⋮┆----------------------------------------
          471┆ require(b != 0, "ZERO_DIVISION");
            ⋮┆----------------------------------------
          477┆ require(aInflated / a == ONE, "DIV_INTERNAL"); // mul overflow
            ⋮┆----------------------------------------
         1494┆ require(c >= a, "ADD_OVERFLOW");
            ⋮┆----------------------------------------
         1503┆ require((b >= 0 && c >= a) || (b < 0 && c < a), "ADD_OVERFLOW");
            ⋮┆----------------------------------------
         1511┆ require(b <= a, "SUB_OVERFLOW");
            ⋮┆----------------------------------------
         1521┆ require((b >= 0 && c <= a) || (b < 0 && c > a), "SUB_OVERFLOW");
            ⋮┆----------------------------------------
         1541┆ require(a == 0 || c / a == b, "MUL_OVERFLOW");
            ⋮┆----------------------------------------
         1546┆ require(b != 0, "ZERO_DIVISION");
            ⋮┆----------------------------------------
         1551┆ require(b != 0, "ZERO_DIVISION");
            ⋮┆----------------------------------------
         1651┆ require(msg.sender == sender || currentAllowance >= amount,      
  "INSUFFICIENT_ALLOWANCE");                                                    
            ⋮┆----------------------------------------
         1656┆ require(currentAllowance >= amount, "INSUFFICIENT_ALLOWANCE");
            ⋮┆----------------------------------------
         1691┆ require(currentBalance >= amount, "INSUFFICIENT_BALANCE");
            ⋮┆----------------------------------------
         1704┆ require(currentBalance >= amount, "INSUFFICIENT_BALANCE");
            ⋮┆----------------------------------------
         1953┆ require(msg.sender == address(_vault), "Non Vault caller");
            ⋮┆----------------------------------------
         1955┆ require(
         1956┆     currentBalances.length == 2 && maxAmountsIn.length == 2,
         1957┆     "Invalid format"
         1958┆ );
            ⋮┆----------------------------------------
         2034┆ require(msg.sender == address(_vault), "Non Vault caller");
            ⋮┆----------------------------------------
         2036┆ require(
         2037┆     currentBalances.length == 2 && minAmountsOut.length == 2,
         2038┆     "Invalid format"
         2039┆ );
            ⋮┆----------------------------------------
         2319┆ require(
         2320┆     localFeeUnderlying >=                                        
  (feesUsedUnderlying).div(percentFeeGov),                                      
         2321┆     "Underflow"
         2322┆ );
            ⋮┆----------------------------------------
         2323┆ require(localFeeBond >= (feesUsedBond).div(percentFeeGov),       
  "Underflow");                                                                 
            ⋮┆----------------------------------------
         2370┆ revert("Token request doesn't match stored");
            ⋮┆----------------------------------------
         2389┆ revert("Called with non pool token");
            ⋮┆----------------------------------------
         2410┆ revert("Called with non pool token");
            ⋮┆----------------------------------------
       solidity.performance.use-multiple-require                                
          Using multiple require statements is cheaper than using && multiple   
  check combinations.                                                           
          There are more advantages, such as easier to read code and better     
  coverage reports.                                                             
                                                                                
          148┆ require(x >= EXPONENT_LB && x <= EXPONENT_UB, "OUT_OF_BOUNDS");
            ⋮┆----------------------------------------
          324┆ require(
          325┆     EXPONENT_LB * DECIMALS <= logx_times_y && logx_times_y <=    
  EXPONENT_UB * DECIMALS,                                                       
          326┆     "PRODUCT_OUT_OF_BOUNDS"
          327┆ );
            ⋮┆----------------------------------------
         1503┆ require((b >= 0 && c >= a) || (b < 0 && c < a), "ADD_OVERFLOW");
            ⋮┆----------------------------------------
         1521┆ require((b >= 0 && c <= a) || (b < 0 && c > a), "SUB_OVERFLOW");
            ⋮┆----------------------------------------
         1955┆ require(
         1956┆     currentBalances.length == 2 && maxAmountsIn.length == 2,
         1957┆     "Invalid format"
         1958┆ );
            ⋮┆----------------------------------------
         2036┆ require(
         2037┆     currentBalances.length == 2 && minAmountsOut.length == 2,
         2038┆     "Invalid format"
         2039┆ );
            ⋮┆----------------------------------------
       solidity.performance.use-nested-if                                       
          Using nested is cheaper than using && multiple check combinations.    
  There are more                                                                
          advantages, such as easier to read code and better coverage reports.  
                                                                                
          318┆ if (PRECISION_LOG_UNDER_BOUND < x_int256 && x_int256 <           
  PRECISION_LOG_UPPER_BOUND) {                                                  
          319┆     int256 logbase = n_log_36(x_int256);
          320┆     logx_times_y = ((logbase / DECIMALS) * y_int256 + ((logbase %
  DECIMALS) * y_int256) / DECIMALS);                                            
          321┆ } else {
          322┆     logx_times_y = n_log(x_int256) * y_int256;
          323┆ }
            ⋮┆----------------------------------------
          341┆ if (PRECISION_LOG_UNDER_BOUND < base && base <                   
  PRECISION_LOG_UPPER_BOUND) {                                                  
          342┆     logbase = n_log_36(base);
          343┆ } else {
          344┆     logbase = n_log(base) * DECIMALS;
          345┆ }
            ⋮┆----------------------------------------
          347┆ if (PRECISION_LOG_UNDER_BOUND < arg && arg <                     
  PRECISION_LOG_UPPER_BOUND) {                                                  
          348┆     logarg = n_log_36(arg);
          349┆ } else {
          350┆     logarg = n_log(arg) * DECIMALS;
          351┆ }
            ⋮┆----------------------------------------
         1655┆ if (msg.sender != sender && currentAllowance != uint256(-1)) {
         1656┆     require(currentAllowance >= amount,                          
  "INSUFFICIENT_ALLOWANCE");                                                    
         1657┆     _setAllowance(sender, msg.sender, currentAllowance - amount);
         1658┆ }
            ⋮┆----------------------------------------
         2362┆ if (tokenIn == underlying && tokenOut == bond) {
         2363┆     // We return (underlyingReserve, bondReserve + totalLP)
         2364┆     return (reserveTokenIn, reserveTokenOut + totalSupply());
         2365┆ } else if (tokenIn == bond && tokenOut == underlying) {
         2366┆     // We return (bondReserve + totalLP, underlyingReserve)
         2367┆     return (reserveTokenIn + totalSupply(), reserveTokenOut);
         2368┆ }
            ⋮┆----------------------------------------
         2365┆ } else if (tokenIn == bond && tokenOut == underlying) {
         2366┆     // We return (bondReserve + totalLP, underlyingReserve)
         2367┆     return (reserveTokenIn + totalSupply(), reserveTokenOut);
         2368┆ }
            ⋮┆----------------------------------------
       solidity.performance.use-short-revert-string                             
          Shortening revert strings to fit in 32 bytes will decrease gas costs  
  for deployment and  gas                                                       
          costs when the revert condition has been met.                         
                                                                                
         2370┆ revert("Token request doesn't match stored");

                
                
┌──────────────┐
│ Scan Summary │
└──────────────┘

Ran 48 rules on 1 file: 57 findings.

A new version of Semgrep is available. See https://semgrep.dev/docs/upgrading

Versions prior to 1.43.0 will cease to work with Semgrep.dev after March 11th 2024, please upgrade.
