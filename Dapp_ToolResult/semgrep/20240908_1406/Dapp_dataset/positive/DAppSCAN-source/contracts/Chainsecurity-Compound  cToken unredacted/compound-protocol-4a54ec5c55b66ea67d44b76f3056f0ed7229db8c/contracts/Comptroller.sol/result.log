METRICS: Using configs from the Registry (like --config=p/ci) reports pseudonymous rule metrics to semgrep.dev.
To disable Registry rule metrics, use "--metrics=off".
Using configs only from local files (like --config=xyz.yml) does not enable metrics.

More information: https://semgrep.dev/docs/metrics

               
               
┌─────────────┐
│ Scan Status │
└─────────────┘
  Scanning 1 file tracked by git with 48 Code rules:
  Scanning 1 file with 48 solidity rules.
                     
                     
┌───────────────────┐
│ 120 Code Findings │
└───────────────────┘
                        
    /sb/Comptroller.sol 
       solidity.performance.array-length-outside-loop                           
          Caching the array length outside a loop saves reading it on each      
  iteration, as long as the                                                     
          array's length is not changed during the loop.                        
                                                                                
         3325┆ for (uint i = 0; i < assets.length; i++) {
            ⋮┆----------------------------------------
         3548┆ for (uint i = 0; i < allMarkets.length; i ++) {
            ⋮┆----------------------------------------
         3839┆ for (uint i = 0; i < cTokens.length; i++) {
            ⋮┆----------------------------------------
         3845┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
         3851┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
         3856┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
       solidity.performance.non-payable-constructor      
          Consider making costructor payable to save gas.
                                                         
         2194┆ constructor() public {
         2195┆     // Set admin to caller
         2196┆     admin = msg.sender;
         2197┆ }
            ⋮┆----------------------------------------
         2371┆ constructor(address account) public {
         2372┆     balances[account] = uint96(totalSupply);
         2373┆     emit Transfer(address(0), account, totalSupply);
         2374┆ }
            ⋮┆----------------------------------------
         2679┆ constructor() {
         2680┆     admin = msg.sender;
         2681┆ }
            ⋮┆----------------------------------------
       solidity.performance.state-variable-read-in-a-loop                       
          Replace state variable reads and writes within loops with local       
  variable reads and writes.                                                    
                                                                                
         2519┆ Checkpoint memory cp = checkpoints[account][center];
            ⋮┆----------------------------------------
       solidity.performance.unnecessary-checked-arithmetic-in-loop              
          A lot of times there is no risk that the loop counter can overflow.   
  Using Solidity's                                                              
          unchecked block saves the overflow checks.                            
                                                                                
         2715┆ for (uint i = 0; i < len; i++) {
            ⋮┆----------------------------------------
         2795┆ for (uint i = 0; i < len; i++) {
            ⋮┆----------------------------------------
         3325┆ for (uint i = 0; i < assets.length; i++) {
            ⋮┆----------------------------------------
         3548┆ for (uint i = 0; i < allMarkets.length; i ++) {
            ⋮┆----------------------------------------
         3569┆ for(uint i = 0; i < numMarkets; i++) {
            ⋮┆----------------------------------------
         3839┆ for (uint i = 0; i < cTokens.length; i++) {
            ⋮┆----------------------------------------
         3845┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
         3851┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
         3856┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
       solidity.performance.use-custom-error-not-require                        
          Consider using custom errors as they are more gas efficient while     
  allowing developers  to                                                       
          describe the error in detail using NatSpec.                           
                                                                                
          844┆ require(msg.sender == admin, "only admin may initialize the      
  market");                                                                     
            ⋮┆----------------------------------------
          845┆ require(accrualBlockNumber == 0 && borrowIndex == 0, "market may 
  only be initialized once");                                                   
            ⋮┆----------------------------------------
          849┆ require(initialExchangeRateMantissa > 0, "initial exchange rate  
  must be greater than zero.");                                                 
            ⋮┆----------------------------------------
          853┆ require(err == NO_ERROR, "setting comptroller failed");
            ⋮┆----------------------------------------
          861┆ require(err == NO_ERROR, "setting interest rate model failed");
            ⋮┆----------------------------------------
         1036┆ require(accrueInterest() == NO_ERROR, "accrue interest failed");
            ⋮┆----------------------------------------
         1046┆ require(accrueInterest() == NO_ERROR, "accrue interest failed");
            ⋮┆----------------------------------------
         1087┆ require(accrueInterest() == NO_ERROR, "accrue interest failed");
            ⋮┆----------------------------------------
         1157┆ require(borrowRateMantissa <= borrowRateMaxMantissa, "borrow rate
  is absurdly high");                                                           
            ⋮┆----------------------------------------
         1305┆ require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of      
  redeemTokensIn or redeemAmountIn must be zero");                              
            ⋮┆----------------------------------------
         1602┆ require(amountSeizeError == NO_ERROR,                            
  "LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED");                       
            ⋮┆----------------------------------------
         1605┆ require(cTokenCollateral.balanceOf(borrower) >= seizeTokens,     
  "LIQUIDATE_SEIZE_TOO_MUCH");                                                  
            ⋮┆----------------------------------------
         1611┆ require(cTokenCollateral.seize(liquidator, borrower, seizeTokens)
  == NO_ERROR, "token seizure failed");                                         
            ⋮┆----------------------------------------
         1750┆ require(newComptroller.isComptroller(), "marker method returned  
  false");                                                                      
            ⋮┆----------------------------------------
         1968┆ require(newInterestRateModel.isInterestRateModel(), "marker      
  method returned false");                                                      
            ⋮┆----------------------------------------
         2008┆ require(_notEntered, "re-entered");
            ⋮┆----------------------------------------
         2474┆ require(signatory != address(0), "Comp::delegateBySig: invalid   
  signature");                                                                  
            ⋮┆----------------------------------------
         2475┆ require(nonce == nonces[signatory]++, "Comp::delegateBySig:      
  invalid nonce");                                                              
            ⋮┆----------------------------------------
         2476┆ require(block.timestamp <= expiry, "Comp::delegateBySig:         
  signature expired");                                                          
            ⋮┆----------------------------------------
         2498┆ require(blockNumber < block.number, "Comp::getPriorVotes: not yet
  determined");                                                                 
            ⋮┆----------------------------------------
         2542┆ require(src != address(0), "Comp::_transferTokens: cannot        
  transfer from the zero address");                                             
            ⋮┆----------------------------------------
         2543┆ require(dst != address(0), "Comp::_transferTokens: cannot        
  transfer to the zero address");                                               
            ⋮┆----------------------------------------
         2767┆ require(oErr == 0, "exitMarket: getAccountSnapshot failed"); //  
  semi-opaque error code                                                        
            ⋮┆----------------------------------------
         2826┆ require(!mintGuardianPaused[cToken], "mint is paused");
            ⋮┆----------------------------------------
         2919┆ revert("redeemTokens zero");
            ⋮┆----------------------------------------
         2932┆ require(!borrowGuardianPaused[cToken], "borrow is paused");
            ⋮┆----------------------------------------
         2940┆ require(msg.sender == cToken, "sender must be cToken");
            ⋮┆----------------------------------------
         2962┆ require(nextTotalBorrows < borrowCap, "market borrow cap         
  reached");                                                                    
            ⋮┆----------------------------------------
         3081┆ require(borrowBalance >= repayAmount, "Can not repay more than   
  the total borrow");                                                           
            ⋮┆----------------------------------------
         3146┆ require(!seizeGuardianPaused, "seize is paused");
            ⋮┆----------------------------------------
         3204┆ require(!transferGuardianPaused, "transfer is paused");
            ⋮┆----------------------------------------
         3442┆ require(msg.sender == admin, "only admin can set close factor");
            ⋮┆----------------------------------------
         3549┆ require(allMarkets[i] != CToken(cToken), "market already added");
            ⋮┆----------------------------------------
         3562┆ require(msg.sender == admin || msg.sender == borrowCapGuardian,  
  "only admin or borrow cap guardian can set borrow caps");                     
            ⋮┆----------------------------------------
         3567┆ require(numMarkets != 0 && numMarkets == numBorrowCaps, "invalid 
  input");                                                                      
            ⋮┆----------------------------------------
         3580┆ require(msg.sender == admin, "only admin can set borrow cap      
  guardian");                                                                   
            ⋮┆----------------------------------------
         3615┆ require(markets[address(cToken)].isListed, "cannot pause a market
  that is not listed");                                                         
            ⋮┆----------------------------------------
         3616┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3617┆ require(msg.sender == admin || state == true, "only admin can    
  unpause");                                                                    
            ⋮┆----------------------------------------
         3625┆ require(markets[address(cToken)].isListed, "cannot pause a market
  that is not listed");                                                         
            ⋮┆----------------------------------------
         3626┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3627┆ require(msg.sender == admin || state == true, "only admin can    
  unpause");                                                                    
            ⋮┆----------------------------------------
         3635┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3636┆ require(msg.sender == admin || state == true, "only admin can    
  unpause");                                                                    
            ⋮┆----------------------------------------
         3644┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3645┆ require(msg.sender == admin || state == true, "only admin can    
  unpause");                                                                    
            ⋮┆----------------------------------------
         3653┆ require(msg.sender == unitroller.admin(), "only unitroller admin 
  can change brains");                                                          
            ⋮┆----------------------------------------
         3654┆ require(unitroller._acceptImplementation() == 0, "change not     
  authorized");                                                                 
            ⋮┆----------------------------------------
         3681┆ require(market.isListed == true, "comp market is not listed");
            ⋮┆----------------------------------------
         3841┆ require(markets[address(cToken)].isListed, "market must be       
  listed");                                                                     
            ⋮┆----------------------------------------
         3887┆ require(adminOrInitializing(), "only admin can grant comp");
            ⋮┆----------------------------------------
         3889┆ require(amountLeft == 0, "insufficient comp for grant");
            ⋮┆----------------------------------------
         3899┆ require(adminOrInitializing(), "only admin can set comp speed");
            ⋮┆----------------------------------------
         3909┆ require(adminOrInitializing(), "only admin can set comp speed");
            ⋮┆----------------------------------------
       solidity.performance.use-multiple-require                                
          Using multiple require statements is cheaper than using && multiple   
  check combinations.                                                           
          There are more advantages, such as easier to read code and better     
  coverage reports.                                                             
                                                                                
          845┆ require(accrualBlockNumber == 0 && borrowIndex == 0, "market may 
  only be initialized once");                                                   
            ⋮┆----------------------------------------
         3567┆ require(numMarkets != 0 && numMarkets == numBorrowCaps, "invalid 
  input");                                                                      
            ⋮┆----------------------------------------
       solidity.performance.use-nested-if                                       
          Using nested is cheaper than using && multiple check combinations.    
  There are more                                                                
          advantages, such as easier to read code and better coverage reports.  
                                                                                
         2441┆ if (spender != src && spenderAllowance != type(uint96).max) {
         2442┆     uint96 newAllowance = sub96(spenderAllowance, amount,        
  "Comp::transferFrom: transfer amount exceeds spender allowance");             
         2443┆     allowances[src][spender] = newAllowance;
         2444┆ 
         2445┆     emit Approval(src, spender, newAllowance);
         2446┆ }
            ⋮┆----------------------------------------
         2553┆ if (srcRep != dstRep && amount > 0) {
         2554┆     if (srcRep != address(0)) {
         2555┆         uint32 srcRepNum = numCheckpoints[srcRep];
         2556┆         uint96 srcRepOld = srcRepNum > 0 ?                       
  checkpoints[srcRep][srcRepNum - 1].votes : 0;                                 
         2557┆         uint96 srcRepNew = sub96(srcRepOld, amount,              
  "Comp::_moveVotes: vote amount underflows");                                  
         2558┆         _writeCheckpoint(srcRep, srcRepNum, srcRepOld,           
  srcRepNew);                                                                   
         2559┆     }
         2560┆ 
         2561┆     if (dstRep != address(0)) {
         2562┆         uint32 dstRepNum = numCheckpoints[dstRep];
             [hid 5 additional lines, adjust with --max-lines-per-finding] 
         2573┆ if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints -    
  1].fromBlock == blockNumber) {                                                
         2574┆     checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;
         2575┆ } else {
         2576┆     checkpoints[delegatee][nCheckpoints] =                       
  Checkpoint(blockNumber, newVotes);                                            
         2577┆     numCheckpoints[delegatee] = nCheckpoints + 1;
         2578┆ }
            ⋮┆----------------------------------------
         2918┆ if (redeemTokens == 0 && redeemAmount > 0) {
         2919┆     revert("redeemTokens zero");
         2920┆ }
            ⋮┆----------------------------------------
         3479┆ if (newCollateralFactorMantissa != 0 &&                          
  oracle.getUnderlyingPrice(cToken) == 0) {                                     
         3480┆     return fail(Error.PRICE_ERROR,                               
  FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);                             
         3481┆ }
            ⋮┆----------------------------------------
         3683┆ if (compSupplyState[address(cToken)].index == 0 &&               
  compSupplyState[address(cToken)].block == 0) {                                
         3684┆     compSupplyState[address(cToken)] = CompMarketState({
         3685┆         index: compInitialIndex,
         3686┆         block: safe32(getBlockNumber(), "block number exceeds 32 
  bits")                                                                        
         3687┆     });
         3688┆ }
            ⋮┆----------------------------------------
         3690┆ if (compBorrowState[address(cToken)].index == 0 &&               
  compBorrowState[address(cToken)].block == 0) {                                
         3691┆     compBorrowState[address(cToken)] = CompMarketState({
         3692┆         index: compInitialIndex,
         3693┆         block: safe32(getBlockNumber(), "block number exceeds 32 
  bits")                                                                        
         3694┆     });
         3695┆ }
            ⋮┆----------------------------------------
         3713┆ if (deltaBlocks > 0 && supplySpeed > 0) {
         3714┆     uint supplyTokens = CToken(cToken).totalSupply();
         3715┆     uint compAccrued = mul_(deltaBlocks, supplySpeed);
         3716┆     Double memory ratio = supplyTokens > 0 ?                     
  fraction(compAccrued, supplyTokens) : Double({mantissa: 0});                  
         3717┆     Double memory index = add_(Double({mantissa:                 
  supplyState.index}), ratio);                                                  
         3718┆     compSupplyState[cToken] = CompMarketState({
         3719┆         index: safe224(index.mantissa, "new index exceeds 224    
  bits"),                                                                       
         3720┆         block: safe32(blockNumber, "block number exceeds 32      
  bits")                                                                        
         3721┆     });
         3722┆ } else if (deltaBlocks > 0) {
             [hid 2 additional lines, adjust with --max-lines-per-finding] 
         3736┆ if (deltaBlocks > 0 && borrowSpeed > 0) {
         3737┆     uint borrowAmount = div_(CToken(cToken).totalBorrows(),      
  marketBorrowIndex);                                                           
         3738┆     uint compAccrued = mul_(deltaBlocks, borrowSpeed);
         3739┆     Double memory ratio = borrowAmount > 0 ?                     
  fraction(compAccrued, borrowAmount) : Double({mantissa: 0});                  
         3740┆     Double memory index = add_(Double({mantissa:                 
  borrowState.index}), ratio);                                                  
                
                
┌──────────────┐
│ Scan Summary │
└──────────────┘

Ran 48 rules on 1 file: 120 findings.
         3741┆     compBorrowState[cToken] = CompMarketState({
         3742┆         index: safe224(index.mantissa, "new index exceeds 224    
  bits"),                                                                       
         3743┆         block: safe32(blockNumber, "block number exceeds 32      
  bits")                                                                        
         3744┆     });
         3745┆ } else if (deltaBlocks > 0) {
             [hid 2 additional lines, adjust with --max-lines-per-finding] 
         3761┆ if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {
         3762┆     supplierIndex.mantissa = compInitialIndex;
         3763┆ }
            ⋮┆----------------------------------------
         3803┆ if (deltaBlocks > 0 && compSpeed > 0) {
         3804┆     uint newAccrued = mul_(deltaBlocks, compSpeed);
         3805┆     uint contributorAccrued = add_(compAccrued[contributor],     
  newAccrued);                                                                  
         3806┆ 
         3807┆     compAccrued[contributor] = contributorAccrued;
         3808┆     lastContributorBlock[contributor] = blockNumber;
         3809┆ }
            ⋮┆----------------------------------------
         3871┆ if (amount > 0 && amount <= compRemaining) {
         3872┆     comp.transfer(user, amount);
         3873┆     return 0;
         3874┆ }
            ⋮┆----------------------------------------
       solidity.performance.use-prefix-increment-not-postfix                    
          Consider using the prefix increment expression whenever the return    
  value is not needed. The                                                      
          prefix increment expression is cheaper in terms of gas.               
                                                                                
         2475┆ require(nonce == nonces[signatory]++, "Comp::delegateBySig:      
  invalid nonce");                                                              
            ⋮┆----------------------------------------
         2715┆ for (uint i = 0; i < len; i++) {
            ⋮┆----------------------------------------
         2795┆ for (uint i = 0; i < len; i++) {
            ⋮┆----------------------------------------
         3325┆ for (uint i = 0; i < assets.length; i++) {
            ⋮┆----------------------------------------
         3548┆ for (uint i = 0; i < allMarkets.length; i ++) {
            ⋮┆----------------------------------------
         3569┆ for(uint i = 0; i < numMarkets; i++) {
            ⋮┆----------------------------------------
         3839┆ for (uint i = 0; i < cTokens.length; i++) {
            ⋮┆----------------------------------------
         3845┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
         3851┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
         3856┆ for (uint j = 0; j < holders.length; j++) {
            ⋮┆----------------------------------------
       solidity.performance.use-short-revert-string                             
          Shortening revert strings to fit in 32 bytes will decrease gas costs  
  for deployment and  gas                                                       
          costs when the revert condition has been met.                         
                                                                                
          844┆ require(msg.sender == admin, "only admin may initialize the      
  market");                                                                     
            ⋮┆----------------------------------------
          845┆ require(accrualBlockNumber == 0 && borrowIndex == 0, "market may 
  only be initialized once");                                                   
            ⋮┆----------------------------------------
          849┆ require(initialExchangeRateMantissa > 0, "initial exchange rate  
  must be greater than zero.");                                                 
            ⋮┆----------------------------------------
          861┆ require(err == NO_ERROR, "setting interest rate model failed");
            ⋮┆----------------------------------------
         1305┆ require(redeemTokensIn == 0 || redeemAmountIn == 0, "one of      
  redeemTokensIn or redeemAmountIn must be zero");                              
            ⋮┆----------------------------------------
         1602┆ require(amountSeizeError == NO_ERROR,                            
  "LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED");                       
            ⋮┆----------------------------------------
         2474┆ require(signatory != address(0), "Comp::delegateBySig: invalid   
  signature");                                                                  
            ⋮┆----------------------------------------
         2475┆ require(nonce == nonces[signatory]++, "Comp::delegateBySig:      
  invalid nonce");                                                              
            ⋮┆----------------------------------------
         2476┆ require(block.timestamp <= expiry, "Comp::delegateBySig:         
  signature expired");                                                          
            ⋮┆----------------------------------------
         2498┆ require(blockNumber < block.number, "Comp::getPriorVotes: not yet
  determined");                                                                 
            ⋮┆----------------------------------------
         2542┆ require(src != address(0), "Comp::_transferTokens: cannot        
  transfer from the zero address");                                             
            ⋮┆----------------------------------------
         2543┆ require(dst != address(0), "Comp::_transferTokens: cannot        
  transfer to the zero address");                                               
            ⋮┆----------------------------------------
         2767┆ require(oErr == 0, "exitMarket: getAccountSnapshot failed"); //  
  semi-opaque error code                                                        
            ⋮┆----------------------------------------
         3081┆ require(borrowBalance >= repayAmount, "Can not repay more than   
  the total borrow");                                                           
            ⋮┆----------------------------------------
         3562┆ require(msg.sender == admin || msg.sender == borrowCapGuardian,  
  "only admin or borrow cap guardian can set borrow caps");                     
            ⋮┆----------------------------------------
         3580┆ require(msg.sender == admin, "only admin can set borrow cap      
  guardian");                                                                   
            ⋮┆----------------------------------------
         3615┆ require(markets[address(cToken)].isListed, "cannot pause a market
  that is not listed");                                                         
            ⋮┆----------------------------------------
         3616┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3625┆ require(markets[address(cToken)].isListed, "cannot pause a market
  that is not listed");                                                         
            ⋮┆----------------------------------------
         3626┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3635┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3644┆ require(msg.sender == pauseGuardian || msg.sender == admin, "only
  pause guardian and admin can pause");                                         
            ⋮┆----------------------------------------
         3653┆ require(msg.sender == unitroller.admin(), "only unitroller admin 
  can change brains");                                                          


A new version of Semgrep is available. See https://semgrep.dev/docs/upgrading

Versions prior to 1.43.0 will cease to work with Semgrep.dev after March 11th 2024, please upgrade.
