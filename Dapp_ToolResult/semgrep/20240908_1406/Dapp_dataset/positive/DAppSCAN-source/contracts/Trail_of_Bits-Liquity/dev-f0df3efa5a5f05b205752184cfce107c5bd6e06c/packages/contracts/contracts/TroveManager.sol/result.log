METRICS: Using configs from the Registry (like --config=p/ci) reports pseudonymous rule metrics to semgrep.dev.
To disable Registry rule metrics, use "--metrics=off".
Using configs only from local files (like --config=xyz.yml) does not enable metrics.

More information: https://semgrep.dev/docs/metrics

               
               
┌─────────────┐
│ Scan Status │
└─────────────┘
  Scanning 1 file tracked by git with 48 Code rules:
  Scanning 1 file with 48 solidity rules.
                    
                    
┌──────────────────┐
│ 42 Code Findings │
└──────────────────┘
                         
    /sb/TroveManager.sol 
       solidity.best-practice.use-ownable2step                                  
          By demanding that the receiver of the owner permissions actively      
  accept via a contract call                                                    
          of its own,  `Ownable2Step` and `Ownable2StepUpgradeable` prevent the 
  contract ownership                                                            
          from accidentally being transferred  to an address that cannot handle 
  it.                                                                           
                                                                                
         2718┆ contract TroveManager is LiquityBase, Ownable, ITroveManager {
            ⋮┆----------------------------------------
       solidity.performance.array-length-outside-loop                           
          Caching the array length outside a loop saves reading it on each      
  iteration, as long as the                                                     
          array's length is not changed during the loop.                        
                                                                                
         3345┆ for (L.i = 0; L.i < _troveArray.length; L.i++) {
            ⋮┆----------------------------------------
         3396┆ for (L.i = 0; L.i < _troveArray.length; L.i++) {
            ⋮┆----------------------------------------
       solidity.performance.non-payable-constructor      
          Consider making costructor payable to save gas.
                                                         
         2675┆ constructor () internal {
         2676┆     _owner = msg.sender;
         2677┆     emit OwnershipTransferred(address(0), msg.sender);
         2678┆ }
            ⋮┆----------------------------------------
       solidity.performance.state-variable-read-in-a-loop                       
          Replace state variable reads and writes within loops with local       
  variable reads and writes.                                                    
                                                                                
         3211┆ L.user = sortedTroves.getLast();
            ⋮┆----------------------------------------
         3246┆ if (L.user == sortedTroves.getFirst()) { break; }
            ⋮┆----------------------------------------
         3268┆ L.user = sortedTroves.getLast();
            ⋮┆----------------------------------------
         3282┆ if (L.user == sortedTroves.getFirst()) { break; }
            ⋮┆----------------------------------------
         3622┆ currentBorrower = sortedTroves.getPrev(currentBorrower);
            ⋮┆----------------------------------------
         3631┆ address nextUserToCheck = sortedTroves.getPrev(currentBorrower);
            ⋮┆----------------------------------------
       solidity.performance.use-custom-error-not-require                        
          Consider using custom errors as they are more gas efficient while     
  allowing developers  to                                                       
          describe the error in detail using NatSpec.                           
                                                                                
          498┆ require(c >= a, "SafeMath: addition overflow");
            ⋮┆----------------------------------------
          552┆ require(c / a == b, "SafeMath: multiplication overflow");
            ⋮┆----------------------------------------
         2691┆ require(isOwner(), "Ownable: caller is not the owner");
            ⋮┆----------------------------------------
         3292┆ require(_troveArray.length != 0, "TroveManager: Calldata address 
  array must not be empty");                                                    
            ⋮┆----------------------------------------
         3915┆ require(TroveOwners.length < 2**128 - 1, "TroveManager:          
  TroveOwners array has maximum size of 2^128 - 1");                            
            ⋮┆----------------------------------------
         3932┆ require(Troves[_borrower].status == Status.closed, "TroveManager:
  Trove is still active");                                                      
            ⋮┆----------------------------------------
         4076┆ require(msg.sender == borrowerOperationsAddress, "TroveManager:  
  Caller is not the BorrowerOperations contract");                              
            ⋮┆----------------------------------------
         4080┆ require(Troves[_borrower].status == Status.active, "TroveManager:
  Trove does not exist or is closed");                                          
            ⋮┆----------------------------------------
         4084┆ require(lusdToken.balanceOf(_redeemer) >= _amount, "TroveManager:
  Requested redemption amount must be <= user's LUSD token balance");           
            ⋮┆----------------------------------------
         4088┆ require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() >  
  1, "TroveManager: Only one trove in the system");                             
            ⋮┆----------------------------------------
         4092┆ require(_amount > 0, "TroveManager: Amount must be greater than  
  zero");                                                                       
            ⋮┆----------------------------------------
       solidity.performance.use-multiple-require                                
          Using multiple require statements is cheaper than using && multiple   
  check combinations.                                                           
          There are more advantages, such as easier to read code and better     
  coverage reports.                                                             
                                                                                
         4088┆ require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() >  
  1, "TroveManager: Only one trove in the system");                             
            ⋮┆----------------------------------------
       solidity.performance.use-nested-if                                       
          Using nested is cheaper than using && multiple check combinations.    
  There are more                                                                
          advantages, such as easier to read code and better coverage reports.  
                                                                                
         3020┆ } else if ((_ICR > _100pct) && (_ICR < MCR)) {
         3021┆     _removeStake(_borrower);
         3022┆ 
         3023┆     (V.debtToOffset,
         3024┆     V.collToSendToSP,
         3025┆     V.debtToRedistribute,
         3026┆     V.collToRedistribute) =                                      
  _getOffsetAndRedistributionVals(V.entireTroveDebt, L.collToLiquidate,         
  _LUSDInStabPool);                                                             
         3027┆ 
         3028┆     _closeTrove(_borrower);
         3029┆     emit TroveLiquidated(_borrower, V.entireTroveDebt,           
  V.entireTroveColl, TroveManagerOperation.liquidateInRecoveryMode);            
             [hid 18 additional lines, adjust with --max-lines-per-finding] 
         3035┆ } else if ((_ICR >= MCR) && (_ICR < _TCR)) {
         3036┆     assert(_LUSDInStabPool != 0);
         3037┆ 
         3038┆     _removeStake(_borrower);
         3039┆ 
         3040┆     V = _getFullOrPartialOffsetVals(_borrower, V.entireTroveDebt,
  V.entireTroveColl, _LUSDInStabPool);                                          
         3041┆ 
         3042┆     _closeTrove(_borrower);
         3043┆ }
         3044┆ else if (_ICR >= _TCR) {
             [hid 3 additional lines, adjust with --max-lines-per-finding] 
         3216┆ if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { break; }
            ⋮┆----------------------------------------
         3235┆ else if (L.backToNormalMode == true && L.ICR < MCR) {
         3236┆     V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);
         3237┆ 
         3238┆     L.remainingLUSDInStabPool =                                  
  L.remainingLUSDInStabPool.sub(V.debtToOffset);                                
         3239┆ 
         3240┆     // Add liquidation values to their respective running totals
         3241┆     T = _addLiquidationValuesToTotals(T, V);
         3242┆ 
         3243┆ }  else break;  // break if the loop reaches a Trove with ICR >= 
  MCR                                                                           
            ⋮┆----------------------------------------
         3352┆ if (L.ICR >= MCR && L.remainingLUSDInStabPool == 0) { continue; }
            ⋮┆----------------------------------------
         3372┆ else if (L.backToNormalMode == true && L.ICR < MCR) {
         3373┆     V = _liquidateNormalMode(L.user, L.remainingLUSDInStabPool);
         3374┆     L.remainingLUSDInStabPool =                                  
  L.remainingLUSDInStabPool.sub(V.debtToOffset);                                
         3375┆ 
         3376┆     // Add liquidation values to their respective running totals
         3377┆     T = _addLiquidationValuesToTotals(T, V);
         3378┆ }
            ⋮┆----------------------------------------
       solidity.performance.use-prefix-decrement-not-postfix                    
          Consider using the prefix decrement expression whenever the return    
  value is not needed. The                                                      
          prefix decrement expression is cheaper in terms of gas.               
                                                                                
         3629┆ _maxIterations--;
            ⋮┆----------------------------------------
       solidity.performance.use-prefix-increment-not-postfix                    
          Consider using the prefix increment expression whenever the return    
  value is not needed. The                                                      
          prefix increment expression is cheaper in terms of gas.               
                                                                                
         3248┆ L.i++;
            ⋮┆----------------------------------------
         3283┆ L.i++;
            ⋮┆----------------------------------------
         3345┆ for (L.i = 0; L.i < _troveArray.length; L.i++) {
            ⋮┆----------------------------------------
         3396┆ for (L.i = 0; L.i < _troveArray.length; L.i++) {
            ⋮┆----------------------------------------
       solidity.performance.use-short-revert-string                             
          Shortening revert strings to fit in 32 bytes will decrease gas costs  
  for deployment and  gas                                                       
          costs when the revert condition has been met.                         
                                                                                
          552┆ require(c / a == b, "SafeMath: multiplication overflow");
            ⋮┆----------------------------------------
         3292┆ require(_troveArray.length != 0, "TroveManager: Calldata address 
  array must not be empty");                                                    
            ⋮┆----------------------------------------
         3915┆ require(TroveOwners.length < 2**128 - 1, "TroveManager:          
  TroveOwners array has maximum size of 2^128 - 1");                            
            ⋮┆----------------------------------------
         3932┆ require(Troves[_borrower].status == Status.closed, "TroveManager:
  Trove is still active");                                                      
            ⋮┆----------------------------------------
         4076┆ require(msg.sender == borrowerOperationsAddress, "TroveManager:  
  Caller is not the BorrowerOperations contract");                              
            ⋮┆----------------------------------------
         4080┆ require(Troves[_borrower].status == Status.active, "TroveManager:
  Trove does not exist or is closed");                                          
            ⋮┆----------------------------------------
         4084┆ require(lusdToken.balanceOf(_redeemer) >= _amount, "TroveManager:
  Requested redemption amount must be <= user's LUSD token balance");           
            ⋮┆----------------------------------------
         4088┆ require (TroveOwnersArrayLength > 1 && sortedTroves.getSize() >  
  1, "TroveManager: Only one trove in the system");                             
            ⋮┆----------------------------------------
         4092┆ require(_amount > 0, "TroveManager: Amount must be greater than  
  zero");                                                                       

                
                
┌──────────────┐
│ Scan Summary │
└──────────────┘

Ran 48 rules on 1 file: 42 findings.

A new version of Semgrep is available. See https://semgrep.dev/docs/upgrading

Versions prior to 1.43.0 will cease to work with Semgrep.dev after March 11th 2024, please upgrade.
