METRICS: Using configs from the Registry (like --config=p/ci) reports pseudonymous rule metrics to semgrep.dev.
To disable Registry rule metrics, use "--metrics=off".
Using configs only from local files (like --config=xyz.yml) does not enable metrics.

More information: https://semgrep.dev/docs/metrics

               
               
┌─────────────┐
│ Scan Status │
└─────────────┘
  Scanning 1 file tracked by git with 48 Code rules:
  Scanning 1 file with 48 solidity rules.
                    
                    
┌──────────────────┐
│ 66 Code Findings │
└──────────────────┘
                                 
    /sb/ExchangeRateProvider.sol 
       solidity.performance.array-length-outside-loop                           
          Caching the array length outside a loop saves reading it on each      
  iteration, as long as the                                                     
          array's length is not changed during the loop.                        
                                                                                
          588┆ for (uint i = 0; i < h.length; i ++)
            ⋮┆----------------------------------------
          593┆ while(subindex < n.length && (i + subindex) < h.length && h[i +  
  subindex] == n[subindex])                                                     
            ⋮┆----------------------------------------
          593┆ while(subindex < n.length && (i + subindex) < h.length && h[i +  
  subindex] == n[subindex])                                                     
            ⋮┆----------------------------------------
          597┆ if(subindex == n.length)
            ⋮┆----------------------------------------
          644┆ for (uint i=0; i<bresult.length; i++){
            ⋮┆----------------------------------------
          683┆ outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 +
  3; //+3 accounts for paired identifier types                                  
            ⋮┆----------------------------------------
          683┆ outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 +
  3; //+3 accounts for paired identifier types                                  
            ⋮┆----------------------------------------
          690┆ while (byte(cborlen).length > ctr) {
            ⋮┆----------------------------------------
          697┆ for (uint x = 0; x < elemArray[i].length; x++) {
            ⋮┆----------------------------------------
          700┆ uint elemcborlen = elemArray[i].length - x >= 24 ? 23 :          
  elemArray[i].length - x;                                                      
            ⋮┆----------------------------------------
          700┆ uint elemcborlen = elemArray[i].length - x >= 24 ? 23 :          
  elemArray[i].length - x;                                                      
            ⋮┆----------------------------------------
          703┆ while (byte(elemcborlen).length > ctr - lctr) {
            ⋮┆----------------------------------------
          725┆ outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 +
  3; //+3 accounts for paired identifier types                                  
            ⋮┆----------------------------------------
          725┆ outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 +
  3; //+3 accounts for paired identifier types                                  
            ⋮┆----------------------------------------
          732┆ while (byte(cborlen).length > ctr) {
            ⋮┆----------------------------------------
          739┆ for (uint x = 0; x < elemArray[i].length; x++) {
            ⋮┆----------------------------------------
          742┆ uint elemcborlen = elemArray[i].length - x >= 24 ? 23 :          
  elemArray[i].length - x;                                                      
            ⋮┆----------------------------------------
          742┆ uint elemcborlen = elemArray[i].length - x >= 24 ? 23 :          
  elemArray[i].length - x;                                                      
            ⋮┆----------------------------------------
          745┆ while (byte(elemcborlen).length > ctr - lctr) {
            ⋮┆----------------------------------------
       solidity.performance.non-payable-constructor      
          Consider making costructor payable to save gas.
                                                         
         1137┆ constructor(
         1138┆   address _registryAddress
         1139┆ )
         1140┆   public
         1141┆ {
         1142┆   require(_registryAddress != address(0));
         1143┆   registry = IRegistry(_registryAddress);
         1144┆ }
            ⋮┆----------------------------------------
       solidity.performance.unnecessary-checked-arithmetic-in-loop              
          A lot of times there is no risk that the loop counter can overflow.   
  Using Solidity's                                                              
          unchecked block saves the overflow checks.                            
                                                                                
          588┆ for (uint i = 0; i < h.length; i ++)
            ⋮┆----------------------------------------
          644┆ for (uint i=0; i<bresult.length; i++){
            ⋮┆----------------------------------------
          681┆ for (uint i = 0; i < arrlen; i++) {
            ⋮┆----------------------------------------
          697┆ for (uint x = 0; x < elemArray[i].length; x++) {
            ⋮┆----------------------------------------
          723┆ for (uint i = 0; i < arrlen; i++) {
            ⋮┆----------------------------------------
          739┆ for (uint x = 0; x < elemArray[i].length; x++) {
            ⋮┆----------------------------------------
          909┆ for (uint256 i=0; i< n_random_bytes; i++) {
            ⋮┆----------------------------------------
       solidity.performance.use-multiple-require                                
          Using multiple require statements is cheaper than using && multiple   
  check combinations.                                                           
          There are more advantages, such as easier to read code and better     
  coverage reports.                                                             
                                                                                
          770┆ require((_nbytes > 0) && (_nbytes <= 32));
            ⋮┆----------------------------------------
          886┆ require((_proof[0] == "L") && (_proof[1] == "P") && (_proof[2] ==
  1));                                                                          
            ⋮┆----------------------------------------
       solidity.performance.use-nested-if                                       
          Using nested is cheaper than using && multiple check combinations.    
  There are more                                                                
          advantages, such as easier to read code and better coverage reports.  
                                                                                
          549┆ if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
          550┆ else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
          551┆ else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            ⋮┆----------------------------------------
          550┆ else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;
          551┆ else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            ⋮┆----------------------------------------
          551┆ else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            ⋮┆----------------------------------------
          552┆ if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
          553┆ else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
          554┆ else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            ⋮┆----------------------------------------
          553┆ else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;
          554┆ else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            ⋮┆----------------------------------------
          554┆ else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            ⋮┆----------------------------------------
          645┆ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
          646┆     if (decimals){
          647┆        if (_b == 0) break;
          648┆         else _b--;
          649┆     }
          650┆     mint *= 10;
          651┆     mint += uint(bresult[i]) - 48;
          652┆ } else if (bresult[i] == 46) decimals = true;
            ⋮┆----------------------------------------
         1045┆ if (v != 27 && v != 28)
         1046┆     return (false, 0);
            ⋮┆----------------------------------------
         1232┆ if (_callInterval > 0 && _ratesActive) {
         1233┆   sendQuery(
         1234┆     _queryString,
         1235┆     _callInterval,
         1236┆     _callbackGasLimit,
         1237┆     _queryType
         1238┆   );
         1239┆ }
            ⋮┆----------------------------------------
       solidity.performance.use-prefix-decrement-not-postfix                    
          Consider using the prefix decrement expression whenever the return    
  value is not needed. The                                                      
          prefix decrement expression is cheaper in terms of gas.               
                                                                                
          648┆ else _b--;
            ⋮┆----------------------------------------
       solidity.performance.use-prefix-increment-not-postfix                    
          Consider using the prefix increment expression whenever the return    
  value is not needed. The                                                      
          prefix increment expression is cheaper in terms of gas.               
                                                                                
          565┆ for (uint i = 0; i < minLength; i ++)
            ⋮┆----------------------------------------
          588┆ for (uint i = 0; i < h.length; i ++)
            ⋮┆----------------------------------------
          595┆ subindex++;
            ⋮┆----------------------------------------
          614┆ for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];
            ⋮┆----------------------------------------
          615┆ for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];
            ⋮┆----------------------------------------
          616┆ for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];
            ⋮┆----------------------------------------
          617┆ for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];
            ⋮┆----------------------------------------
          618┆ for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];
            ⋮┆----------------------------------------
          644┆ for (uint i=0; i<bresult.length; i++){
            ⋮┆----------------------------------------
          663┆ len++;
            ⋮┆----------------------------------------
          681┆ for (uint i = 0; i < arrlen; i++) {
            ⋮┆----------------------------------------
          692┆ ctr++;
            ⋮┆----------------------------------------
          694┆ for (i = 0; i < arrlen; i++) {
            ⋮┆----------------------------------------
          696┆ ctr++;
            ⋮┆----------------------------------------
          697┆ for (uint x = 0; x < elemArray[i].length; x++) {
            ⋮┆----------------------------------------
          705┆ ctr++;
            ⋮┆----------------------------------------
          709┆ ctr++;
            ⋮┆----------------------------------------
          712┆ ctr++;
            ⋮┆----------------------------------------
          723┆ for (uint i = 0; i < arrlen; i++) {
            ⋮┆----------------------------------------
          734┆ ctr++;
            ⋮┆----------------------------------------
          736┆ for (i = 0; i < arrlen; i++) {
            ⋮┆----------------------------------------
          738┆ ctr++;
            ⋮┆----------------------------------------
          739┆ for (uint x = 0; x < elemArray[i].length; x++) {
            ⋮┆----------------------------------------
          747┆ ctr++;
            ⋮┆----------------------------------------
          751┆ ctr++;
            ⋮┆----------------------------------------
          754┆ ctr++;
            ⋮┆----------------------------------------
          909┆ for (uint256 i=0; i< n_random_bytes; i++) {

                
                
┌──────────────┐
│ Scan Summary │
└──────────────┘

Ran 48 rules on 1 file: 66 findings.

A new version of Semgrep is available. See https://semgrep.dev/docs/upgrading

Versions prior to 1.43.0 will cease to work with Semgrep.dev after March 11th 2024, please upgrade.
