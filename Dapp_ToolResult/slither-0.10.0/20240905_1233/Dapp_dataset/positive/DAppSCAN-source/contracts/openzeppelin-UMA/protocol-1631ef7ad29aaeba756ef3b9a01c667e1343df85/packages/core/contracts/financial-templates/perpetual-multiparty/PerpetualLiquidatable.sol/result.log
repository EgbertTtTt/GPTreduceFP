'solc --version' running
'solc /sb/PerpetualLiquidatable.sol --combined-json abi,ast,bin,bin-runtime,srcmap,srcmap-runtime,userdoc,devdoc,hashes,compact-format --allow-paths .,/sb' running
Compilation warnings/errors on /sb/PerpetualLiquidatable.sol:
Warning: Contract code size exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on mainnet. Consider enabling the optimizer (with a low "runs" value!), turning off revert strings, or using libraries.
    --> /sb/PerpetualLiquidatable.sol:3541:1:
     |
3541 | contract PerpetualPositionManager is FundingRateApplier {
     | ^ (Relevant source part starts here and spans across multiple lines).

Warning: Contract code size exceeds 24576 bytes (a limit introduced in Spurious Dragon). This contract may not be deployable on mainnet. Consider enabling the optimizer (with a low "runs" value!), turning off revert strings, or using libraries.
    --> /sb/PerpetualLiquidatable.sol:4306:1:
     |
4306 | contract PerpetualLiquidatable is PerpetualPositionManager {
     | ^ (Relevant source part starts here and spans across multiple lines).



Reentrancy in FundingRateApplier._applyEffectiveFundingRate() (../../sb/PerpetualLiquidatable.sol#3465-3493):
	External calls:
	- _latestFundingRatePerSecond = _getLatestFundingRate() (../../sb/PerpetualLiquidatable.sol#3474)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
	- (fundingRate.cumulativeMultiplier,periodRate) = _calculateEffectiveFundingRate(paymentPeriod,_getLatestFundingRate(),fundingRate.cumulativeMultiplier) (../../sb/PerpetualLiquidatable.sol#3477-3481)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
	External calls sending eth:
	- _latestFundingRatePerSecond = _getLatestFundingRate() (../../sb/PerpetualLiquidatable.sol#3474)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	- (fundingRate.cumulativeMultiplier,periodRate) = _calculateEffectiveFundingRate(paymentPeriod,_getLatestFundingRate(),fundingRate.cumulativeMultiplier) (../../sb/PerpetualLiquidatable.sol#3477-3481)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- (fundingRate.cumulativeMultiplier,periodRate) = _calculateEffectiveFundingRate(paymentPeriod,_getLatestFundingRate(),fundingRate.cumulativeMultiplier) (../../sb/PerpetualLiquidatable.sol#3477-3481)
		- cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee)) (../../sb/PerpetualLiquidatable.sol#1954)
	FeePayer.cumulativeFeeMultiplier (../../sb/PerpetualLiquidatable.sol#1739) can be used in cross function reentrancies:
	- FeePayer.constructor(address,address,address) (../../sb/PerpetualLiquidatable.sol#1765-1774)
	- FeePayer.constructor(address,address,address) (../../sb/PerpetualLiquidatable.sol#1765-1774)
	- FeePayer.cumulativeFeeMultiplier (../../sb/PerpetualLiquidatable.sol#1739)
	- (fundingRate.cumulativeMultiplier,periodRate) = _calculateEffectiveFundingRate(paymentPeriod,_getLatestFundingRate(),fundingRate.cumulativeMultiplier) (../../sb/PerpetualLiquidatable.sol#3477-3481)
		- fundingRate.rate = FixedPoint.Signed(price) (../../sb/PerpetualLiquidatable.sol#3431)
		- fundingRate.updateTime = proposalTime (../../sb/PerpetualLiquidatable.sol#3432)
		- fundingRate.proposalTime = 0 (../../sb/PerpetualLiquidatable.sol#3446)
		- fundingRate.proposalTime = 0 (../../sb/PerpetualLiquidatable.sol#3453)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
	- fundingRate.applicationTime = currentTime (../../sb/PerpetualLiquidatable.sol#3492)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
Reentrancy in FundingRateApplier.applyFundingRate() (../../sb/PerpetualLiquidatable.sol#3334-3336):
	External calls:
	- _applyEffectiveFundingRate() (../../sb/PerpetualLiquidatable.sol#3335)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
	- regularFees() (../../sb/PerpetualLiquidatable.sol#3334)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- _applyEffectiveFundingRate() (../../sb/PerpetualLiquidatable.sol#3335)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	- regularFees() (../../sb/PerpetualLiquidatable.sol#3334)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- _applyEffectiveFundingRate() (../../sb/PerpetualLiquidatable.sol#3335)
		- cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee)) (../../sb/PerpetualLiquidatable.sol#1954)
	FeePayer.cumulativeFeeMultiplier (../../sb/PerpetualLiquidatable.sol#1739) can be used in cross function reentrancies:
	- FeePayer.constructor(address,address,address) (../../sb/PerpetualLiquidatable.sol#1765-1774)
	- FeePayer.constructor(address,address,address) (../../sb/PerpetualLiquidatable.sol#1765-1774)
	- FeePayer.cumulativeFeeMultiplier (../../sb/PerpetualLiquidatable.sol#1739)
Reentrancy in FundingRateApplier.applyFundingRate() (../../sb/PerpetualLiquidatable.sol#3334-3336):
	External calls:
	- regularFees() (../../sb/PerpetualLiquidatable.sol#3334)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- regularFees() (../../sb/PerpetualLiquidatable.sol#3334)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3334)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
Reentrancy in PerpetualPositionManager.create(FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3846-3884):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3849)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3849)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3850)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reentrancy in PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#4505-4637):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#4514)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#4514)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#4515)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
	- _reduceSponsorPosition(sponsor,tokensLiquidated,lockedCollateral,withdrawalAmountToRemove) (../../sb/PerpetualLiquidatable.sol#4579)
		- rawTotalPositionCollateral = rawTotalPositionCollateral.sub(positionToLiquidate.rawCollateral) (../../sb/PerpetualLiquidatable.sol#4134)
	PerpetualPositionManager.rawTotalPositionCollateral (../../sb/PerpetualLiquidatable.sol#3572) can be used in cross function reentrancies:
	- PerpetualPositionManager._decrementCollateralBalances(PerpetualPositionManager.PositionData,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#4212-4218)
	- PerpetualPositionManager._deleteSponsorPosition(address) (../../sb/PerpetualLiquidatable.sol#4128-4144)
	- PerpetualPositionManager._incrementCollateralBalances(PerpetualPositionManager.PositionData,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#4200-4206)
	- PerpetualPositionManager._pfc() (../../sb/PerpetualLiquidatable.sol#4146-4148)
	- PerpetualPositionManager.rawTotalPositionCollateral (../../sb/PerpetualLiquidatable.sol#3572)
	- PerpetualPositionManager.totalPositionCollateral() (../../sb/PerpetualLiquidatable.sol#4069-4076)
Reentrancy in PerpetualPositionManager.depositTo(address,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3696-3713):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3700)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3700)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3701)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reentrancy in PerpetualLiquidatable.dispute(uint256,address) (../../sb/PerpetualLiquidatable.sol#4649-4686):
	External calls:
	- _requestOraclePrice(disputedLiquidation.liquidationTime) (../../sb/PerpetualLiquidatable.sol#4670)
		- _getOracle().requestPrice(priceIdentifier,requestedTime) (../../sb/PerpetualLiquidatable.sol#4173)
	- _payFinalFees(msg.sender,disputedLiquidation.finalFee) (../../sb/PerpetualLiquidatable.sol#4682)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- collateralCurrency.safeTransferFrom(payer,address(this),amount.rawValue) (../../sb/PerpetualLiquidatable.sol#1866)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- collateralCurrency.safeIncreaseAllowance(address(store),amount.rawValue) (../../sb/PerpetualLiquidatable.sol#1881)
		- store.payOracleFeesErc20(address(collateralCurrency),amount) (../../sb/PerpetualLiquidatable.sol#1882)
	- fees() (../../sb/PerpetualLiquidatable.sol#4652)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- _payFinalFees(msg.sender,disputedLiquidation.finalFee) (../../sb/PerpetualLiquidatable.sol#4682)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	- fees() (../../sb/PerpetualLiquidatable.sol#4652)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- _payFinalFees(msg.sender,disputedLiquidation.finalFee) (../../sb/PerpetualLiquidatable.sol#4682)
		- cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee)) (../../sb/PerpetualLiquidatable.sol#1954)
	FeePayer.cumulativeFeeMultiplier (../../sb/PerpetualLiquidatable.sol#1739) can be used in cross function reentrancies:
	- FeePayer._adjustCumulativeFeeMultiplier(FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#1950-1955)
	- FeePayer._convertToRawCollateral(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#1909-1915)
	- FeePayer._getFeeAdjustedCollateral(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#1899-1905)
	- FeePayer.constructor(address,address,address) (../../sb/PerpetualLiquidatable.sol#1765-1774)
	- FeePayer.constructor(address,address,address) (../../sb/PerpetualLiquidatable.sol#1765-1774)
	- FeePayer.cumulativeFeeMultiplier (../../sb/PerpetualLiquidatable.sol#1739)
Reentrancy in PerpetualLiquidatable.dispute(uint256,address) (../../sb/PerpetualLiquidatable.sol#4649-4686):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#4652)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#4652)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#4653)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reentrancy in PerpetualPositionManager.emergencyShutdown() (../../sb/PerpetualLiquidatable.sol#4025-4033):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#4025)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#4025)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#4025)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
	- emergencyShutdownTimestamp = getCurrentTime() (../../sb/PerpetualLiquidatable.sol#4029)
	FundingRateApplier.emergencyShutdownTimestamp (../../sb/PerpetualLiquidatable.sol#3260) can be used in cross function reentrancies:
	- FundingRateApplier._applyEffectiveFundingRate() (../../sb/PerpetualLiquidatable.sol#3465-3493)
	- PerpetualPositionManager._notEmergencyShutdown() (../../sb/PerpetualLiquidatable.sol#4242-4245)
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.emergencyShutdownTimestamp (../../sb/PerpetualLiquidatable.sol#3260)
Reentrancy in FundingRateApplier.proposeNewRate(FixedPoint.Signed,uint256) (../../sb/PerpetualLiquidatable.sol#3343-3392):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3345)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3345)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3346)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- fundingRate.proposalTime = timestamp (../../sb/PerpetualLiquidatable.sol#3361)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
Reentrancy in PerpetualPositionManager.redeem(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3895-3932):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3899)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3899)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3900)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
	- amountWithdrawn = _deleteSponsorPosition(msg.sender) (../../sb/PerpetualLiquidatable.sol#3912)
		- delete positions[sponsor] (../../sb/PerpetualLiquidatable.sol#4138)
	PerpetualPositionManager.positions (../../sb/PerpetualLiquidatable.sol#3564) can be used in cross function reentrancies:
	- PerpetualPositionManager._deleteSponsorPosition(address) (../../sb/PerpetualLiquidatable.sol#4128-4144)
	- PerpetualPositionManager._getPositionData(address) (../../sb/PerpetualLiquidatable.sol#4150-4157)
	- PerpetualPositionManager._onlyCollateralizedPosition(address) (../../sb/PerpetualLiquidatable.sol#4235-4240)
	- PerpetualPositionManager.getCollateral(address) (../../sb/PerpetualLiquidatable.sol#4055-4063)
	- PerpetualPositionManager.positions (../../sb/PerpetualLiquidatable.sol#3564)
	- amountWithdrawn = _deleteSponsorPosition(msg.sender) (../../sb/PerpetualLiquidatable.sol#3912)
		- rawTotalPositionCollateral = rawTotalPositionCollateral.sub(positionToLiquidate.rawCollateral) (../../sb/PerpetualLiquidatable.sol#4134)
	PerpetualPositionManager.rawTotalPositionCollateral (../../sb/PerpetualLiquidatable.sol#3572) can be used in cross function reentrancies:
	- PerpetualPositionManager._decrementCollateralBalances(PerpetualPositionManager.PositionData,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#4212-4218)
	- PerpetualPositionManager._deleteSponsorPosition(address) (../../sb/PerpetualLiquidatable.sol#4128-4144)
	- PerpetualPositionManager._incrementCollateralBalances(PerpetualPositionManager.PositionData,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#4200-4206)
	- PerpetualPositionManager._pfc() (../../sb/PerpetualLiquidatable.sol#4146-4148)
	- PerpetualPositionManager.rawTotalPositionCollateral (../../sb/PerpetualLiquidatable.sol#3572)
	- PerpetualPositionManager.totalPositionCollateral() (../../sb/PerpetualLiquidatable.sol#4069-4076)
Reentrancy in PerpetualPositionManager.settleEmergencyShutdown() (../../sb/PerpetualLiquidatable.sol#3956-4012):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3959)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3959)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3960)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reentrancy in PerpetualPositionManager.withdraw(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3733-3755):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3737)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3737)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3738)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reentrancy in PerpetualLiquidatable.withdrawLiquidation(uint256,address) (../../sb/PerpetualLiquidatable.sol#4698-4789):
	External calls:
	- collateralCurrency.safeTransfer(liquidation.disputer,rewards.paidToDisputer.rawValue) (../../sb/PerpetualLiquidatable.sol#4750)
	- collateralCurrency.safeTransfer(liquidation.liquidator,rewards.paidToLiquidator.rawValue) (../../sb/PerpetualLiquidatable.sol#4751)
	- collateralCurrency.safeTransfer(liquidation.sponsor,rewards.paidToSponsor.rawValue) (../../sb/PerpetualLiquidatable.sol#4752)
	- collateralCurrency.safeTransfer(liquidation.liquidator,rewards.paidToLiquidator.rawValue) (../../sb/PerpetualLiquidatable.sol#4762)
	- collateralCurrency.safeTransfer(liquidation.liquidator,rewards.paidToLiquidator.rawValue) (../../sb/PerpetualLiquidatable.sol#4773)
	- fees() (../../sb/PerpetualLiquidatable.sol#4701)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#4701)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- delete liquidations[sponsor][liquidationId] (../../sb/PerpetualLiquidatable.sol#4786)
	PerpetualLiquidatable.liquidations (../../sb/PerpetualLiquidatable.sol#4375) can be used in cross function reentrancies:
	- PerpetualLiquidatable.getLiquidations(address) (../../sb/PerpetualLiquidatable.sol#4796-4803)
	- PerpetualLiquidatable.liquidations (../../sb/PerpetualLiquidatable.sol#4375)
Reentrancy in PerpetualLiquidatable.withdrawLiquidation(uint256,address) (../../sb/PerpetualLiquidatable.sol#4698-4789):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#4701)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#4701)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#4702)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reentrancy in PerpetualPositionManager.withdrawPassedRequest() (../../sb/PerpetualLiquidatable.sol#3789-3820):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3792)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3792)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- nonReentrant() (../../sb/PerpetualLiquidatable.sol#3793)
		- _notEntered = false (../../sb/PerpetualLiquidatable.sol#1537)
		- _notEntered = true (../../sb/PerpetualLiquidatable.sol#1543)
	Lockable._notEntered (../../sb/PerpetualLiquidatable.sol#1492) can be used in cross function reentrancies:
	- Lockable._postEntranceReset() (../../sb/PerpetualLiquidatable.sol#1540-1544)
	- Lockable._preEntranceCheck() (../../sb/PerpetualLiquidatable.sol#1530-1533)
	- Lockable._preEntranceSet() (../../sb/PerpetualLiquidatable.sol#1535-1538)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities

PerpetualPositionManager.redeem(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3895-3932) performs a multiplication on the result of a division:
	- fractionRedeemed = numTokens.div(positionData.tokensOutstanding) (../../sb/PerpetualLiquidatable.sol#3906)
	- collateralRedeemed = fractionRedeemed.mul(_getFeeAdjustedCollateral(positionData.rawCollateral)) (../../sb/PerpetualLiquidatable.sol#3907-3908)
PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#4505-4637) performs a multiplication on the result of a division:
	- ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding) (../../sb/PerpetualLiquidatable.sol#4566)
	- lockedCollateral = startCollateral.mul(ratio) (../../sb/PerpetualLiquidatable.sol#4569)
PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#4505-4637) performs a multiplication on the result of a division:
	- ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding) (../../sb/PerpetualLiquidatable.sol#4566)
	- liquidatedCollateral = startCollateralNetOfWithdrawal.mul(ratio) (../../sb/PerpetualLiquidatable.sol#4573)
PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#4505-4637) performs a multiplication on the result of a division:
	- ratio = tokensLiquidated.div(positionToLiquidate.tokensOutstanding) (../../sb/PerpetualLiquidatable.sol#4566)
	- withdrawalAmountToRemove = positionToLiquidate.withdrawalRequestAmount.mul(ratio) (../../sb/PerpetualLiquidatable.sol#4577-4578)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply

FeePayer.payRegularFees() (../../sb/PerpetualLiquidatable.sol#1789-1840) uses a dangerous strict equality:
	- lastPaymentTime == time (../../sb/PerpetualLiquidatable.sol#1803)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#dangerous-strict-equalities

Reentrancy in FundingRateApplier._getLatestFundingRate() (../../sb/PerpetualLiquidatable.sol#3413-3458):
	External calls:
	- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
	State variables written after the call(s):
	- fundingRate.rate = FixedPoint.Signed(price) (../../sb/PerpetualLiquidatable.sol#3431)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
	- fundingRate.updateTime = proposalTime (../../sb/PerpetualLiquidatable.sol#3432)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
	- fundingRate.proposalTime = 0 (../../sb/PerpetualLiquidatable.sol#3453)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
Reentrancy in FundingRateApplier._getLatestFundingRate() (../../sb/PerpetualLiquidatable.sol#3413-3458):
	External calls:
	- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
	- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
	State variables written after the call(s):
	- fundingRate.proposalTime = 0 (../../sb/PerpetualLiquidatable.sol#3446)
	FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257) can be used in cross function reentrancies:
	- FundingRateApplier.constructor(bytes32,address,address,address,FixedPoint.Unsigned,address) (../../sb/PerpetualLiquidatable.sol#3303-3322)
	- FundingRateApplier.fundingRate (../../sb/PerpetualLiquidatable.sol#3257)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-1

PerpetualLiquidatable.withdrawLiquidation(uint256,address).rewards (../../sb/PerpetualLiquidatable.sol#4729) is a local variable never initialized
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#uninitialized-local-variables

FundingRateApplier.proposeNewRate(FixedPoint.Signed,uint256) (../../sb/PerpetualLiquidatable.sol#3343-3392) ignores return value by optimisticOracle.requestPrice(identifier,timestamp,ancillaryData,collateralCurrency,0) (../../sb/PerpetualLiquidatable.sol#3368)
FundingRateApplier.proposeNewRate(FixedPoint.Signed,uint256) (../../sb/PerpetualLiquidatable.sol#3343-3392) ignores return value by optimisticOracle.proposePriceFor(msg.sender,address(this),identifier,timestamp,ancillaryData,rate.rawValue) (../../sb/PerpetualLiquidatable.sol#3384-3391)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return

Reentrancy in FundingRateApplier._getLatestFundingRate() (../../sb/PerpetualLiquidatable.sol#3413-3458):
	External calls:
	- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
	State variables written after the call(s):
	- _adjustCumulativeFeeMultiplier(reward,_pfc()) (../../sb/PerpetualLiquidatable.sol#3439)
		- cumulativeFeeMultiplier = cumulativeFeeMultiplier.mul(FixedPoint.fromUnscaledUint(1).sub(effectiveFee)) (../../sb/PerpetualLiquidatable.sol#1954)
Reentrancy in PerpetualPositionManager.create(FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3846-3884):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3849)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3849)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- positionData.tokensOutstanding = positionData.tokensOutstanding.add(numTokens) (../../sb/PerpetualLiquidatable.sol#3873)
	- totalTokensOutstanding = totalTokensOutstanding.add(numTokens) (../../sb/PerpetualLiquidatable.sol#3875)
Reentrancy in PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#4505-4637):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#4514)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#4514)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- liquidations[sponsor].push(LiquidationData({sponsor:sponsor,liquidator:msg.sender,state:Status.PreDispute,liquidationTime:getCurrentTime(),tokensOutstanding:_getFundingRateAppliedTokenDebt(tokensLiquidated),lockedCollateral:lockedCollateral,liquidatedCollateral:liquidatedCollateral,rawUnitCollateral:_convertToRawCollateral(FixedPoint.fromUnscaledUint(1)),disputer:address(0),settlementPrice:FixedPoint.fromUnscaledUint(0),finalFee:finalFeeBond})) (../../sb/PerpetualLiquidatable.sol#4589-4603)
	- _reduceSponsorPosition(sponsor,tokensLiquidated,lockedCollateral,withdrawalAmountToRemove) (../../sb/PerpetualLiquidatable.sol#4579)
		- delete positions[sponsor] (../../sb/PerpetualLiquidatable.sol#4138)
	- _reduceSponsorPosition(sponsor,tokensLiquidated,lockedCollateral,withdrawalAmountToRemove) (../../sb/PerpetualLiquidatable.sol#4579)
		- totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding) (../../sb/PerpetualLiquidatable.sol#4135)
		- totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRemove) (../../sb/PerpetualLiquidatable.sol#4124)
Reentrancy in PerpetualPositionManager.redeem(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3895-3932):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3899)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3899)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- amountWithdrawn = _deleteSponsorPosition(msg.sender) (../../sb/PerpetualLiquidatable.sol#3912)
		- totalTokensOutstanding = totalTokensOutstanding.sub(positionToLiquidate.tokensOutstanding) (../../sb/PerpetualLiquidatable.sol#4135)
	- totalTokensOutstanding = totalTokensOutstanding.sub(numTokens) (../../sb/PerpetualLiquidatable.sol#3923)
Reentrancy in PerpetualPositionManager.settleEmergencyShutdown() (../../sb/PerpetualLiquidatable.sol#3956-4012):
	External calls:
	- fees() (../../sb/PerpetualLiquidatable.sol#3959)
		- returndata = address(token).functionCall(data,SafeERC20: low-level call failed) (../../sb/PerpetualLiquidatable.sol#537)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
		- price = optimisticOracle.getPrice(identifier,proposalTime,ancillaryData) (../../sb/PerpetualLiquidatable.sol#3422-3455)
		- collateralCurrency.safeTransfer(request.proposer,reward.rawValue) (../../sb/PerpetualLiquidatable.sol#3440)
		- collateralCurrency.safeIncreaseAllowance(address(store),regularFee.rawValue) (../../sb/PerpetualLiquidatable.sol#1832)
		- store.payOracleFeesErc20(address(collateralCurrency),regularFee) (../../sb/PerpetualLiquidatable.sol#1833)
		- collateralCurrency.safeTransfer(msg.sender,latePenalty.rawValue) (../../sb/PerpetualLiquidatable.sol#1837)
	External calls sending eth:
	- fees() (../../sb/PerpetualLiquidatable.sol#3959)
		- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
	State variables written after the call(s):
	- emergencyShutdownPrice = _getOracleEmergencyShutdownPrice() (../../sb/PerpetualLiquidatable.sol#3965)
	- delete positions[msg.sender] (../../sb/PerpetualLiquidatable.sol#3993)
	- totalTokensOutstanding = totalTokensOutstanding.sub(tokensToRedeem) (../../sb/PerpetualLiquidatable.sol#4004)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2

Reentrancy in FeePayer._payFinalFees(address,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#1859-1883):
	External calls:
	- collateralCurrency.safeTransferFrom(payer,address(this),amount.rawValue) (../../sb/PerpetualLiquidatable.sol#1866)
	Event emitted after the call(s):
	- FinalFeesPaid(amount.rawValue) (../../sb/PerpetualLiquidatable.sol#1878)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3

FeePayer.payRegularFees() (../../sb/PerpetualLiquidatable.sol#1789-1840) uses timestamp for comparisons
	Dangerous comparisons:
	- lastPaymentTime == time (../../sb/PerpetualLiquidatable.sol#1803)
OptimisticOracle.getState(address,bytes32,uint256,bytes) (../../sb/PerpetualLiquidatable.sol#3052-3080) uses timestamp for comparisons
	Dangerous comparisons:
	- request.expirationTime <= getCurrentTime() (../../sb/PerpetualLiquidatable.sol#3073)
FundingRateApplier.proposeNewRate(FixedPoint.Signed,uint256) (../../sb/PerpetualLiquidatable.sol#3343-3392) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(fundingRate.proposalTime == 0,Proposal in progress) (../../sb/PerpetualLiquidatable.sol#3349)
	- require(bool,string)(timestamp > updateTime && timestamp >= currentTime.sub(1800) && timestamp <= currentTime.add(90),Invalid proposal time) (../../sb/PerpetualLiquidatable.sol#3355-3358)
FundingRateApplier._getLatestFundingRate() (../../sb/PerpetualLiquidatable.sol#3413-3458) uses timestamp for comparisons
	Dangerous comparisons:
	- proposalTime != 0 (../../sb/PerpetualLiquidatable.sol#3415)
	- proposalTime >= lastUpdateTime (../../sb/PerpetualLiquidatable.sol#3429)
	- request.disputer == address(0) (../../sb/PerpetualLiquidatable.sol#3435)
	- optimisticOracle.getRequest(address(this),identifier,proposalTime,ancillaryData).disputer != address(0) (../../sb/PerpetualLiquidatable.sol#3450-3451)
PerpetualPositionManager.requestWithdrawal(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3762-3780) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(collateralAmount.isGreaterThan(0) && collateralAmount.isLessThanOrEqual(_getFeeAdjustedCollateral(positionData.rawCollateral)),Invalid collateral amount) (../../sb/PerpetualLiquidatable.sol#3769-3773)
PerpetualPositionManager.withdrawPassedRequest() (../../sb/PerpetualLiquidatable.sol#3789-3820) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(positionData.withdrawalRequestPassTimestamp != 0 && positionData.withdrawalRequestPassTimestamp <= getCurrentTime(),Invalid withdraw request) (../../sb/PerpetualLiquidatable.sol#3797-3801)
PerpetualPositionManager.create(FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#3846-3884) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)((_checkCollateralization(_getFeeAdjustedCollateral(positionData.rawCollateral).add(collateralAmount),positionData.tokensOutstanding.add(numTokens)) || _checkCollateralization(collateralAmount,numTokens)),Insufficient collateral) (../../sb/PerpetualLiquidatable.sol#3855-3861)
PerpetualPositionManager._reduceSponsorPosition(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#4093-4125) uses timestamp for comparisons
	Dangerous comparisons:
	- tokensToRemove.isEqual(positionData.tokensOutstanding) && _getFeeAdjustedCollateral(positionData.rawCollateral).isEqual(collateralToRemove) (../../sb/PerpetualLiquidatable.sol#4103-4104)
PerpetualPositionManager._notEmergencyShutdown() (../../sb/PerpetualLiquidatable.sol#4242-4245) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool)(emergencyShutdownTimestamp == 0) (../../sb/PerpetualLiquidatable.sol#4244)
PerpetualPositionManager._isEmergencyShutdown() (../../sb/PerpetualLiquidatable.sol#4247-4250) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool)(emergencyShutdownTimestamp != 0) (../../sb/PerpetualLiquidatable.sol#4249)
PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#4505-4637) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)(getCurrentTime() <= deadline,Mined after deadline) (../../sb/PerpetualLiquidatable.sol#4523)
	- require(bool,string)(maxCollateralPerToken.mul(startTokens).isGreaterThanOrEqual(startCollateralNetOfWithdrawal),CR is more than max liq. price) (../../sb/PerpetualLiquidatable.sol#4544-4547)
	- require(bool,string)(minCollateralPerToken.mul(startTokens).isLessThanOrEqual(startCollateralNetOfWithdrawal),CR is less than min liq. price) (../../sb/PerpetualLiquidatable.sol#4549-4552)
	- positionToLiquidate.withdrawalRequestPassTimestamp > 0 && positionToLiquidate.withdrawalRequestPassTimestamp > getCurrentTime() && tokensLiquidated.isGreaterThanOrEqual(griefingThreshold) (../../sb/PerpetualLiquidatable.sol#4614-4616)
PerpetualLiquidatable._disputable(uint256,address) (../../sb/PerpetualLiquidatable.sol#4872-4878) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)((getCurrentTime() < _getLiquidationExpiry(liquidation)) && (liquidation.state == Status.PreDispute),Liquidation not disputable) (../../sb/PerpetualLiquidatable.sol#4874-4877)
PerpetualLiquidatable._withdrawable(uint256,address) (../../sb/PerpetualLiquidatable.sol#4880-4890) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool,string)((state > Status.PreDispute) || ((_getLiquidationExpiry(liquidation) <= getCurrentTime()) && (state == Status.PreDispute)),Liquidation not withdrawable) (../../sb/PerpetualLiquidatable.sol#4885-4889)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp

Address.isContract(address) (../../sb/PerpetualLiquidatable.sol#312-321) uses assembly
	- INLINE ASM (../../sb/PerpetualLiquidatable.sol#319)
Address._verifyCallResult(bool,bytes,string) (../../sb/PerpetualLiquidatable.sol#457-474) uses assembly
	- INLINE ASM (../../sb/PerpetualLiquidatable.sol#466-469)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage

Address.functionCall(address,bytes) (../../sb/PerpetualLiquidatable.sol#365-367) is never used and should be removed
Address.functionCallWithValue(address,bytes,uint256) (../../sb/PerpetualLiquidatable.sol#390-392) is never used and should be removed
Address.functionDelegateCall(address,bytes) (../../sb/PerpetualLiquidatable.sol#439-441) is never used and should be removed
Address.functionDelegateCall(address,bytes,string) (../../sb/PerpetualLiquidatable.sol#449-455) is never used and should be removed
Address.functionStaticCall(address,bytes) (../../sb/PerpetualLiquidatable.sol#415-417) is never used and should be removed
Address.functionStaticCall(address,bytes,string) (../../sb/PerpetualLiquidatable.sol#425-431) is never used and should be removed
Address.sendValue(address,uint256) (../../sb/PerpetualLiquidatable.sol#339-345) is never used and should be removed
Context._msgData() (../../sb/PerpetualLiquidatable.sol#2466-2469) is never used and should be removed
FixedPoint.add(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1213-1215) is never used and should be removed
FixedPoint.add(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#836-838) is never used and should be removed
FixedPoint.div(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1313-1320) is never used and should be removed
FixedPoint.div(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1329-1331) is never used and should be removed
FixedPoint.div(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#949-951) is never used and should be removed
FixedPoint.div(int256,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1340-1342) is never used and should be removed
FixedPoint.div(uint256,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#960-962) is never used and should be removed
FixedPoint.divAwayFromZero(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1350-1362) is never used and should be removed
FixedPoint.divAwayFromZero(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1370-1375) is never used and should be removed
FixedPoint.divCeil(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#987-992) is never used and should be removed
FixedPoint.fromUnsigned(FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#1023-1026) is never used and should be removed
FixedPoint.isEqual(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1053-1055) is never used and should be removed
FixedPoint.isEqual(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1043-1045) is never used and should be removed
FixedPoint.isGreaterThan(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1063-1065) is never used and should be removed
FixedPoint.isGreaterThan(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1073-1075) is never used and should be removed
FixedPoint.isGreaterThan(int256,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1083-1085) is never used and should be removed
FixedPoint.isGreaterThan(uint256,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#706-708) is never used and should be removed
FixedPoint.isGreaterThanOrEqual(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1093-1095) is never used and should be removed
FixedPoint.isGreaterThanOrEqual(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1103-1105) is never used and should be removed
FixedPoint.isGreaterThanOrEqual(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#726-728) is never used and should be removed
FixedPoint.isGreaterThanOrEqual(int256,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1113-1115) is never used and should be removed
FixedPoint.isGreaterThanOrEqual(uint256,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#736-738) is never used and should be removed
FixedPoint.isLessThan(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1123-1125) is never used and should be removed
FixedPoint.isLessThan(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1133-1135) is never used and should be removed
FixedPoint.isLessThan(int256,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1143-1145) is never used and should be removed
FixedPoint.isLessThan(uint256,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#766-768) is never used and should be removed
FixedPoint.isLessThanOrEqual(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1153-1155) is never used and should be removed
FixedPoint.isLessThanOrEqual(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1163-1165) is never used and should be removed
FixedPoint.isLessThanOrEqual(int256,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1173-1175) is never used and should be removed
FixedPoint.isLessThanOrEqual(uint256,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#796-798) is never used and should be removed
FixedPoint.max(FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#816-818) is never used and should be removed
FixedPoint.min(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1183-1185) is never used and should be removed
FixedPoint.mul(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1254-1262) is never used and should be removed
FixedPoint.mulAwayFromZero(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1281-1293) is never used and should be removed
FixedPoint.mulAwayFromZero(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1301-1304) is never used and should be removed
FixedPoint.mulCeil(FixedPoint.Unsigned,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#904-913) is never used and should be removed
FixedPoint.mulCeil(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#921-924) is never used and should be removed
FixedPoint.pow(FixedPoint.Signed,uint256) (../../sb/PerpetualLiquidatable.sol#1384-1389) is never used and should be removed
FixedPoint.pow(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#1001-1006) is never used and should be removed
FixedPoint.sub(FixedPoint.Signed,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1223-1225) is never used and should be removed
FixedPoint.sub(FixedPoint.Signed,int256) (../../sb/PerpetualLiquidatable.sol#1233-1235) is never used and should be removed
FixedPoint.sub(FixedPoint.Unsigned,uint256) (../../sb/PerpetualLiquidatable.sol#856-858) is never used and should be removed
FixedPoint.sub(int256,FixedPoint.Signed) (../../sb/PerpetualLiquidatable.sol#1243-1245) is never used and should be removed
FixedPoint.sub(uint256,FixedPoint.Unsigned) (../../sb/PerpetualLiquidatable.sol#866-868) is never used and should be removed
SafeCast.toInt128(int256) (../../sb/PerpetualLiquidatable.sol#2075-2078) is never used and should be removed
SafeCast.toInt16(int256) (../../sb/PerpetualLiquidatable.sol#2129-2132) is never used and should be removed
SafeCast.toInt32(int256) (../../sb/PerpetualLiquidatable.sol#2111-2114) is never used and should be removed
SafeCast.toInt64(int256) (../../sb/PerpetualLiquidatable.sol#2093-2096) is never used and should be removed
SafeCast.toInt8(int256) (../../sb/PerpetualLiquidatable.sol#2147-2150) is never used and should be removed
SafeCast.toUint128(uint256) (../../sb/PerpetualLiquidatable.sol#1985-1988) is never used and should be removed
SafeCast.toUint16(uint256) (../../sb/PerpetualLiquidatable.sol#2030-2033) is never used and should be removed
SafeCast.toUint256(int256) (../../sb/PerpetualLiquidatable.sol#2057-2060) is never used and should be removed
SafeCast.toUint32(uint256) (../../sb/PerpetualLiquidatable.sol#2015-2018) is never used and should be removed
SafeCast.toUint64(uint256) (../../sb/PerpetualLiquidatable.sol#2000-2003) is never used and should be removed
SafeCast.toUint8(uint256) (../../sb/PerpetualLiquidatable.sol#2045-2048) is never used and should be removed
SafeERC20.safeApprove(IERC20,address,uint256) (../../sb/PerpetualLiquidatable.sol#505-514) is never used and should be removed
SafeERC20.safeDecreaseAllowance(IERC20,address,uint256) (../../sb/PerpetualLiquidatable.sol#521-524) is never used and should be removed
SafeMath.div(uint256,uint256,string) (../../sb/PerpetualLiquidatable.sol#191-194) is never used and should be removed
SafeMath.mod(uint256,uint256,string) (../../sb/PerpetualLiquidatable.sol#211-214) is never used and should be removed
SafeMath.sub(uint256,uint256,string) (../../sb/PerpetualLiquidatable.sol#171-174) is never used and should be removed
SafeMath.tryAdd(uint256,uint256) (../../sb/PerpetualLiquidatable.sol#25-29) is never used and should be removed
SafeMath.tryDiv(uint256,uint256) (../../sb/PerpetualLiquidatable.sol#61-64) is never used and should be removed
SafeMath.tryMod(uint256,uint256) (../../sb/PerpetualLiquidatable.sol#71-74) is never used and should be removed
SafeMath.tryMul(uint256,uint256) (../../sb/PerpetualLiquidatable.sol#46-54) is never used and should be removed
SafeMath.trySub(uint256,uint256) (../../sb/PerpetualLiquidatable.sol#36-39) is never used and should be removed
SignedSafeMath.div(int256,int256) (../../sb/PerpetualLiquidatable.sol#590-597) is never used and should be removed
SignedSafeMath.sub(int256,int256) (../../sb/PerpetualLiquidatable.sol#609-614) is never used and should be removed
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#dead-code

Pragma version^0.6.0 (../../sb/PerpetualLiquidatable.sol#1) allows old versions
solc-0.6.12 is not recommended for deployment
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity

Low level call in Address.sendValue(address,uint256) (../../sb/PerpetualLiquidatable.sol#339-345):
	- (success) = recipient.call{value: amount}() (../../sb/PerpetualLiquidatable.sol#343)
Low level call in Address.functionCallWithValue(address,bytes,uint256,string) (../../sb/PerpetualLiquidatable.sol#400-407):
	- (success,returndata) = target.call{value: value}(data) (../../sb/PerpetualLiquidatable.sol#405)
Low level call in Address.functionStaticCall(address,bytes,string) (../../sb/PerpetualLiquidatable.sol#425-431):
	- (success,returndata) = target.staticcall(data) (../../sb/PerpetualLiquidatable.sol#429)
Low level call in Address.functionDelegateCall(address,bytes,string) (../../sb/PerpetualLiquidatable.sol#449-455):
	- (success,returndata) = target.delegatecall(data) (../../sb/PerpetualLiquidatable.sol#453)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#low-level-calls

Redundant expression "this (../../sb/PerpetualLiquidatable.sol#2467)" inContext (../../sb/PerpetualLiquidatable.sol#2461-2470)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#redundant-statements

Variable PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256).maxCollateralPerToken (../../sb/PerpetualLiquidatable.sol#4508) is too similar to PerpetualLiquidatable.createLiquidation(address,FixedPoint.Unsigned,FixedPoint.Unsigned,FixedPoint.Unsigned,uint256).minCollateralPerToken (../../sb/PerpetualLiquidatable.sol#4507)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#variable-names-too-similar

Loop condition i < whitelistIndices.length (../../sb/PerpetualLiquidatable.sol#2599) should use cached array length instead of referencing `length` member of the storage array.
 Loop condition i_scope_0 < whitelistIndices.length (../../sb/PerpetualLiquidatable.sol#2608) should use cached array length instead of referencing `length` member of the storage array.
 Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#cache-array-length

FeePayer.collateralCurrency (../../sb/PerpetualLiquidatable.sol#1724) should be immutable 
FeePayer.finder (../../sb/PerpetualLiquidatable.sol#1727) should be immutable 
FundingRateApplier.configStore (../../sb/PerpetualLiquidatable.sol#3263) should be immutable 
OptimisticOracle.defaultLiveness (../../sb/PerpetualLiquidatable.sol#2715) should be immutable 
OptimisticOracle.finder (../../sb/PerpetualLiquidatable.sol#2712) should be immutable 
PerpetualLiquidatable.liquidationLiveness (../../sb/PerpetualLiquidatable.sol#4387) should be immutable 
PerpetualPositionManager.priceIdentifier (../../sb/PerpetualLiquidatable.sol#3578) should be immutable 
PerpetualPositionManager.tokenCurrency (../../sb/PerpetualLiquidatable.sol#3575) should be immutable 
PerpetualPositionManager.withdrawalLiveness (../../sb/PerpetualLiquidatable.sol#3585) should be immutable 
Testable.timerAddress (../../sb/PerpetualLiquidatable.sol#1582) should be immutable 
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-immutable
/sb/PerpetualLiquidatable.sol analyzed (29 contracts with 93 detectors), 142 result(s) found
