'solc --version' running
'solc /sb/DTT.sol --combined-json abi,ast,bin,bin-runtime,srcmap,srcmap-runtime,userdoc,devdoc,hashes,compact-format --allow-paths .,/sb' running
Compilation warnings/errors on /sb/DTT.sol:
/sb/DTT.sol:35:45: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
    bytes32 public sigDestinationTransfer = keccak256(
                                            ^ (Relevant source part starts here and spans across multiple lines).
/sb/DTT.sol:44:49: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
    bytes32 public sigDestinationTransferFrom = keccak256(
                                                ^ (Relevant source part starts here and spans across multiple lines).
/sb/DTT.sol:54:44: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
    bytes32 public sigDestinationApprove = keccak256(
                                           ^ (Relevant source part starts here and spans across multiple lines).
/sb/DTT.sol:63:51: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
    bytes32 public sigDestinationApproveAndCall = keccak256( // `approveAndCallViaSignature`
                                                  ^ (Relevant source part starts here and spans across multiple lines).
/sb/DTT.sol:136:21: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
                    keccak256(
                    ^ (Relevant source part starts here and spans across multiple lines).
/sb/DTT.sol:151:37: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
                signer == ecrecover(keccak256(ethSignedMessagePrefix, "32", data), v, r, s) // Geth-adopted
                                    ^-------------------------------------------^
/sb/DTT.sol:153:37: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\x20", data), v, r, s) // Trezor-adopted
                                    ^---------------------------------------------^
/sb/DTT.sol:157:37: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
                signer == ecrecover(keccak256(ethSignedMessagePrefix, "64", hexToString(data)), v, r, s) // Geth
                                    ^--------------------------------------------------------^
/sb/DTT.sol:159:37: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
                signer == ecrecover(keccak256(ethSignedMessagePrefix, "\x40", hexToString(data)), v, r, s) // Trezor
                                    ^----------------------------------------------------------^
/sb/DTT.sol:216:13: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
            keccak256(address(this), from, to, value, fee, deadline, sigId),
            ^-------------------------------------------------------------^
/sb/DTT.sol:262:13: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
            keccak256(address(this), from, spender, value, fee, deadline, sigId),
            ^------------------------------------------------------------------^
/sb/DTT.sol:304:13: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
            keccak256(address(this), signer, from, to, value, fee, deadline, sigId),
            ^---------------------------------------------------------------------^
/sb/DTT.sol:352:13: Warning: This function only accepts a single "bytes" argument. Please use "abi.encodePacked(...)" or a similar function to encode the data.
            keccak256(address(this), from, spender, value, extraData, fee, deadline, sigId),
            ^-----------------------------------------------------------------------------^


DTT.rescueTokens(DTT,uint256) (../../sb/DTT.sol#414-417) ignores return value by tokenContract.approve(rescueAccount,value) (../../sb/DTT.sol#416)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#unused-return

DTT.changeRescueAccount(address).newRescueAccount (../../sb/DTT.sol#423) lacks a zero-check on :
		- rescueAccount = newRescueAccount (../../sb/DTT.sol#425)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#missing-zero-address-validation

Reentrancy in DTT.approveAndCallViaSignature(address,address,uint256,bytes,uint256,uint256,uint256,bytes,DTT.sigStandard) (../../sb/DTT.sol#340-360):
	External calls:
	- tokenRecipient(spender).receiveApproval(from,value,this,extraData) (../../sb/DTT.sol#357)
	State variables written after the call(s):
	- internalTransfer(from,msg.sender,fee) (../../sb/DTT.sol#358)
		- balanceOf[from] -= value (../../sb/DTT.sol#86)
		- balanceOf[to] += value (../../sb/DTT.sol#87)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-2

Reentrancy in DTT.approveAndCallViaSignature(address,address,uint256,bytes,uint256,uint256,uint256,bytes,DTT.sigStandard) (../../sb/DTT.sol#340-360):
	External calls:
	- tokenRecipient(spender).receiveApproval(from,value,this,extraData) (../../sb/DTT.sol#357)
	Event emitted after the call(s):
	- Transfer(from,to,value) (../../sb/DTT.sol#88)
		- internalTransfer(from,msg.sender,fee) (../../sb/DTT.sol#358)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#reentrancy-vulnerabilities-3

DTT.requireSignature(bytes32,address,uint256,uint256,bytes,DTT.sigStandard,DTT.sigDestination) (../../sb/DTT.sol#119-163) uses timestamp for comparisons
	Dangerous comparisons:
	- require(bool)(block.timestamp <= deadline && ! usedSigIds[signer][sigId]) (../../sb/DTT.sol#132)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp

DTT.requireSignature(bytes32,address,uint256,uint256,bytes,DTT.sigStandard,DTT.sigDestination) (../../sb/DTT.sol#119-163) uses assembly
	- INLINE ASM (../../sb/DTT.sol#125-130)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#assembly-usage

Pragma version^0.4.23 (../../sb/DTT.sol#1) allows old versions
solc-0.4.26 is not recommended for deployment
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#incorrect-versions-of-solidity

Contract tokenRecipient (../../sb/DTT.sol#4-6) is not in CapWords
Enum DTT.sigStandard (../../sb/DTT.sol#33) is not in CapWords
Enum DTT.sigDestination (../../sb/DTT.sol#34) is not in CapWords
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#conformance-to-solidity-naming-conventions

DTT.decimals (../../sb/DTT.sol#21) should be constant 
DTT.ethSignedMessagePrefix (../../sb/DTT.sol#32) should be constant 
DTT.sigDestinationApprove (../../sb/DTT.sol#54-62) should be constant 
DTT.sigDestinationApproveAndCall (../../sb/DTT.sol#63-72) should be constant 
DTT.sigDestinationTransfer (../../sb/DTT.sol#35-43) should be constant 
DTT.sigDestinationTransferFrom (../../sb/DTT.sol#44-53) should be constant 
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant

approveAndCall(address,uint256,bytes) should be declared external:
	- DTT.approveAndCall(address,uint256,bytes) (../../sb/DTT.sol#321-325)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#public-function-that-could-be-declared-external
/sb/DTT.sol analyzed (2 contracts with 93 detectors), 18 result(s) found
